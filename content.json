{"pages":[{"title":"","text":"blog_2 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc < 2.8). document.addEventListener('DOMContentLoaded', function(e) { var hs = document.querySelectorAll(\"div.section[class*='level'] > :first-child\"); var i, h, a; for (i = 0; i < hs.length; i++) { h = hs[i]; if (!/^h[1-6]$/i.test(h.tagName)) continue; // it should be a header h1-h6 a = h.attributes; while (a.length > 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(C,e){\"use strict\";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return\"function\"==typeof e&&\"number\"!=typeof e.nodeType&&\"function\"!=typeof e.item},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement(\"script\");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?n[o.call(e)]||\"object\":typeof e}var f=\"3.6.0\",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&\"length\"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&(\"array\"===n||0===t||\"number\"==typeof t&&0","link":"/Images/blog2.html"},{"title":"","text":"r_blog // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc < 2.8). document.addEventListener('DOMContentLoaded', function(e) { var hs = document.querySelectorAll(\"div.section[class*='level'] > :first-child\"); var i, h, a; for (i = 0; i < hs.length; i++) { h = hs[i]; if (!/^h[1-6]$/i.test(h.tagName)) continue; // it should be a header h1-h6 a = h.attributes; while (a.length > 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(C,e){\"use strict\";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return\"function\"==typeof e&&\"number\"!=typeof e.nodeType&&\"function\"!=typeof e.item},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement(\"script\");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?n[o.call(e)]||\"object\":typeof e}var f=\"3.6.0\",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&\"length\"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&(\"array\"===n||0===t||\"number\"==typeof t&&0","link":"/Images/gg.html"},{"title":"","text":"서울의 음식점 현황 분석 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc < 2.8). document.addEventListener('DOMContentLoaded', function(e) { var hs = document.querySelectorAll(\"div.section[class*='level'] > :first-child\"); var i, h, a; for (i = 0; i < hs.length; i++) { h = hs[i]; if (!/^h[1-6]$/i.test(h.tagName)) continue; // it should be a header h1-h6 a = h.attributes; while (a.length > 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(C,e){\"use strict\";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return\"function\"==typeof e&&\"number\"!=typeof e.nodeType&&\"function\"!=typeof e.item},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement(\"script\");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?n[o.call(e)]||\"object\":typeof e}var f=\"3.6.0\",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&\"length\"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&(\"array\"===n||0===t||\"number\"==typeof t&&0","link":"/Images/report2.html"}],"posts":[{"title":"핵소 사용법","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 어서오세요","link":"/2022/03/18/hello-world/"},{"title":"분석방법","text":"기술통계 평균, 최솟값, 최댓값, 중앙값과같이 데이터의 특징을 알려주는 값. 기술통계(descriptive statistics)라고 함. 추론통계 변수간의 관계를 파악, 변수간의 인과관계 또는 새로운 사실 밝혀냄 평균 차이 검정, 교차분석, 상관관계분석, 회귀분석 귀무가설: 두 집단의 평균 차이가 없다. (현상황을 유지 할 필요가 있음) 대립가설: 두 집단의 평균 차이가 있다. (현상황을 바꿀 필요가 있음) 평균차이검정 집단별로 평균의 차이가 실제로 있는가 검정 독립표본 t 검정 방법1 : t.test(data= 데이터세트, 종속변수(비교값)~독립변수(비교대상)) 방법2 : t.test(데이터세트$종속변수(비교값)~데이터세트$독립변수(비교대상)) 123mpg1 = read.csv(&quot;source_2021/1_day_eda/solution/data/public_dataset/mpg1.csv&quot;, stringsAsFactors = F)t.test(data = mpg1, cty~ trans) 1234567891011## ## Welch Two Sample t-test## ## data: cty by trans## t = -4.5375, df = 132.32, p-value = 1.263e-05## alternative hypothesis: true difference in means between group auto and group manual is not equal to 0## 95 percent confidence interval:## -3.887311 -1.527033## sample estimates:## mean in group auto mean in group manual ## 15.96815 18.67532 -&gt; p-value = 1.263e-05로 0.05보다 작으므로 평균차이가 있는 대립가설을 채택 교차분석 범주형 변수로 구성된 집단들의 관련성을 검정하는 통계 분석. 12mpg1 = read.csv(&quot;source_2021/1_day_eda/solution/data/public_dataset/mpg1.csv&quot;, stringsAsFactors = F)table(mpg1$trans, mpg1$drv) #trans, drv의 교차분석 1234## ## 4 f r## auto 75 65 17## manual 28 41 8 1prop.table(table(mpg1$trans, mpg1$drv), 1) #auto, manual의 비율분석 1234## ## 4 f r## auto 0.4777070 0.4140127 0.1082803## manual 0.3636364 0.5324675 0.1038961 12mpg1 = read.csv(&quot;source_2021/1_day_eda/solution/data/public_dataset/mpg1.csv&quot;, stringsAsFactors = F)chisq.test(mpg1$trans, mpg1$drv) 12345## ## Pearson's Chi-squared test## ## data: mpg1$trans and mpg1$drv## X-squared = 3.1368, df = 2, p-value = 0.2084 12# == chisq.test(table(mpg1$trans, mpg1$drv))# == summary(table(mpg1$trans, mpg1$drv)) -&gt; p-value = 0.2084로 0.05보다 크므로 귀무가설을 채택 상관관계분석 변수간의 상관관계를 알아보는것 방법 : cor.test(데이터세트$ 비교변수1, 데이터세트$비교변수2) 12mpg1 = read.csv(&quot;source_2021/1_day_eda/solution/data/public_dataset/mpg1.csv&quot;, stringsAsFactors = F)cor.test(mpg1$cty, mpg1$hwy) 1234567891011## ## Pearson's product-moment correlation## ## data: mpg1$cty and mpg1$hwy## t = 49.585, df = 232, p-value &lt; 2.2e-16## alternative hypothesis: true correlation is not equal to 0## 95 percent confidence interval:## 0.9433129 0.9657663## sample estimates:## cor ## 0.9559159 p-value &lt; 2.2e-16로 0.05보다 작으므로 대립가설을 채택 회귀분석 한 변수가 다른 변수에 영향을 주는것 단순회귀분석 독립변수가 1개, 종속변수가 1개 변수는 독립변수와 종속변수가 모두 등간척도 또는 비율척도이어야합니다. 방법 1 : lm(dat= 데이터세트, 종속변수 ~ 독립변수) 방법 2 : lm(종속변수 ~ 독립변수, data = 데이터세트) 방법 3 : lm(데이터세트$종속변수~ 데이터세트$독립변수) 1lm(data= mtcars, mpg~disp) 1234567## ## Call:## lm(formula = mpg ~ disp, data = mtcars)## ## Coefficients:## (Intercept) disp ## 29.59985 -0.04122 -&gt; 29.59985 - 0.04122 * disp 라는 식이 도출됨. 123RA = lm(data= mtcars, mpg~disp)summary(RA) 123456789101112131415161718## ## Call:## lm(formula = mpg ~ disp, data = mtcars)## ## Residuals:## Min 1Q Median 3Q Max ## -4.8922 -2.2022 -0.9631 1.6272 7.2305 ## ## Coefficients:## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 29.599855 1.229720 24.070 &lt; 2e-16 ***## disp -0.041215 0.004712 -8.747 9.38e-10 ***## ---## Signif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1## ## Residual standard error: 3.251 on 30 degrees of freedom## Multiple R-squared: 0.7183, Adjusted R-squared: 0.709 ## F-statistic: 76.51 on 1 and 30 DF, p-value: 9.38e-10 -&gt; p-value: 9.38e-10로 0.05보다 작으므로 회귀모형이 적합-&gt; 회귀식으로 mpg= -0.04122 * disp + 29.59985 라는 식이 도출됨. 다중회귀분석 종속변수에 영향을 주는 독립변수가 복수일때 분석하는 방식 방법 1 : lm(data = 데이터세트, 종속변수~ 독립변수1 + 독립변수2 + …) 방법 2 : lm(종족변수~ 독립변수1+ 독립변수2+ … , data = 데이터세트) 방법 3 : lm(데이터세트$종속변수~ 데이터세트$독립변수1+ 데이터세트$독립변수2+ …) 1lm(data= mtcars, mpg~ disp+ hp+ wt) 1234567## ## Call:## lm(formula = mpg ~ disp + hp + wt, data = mtcars)## ## Coefficients:## (Intercept) disp hp wt ## 37.105505 -0.000937 -0.031157 -3.800891 12# == lm(mpg~ disp+ hp+ wt, data= mtcars)# ==lm(mtcars$mpg~ mtcars$disp+ mtcars$hp+ mtcars$wt) -&gt; mpg = 37.105505 - (0.000937 * disp) - (0.031157 * hp) - (3.800891 * wt) 라는 다중 회귀식이 도출됨.-&gt; 하지만, summary() 함수로 유의수준을 확인 할 필요가 있음 123RA = lm(data= mtcars, mpg~ disp+ hp+ wt)summary(RA) 1234567891011121314151617181920## ## Call:## lm(formula = mpg ~ disp + hp + wt, data = mtcars)## ## Residuals:## Min 1Q Median 3Q Max ## -3.891 -1.640 -0.172 1.061 5.861 ## ## Coefficients:## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 37.105505 2.110815 17.579 &lt; 2e-16 ***## disp -0.000937 0.010350 -0.091 0.92851 ## hp -0.031157 0.011436 -2.724 0.01097 * ## wt -3.800891 1.066191 -3.565 0.00133 ** ## ---## Signif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1## ## Residual standard error: 2.639 on 28 degrees of freedom## Multiple R-squared: 0.8268, Adjusted R-squared: 0.8083 ## F-statistic: 44.57 on 3 and 28 DF, p-value: 8.65e-11 -&gt; p-value: 8.65e-11로 0.001보다 작으므로 회귀모형이 적합-&gt; disp의 Pr(&gt;|t|)값이 0.92851로 0.05보다 높으므로 유의수준 부적합-&gt; mpg는 disp에 영향을 받지 않고 hp, wt의 영향을 받음.","link":"/2022/03/18/0315_statistics/"},{"title":"배포 - 깃허브 올리기","text":"깃헙 올리기1234$ git add README.md (README.md 파일만 올릴 때)$ git add . (모든 파일 올릴 때)$ git commit -m &quot;~~&quot; (브랜치에 기록)$ git push (깃허브에 보내기)","link":"/2022/03/18/0318_distribute_Github_Upload/"},{"title":"배포 - 깃허브 블로그(hexo)","text":"깃허브 블로그(hexo)ex) 는 형식에 맞춰서 재작성, 없으면 그대로 적으면 됨. 필수 파일 설치 nodejs.org 설치 (16.14.1 LTS 사용) 1$ node -v 로 버전 확인 가능 git-scm.com 다운로드 1$ git -version 으로 확인 가능 hexo 설치 (npm을 통해서 설치 가능) 1$ npm install -g hexo-cli 깃허브 설정 Repositories (이하 Repo)는 백업용 + 배포용 두가지를 권장 1234567배포용 ex)$ echo &quot;# &lt;폴더명&gt;&quot; &gt;&gt; README.md$ git init (git 초기화)$ git add README.md (모든 파일 올릴땐 git add .)$ git commit -m &quot;first commit&quot; (-m &quot;~~&quot;필수)$ git branch -M main (브랜치를 main으로 전환)$ git remote add origin https://github.com/WoobinHwang/&lt;폴더명&gt;.gitgit push -u origin main 백업용 Repo를 git clone을 통해 적당한 경로로 내려받는다. 1ex) $ git clone your_git_repo_address.git 블로그 만들기 폴더 만들기 12$ mkdir &lt;폴더명&gt; (mkdir == make directory)$ cd &lt;폴더명&gt; (cd == 해당 폴더로 접속) 폴더의 Hexo를 초기화 후 설치 12345ex) $ hexo init &lt;폴더명&gt;ex) $ cd &lt;폴더명&gt;$ npm install$ npm install hexo-server --save$ npm install hexo-deployer-git --save _config.yml 파일 설정 사이트 정보 수정 12345ex)title: 제목을 지어주세요subtitle: 부제목을 지어주세요description: description을 지어주세요author: YourName 블로그 url 설정 12345ex)url: https://유저네임.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults: 깃허브 연동 123456ex)# Deploymentdeploy: type: git repo: https://github.com/유저네임/유저네임.github.io.git branch: main 깃허브(hexo)에 배포하기- 1234$ hexo server (local에서 확인)$ hexo generate (수정 파일 확인 가능)$ hexo deploy (깃헙 , hexo에 업로드)# == hexo generate --deploy (두 작업 동시에 가능) 테마 적용하기 https://ppoffice.github.io/hexo-theme-icarus/uncategorized/getting-started-with-icarus/#install-npm 예시 - 이카루스 적용하기 123$ npm install -S hexo-theme-icarus$ hexo config theme icarus$ npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3","link":"/2022/03/18/0318_distribute_github_blog/"},{"title":"배포 - 파일 업로드(Markdown 형식)","text":"파일 업로드(markdown 형식)R - &gt; hexo R 상단 창 예시 12345678---title: &quot;title_name&quot;author: &quot;Woobin&quot;date: '2022-mm-dd'output: html_document: keep_md: true--- knit 실행시 &lt;파일명&gt;.md, &lt;파일명&gt;.html, &lt;파일명&gt;_files 가 생성됨. source / _posts 폴더로 &lt;파일명&gt;.md 파일 옮기기source / Images 폴더로 &lt;파일명&gt;_files 폴더 옮기기 이미지 파일이 있으면 md 파일에서 주소 설정 필요ex) /Images/ ~해당 이미지가 있는 주소명까지 hexo server로 확인해보기 Notion - &gt; hexo 노션의 상단 …에서 내보내기 (Markdown형식) 압축 해제 후source / _posts 폴더로 &lt;파일명&gt;.md 파일 옮기기source / Images 폴더로 &lt;파일명&gt;_files 폴더 옮기기 md 파일에서 이미지 파일의 경로가 이상하게 지정되어 있어 바꿔야함. Copy Path/Reference… 클릭 Path From Repository Root 선택기본적으로 source는 잡혀있으니까 제외하고 /Images/~파일명 으로 교체 hexo server 로 확인 JupyterLab - &gt; hexo anaconda를 관리자 권한으로 실행 JupyterLab 실행 Save and Export Notebook As… - &gt; Markdown으로 압축 후 바탕화면에서 압축해제 source / _posts 폴더로 &lt;파일명&gt;.md 파일 옮기기source / Images 폴더로 &lt;파일명&gt;_files 폴더 옮기기 이미지 파일이 있으면 md 파일에서 주소 설정 필요ex) /Images/ ~해당 이미지가 있는 주소명까지","link":"/2022/03/18/0318_File_Upload(Markdown)/"},{"title":"파이썬 기초문법 연습1","text":"논리형 연산자비교 연산자12var = input(&quot;입력해주세요.&quot;)print(type(var)) 입력해주세요.1 &lt;class 'str'&gt; 12var = int(&quot;1&quot;)print(type(var)) &lt;class 'int'&gt; 12var = int(input(&quot;숫자를 입력해주세요.&quot;))print(type(var)) 숫자를 입력해주세요.1 &lt;class 'int'&gt; 12345num1 = int(input(&quot;숫자를 입력하세요.&quot;))num2 = int(input(&quot;숫자를 입력하세요.&quot;))var = num1 &gt;= num2print(var) 숫자를 입력하세요.5 숫자를 입력하세요.3 True 12greeting = &quot;Hello kaggle!&quot;print(greeting[10]) l 슬라이싱- 범위를 지정하고 데이터를 가져온다.12345678greeting = &quot;Hello kaggle!&quot;print(greeting[:])print(greeting[6:])print(greeting[:5])print(greeting[3:9])print(greeting[0:9:2])print(greeting[13]) Hello kaggle! kaggle! Hello lo kag Hlokg 문자열 포매팅바로 대입12print(&quot;I eat %d apples.&quot; %3)'I eat %s apples.' %&quot;two&quot; I eat 3 apples. 'I eat two apples.' 변수 대입12345num1 = 4print(&quot;I have %d apples.&quot; %num1)num2 = &quot;three&quot;print(&quot;I have %s balls&quot; %num2) I have 4 apples. I have three balls 두개의 변수 대입12num1 = 3; num2 = &quot;four&quot;print(&quot;i love %d, and hate %s&quot; %(num1, num2)) i love 3, and hate four 종류코드 설명%s 문자열(String)%c 문자 1개(character)%d 정수(Integer)%f 부동소수(floating-point)%o 8진수%x 16진수%% Literal % (문자 % 자체) f 문자열 포매팅123name = &quot;홍길동&quot;; age = 27 print(f&quot;제 이름은 {name}, 나이는 {age}세 입니다.&quot;)f&quot;제 이름은 {name}, 내년엔 {age+1}세 입니다.&quot; 제 이름은 홍길동, 나이는 27세 입니다. '제 이름은 홍길동, 내년엔 28세 입니다.' 123456print(f'{&quot;hi&quot;:&lt;10}') # 왼쪽 정렬print(f'{&quot;hi&quot;:&gt;8}') # 오른쪽 정렬print(f'{&quot;hi&quot;:^10}') # 가운데 정렬print(f'{&quot;hi&quot;:=&lt;3}') # 왼쪽 정렬print(f'{&quot;hi&quot;:-&gt;10}') # 오른쪽 정렬print(f'{&quot;hi&quot;:!^6}') # 가운데 정렬 hi hi hi hi= --------hi !!hi!! 확인용 코드12print(f'{&quot;hi&quot;:!&lt;4}')print((&quot;hello&quot;[1])) hi!! e 소수점 나타내기123pi = 3.141592print(f'{pi:0.4f}') # pi의 소수점 4자리까지 표시print(f'{pi:7.3f}') # pi의 소수점 3자리까지, 총 7자리로 맞추기 3.1416 3.142 리스트 시퀀스 데이터 타입 데이터에 순서가 존재하냐! 슬라이싱이 가능해야함. 대괄호[‘값1’, ‘값2’, ‘값3’, …] 12345678910111213a = [] # 빈 리스트 생성a_func = list() # 빈 리스트 생성b = [1] # 숫자가 요소가 될 수 있다.c = ['apple'] # 문자열도 요소가 될 수 있다.d = [1, 2, ['apple']] # 리스트 안에 또 다른 리스트를 요소로 넣을 수 있다.print(a)print(a_func)print(b)print(c)print(d)print(type(d)) [] [] [1] ['apple'] [1, 2, ['apple']] &lt;class 'list'&gt; 리스트 슬라이싱1234567a = [1, 2, 3, 4, 5, 6, 7, 8]print(a[0])print(a[3:])print(a[:3])print(a[1:3])print(a[1:3])print(a[1:6:2]) 1 [4, 5, 6, 7, 8] [1, 2, 3] [2, 3] [2, 3] [2, 4, 6] 12345a = [[&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;], 1]print(a[0][1])print(a)print(a[0][1][-2])print(a[0][2][2]) banana [['apple', 'banana', 'cherry'], 1] n e 123a = [1, 2, 3, 4, 5, 6, 7, 8]print(a[::-1]) # 역순print(a[::2]) [8, 7, 6, 5, 4, 3, 2, 1] [1, 3, 5, 7] 리스트 연산자12345a = [&quot;john&quot;, &quot;evan&quot;]b = [&quot;alice&quot;, &quot;eva&quot;]c = a+ bprint(c) ['john', 'evan', 'alice', 'eva'] 12345c = a * 3d = b * 0print(&quot;a * 3 = &quot;, c)print(&quot;b * 0 = &quot;, d) a * 3 = ['john', 'evan', 'john', 'evan', 'john', 'evan'] b * 0 = [] 리스트 수정 및 삭제123a = [0, 1, 2]a[1] = &quot;b&quot;print(a) [0, 'b', 2] 리트스 값 추가하기123456789a = [100, 200, 300]a.append(400)print(a)# a.append([500, 600])# print(a)a.extend([500, 600])print(a) [100, 200, 300, 400] [100, 200, 300, 400, 500, 600] 1234a = [0, 1, 2]# a.insert(인덱스번호, 넣고자하는값)a.insert(1, 100)print(a) [0, 100, 1, 2] 리스트 값 삭제하기12345a = [4, 3, 2, 1, &quot;A&quot;]a.remove(1) # 리스트 안에 있는 값을 삭제print(a)a.remove(&quot;A&quot;)print(a) [4, 3, 2, 'A'] [4, 3, 2] 1234567a = [1, 2, 3, 4, 5, 6, 7, 8]del a[1] # 인덱스 번호print(a)del a[1:5]print(a) [1, 3, 4, 5, 6, 7, 8] [1, 7, 8] 1234b = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]x = b.pop()print(x)print(b) d ['a', 'b', 'c'] 그 외 메서드12345a = [0, 1, 2, 3]print(a)a.clear()print(a) [0, 1, 2, 3] [] 1234a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]print(a.index(&quot;a&quot;))print(a.index(&quot;b&quot;))print(a.index(&quot;c&quot;)) 0 1 2 123456789a = [1, 4, 5, 2, 3]b = [1, 4, 5, 2, 3]a.sort()print(a)# 내림차순, sortb.sort(reverse=True)print(&quot;sort(reverse=True): &quot;, b) [1, 2, 3, 4, 5] sort(reverse=True): [5, 4, 3, 2, 1] 12# c = [4, 3, 2, 1, &quot;a&quot;]# c.sort() # 문자형이 다르기떄문에 에러가 남. --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-177-4435d5800da3&gt; in &lt;module&gt;() 1 c = [4, 3, 2, 1, &quot;a&quot;] ----&gt; 2 c.sort() TypeError: '&lt;' not supported between instances of 'str' and 'int' 튜플 List와 비슷하다. 비슷한점 : 슬라이싱, 인덱싱 등등 (vs 리스트)다른점: 튜플은 수정 삭제가 안된다. 123456tuple1 = (0) # 끝에 콤마(,)를 붙이지 않을 때 =&gt; inttuple2 = (0,) # 끝에 콤마를 붙일 때 =&gt; tupletuple3 = 0, 1, 2print(type(tuple1))print(type(tuple2))print(type(tuple3)) &lt;class 'int'&gt; &lt;class 'tuple'&gt; &lt;class 'tuple'&gt; 1234567891011a = (0, 1, 2, 3, &quot;a&quot;)print(type(a))b = list(a)print(b)b[1] = &quot;b&quot;a= tuple(b)print(a)# a[4] = 41# del a[4] &lt;class 'tuple'&gt; [0, 1, 2, 3, 'a'] (0, 'b', 2, 3, 'a') 튜플 인덱싱 및 슬라이싱 하기1234a = (1, 2, 3, 4, &quot;a&quot;)print(a[1])print(a[3])print(a[4]) 2 4 a 더하기 곱셈 연산자 사용12345678a = (&quot;홍길동&quot;, &quot;임꺽정&quot;)b = (&quot;철수&quot;, &quot;영희&quot;)c = (1, 2)print(a+b)print(a*2)print(b*0)print(c*2) ('홍길동', '임꺽정', '철수', '영희') ('홍길동', '임꺽정', '홍길동', '임꺽정') () (1, 2, 1, 2) 딕셔너리 key - value 값으로 나뉨 1234567dict_01 = {&quot;teacher&quot; : &quot;evan&quot;, &quot;class&quot; : 604, &quot;students&quot; : 24, &quot;학생이름&quot; : [&quot;A&quot;, &quot;B&quot;],}print(dict_01)print(dict_01[&quot;teacher&quot;])print(dict_01[&quot;학생이름&quot;]) {'teacher': 'evan', 'class': 604, 'students': 24, '학생이름': ['A', 'B']} evan ['A', 'B'] 1234print(type(dict_01.keys()))print(type(dict_01.values()))print(list(dict_01.keys()))print(list(dict_01.values())) &lt;class 'dict_keys'&gt; &lt;class 'dict_values'&gt; ['teacher', 'class', 'students', '학생이름'] ['evan', 604, 24, ['A', 'B']] 1dict_01.items() # 개별 key,value는 튜플 상태로 저장되어있음. dict_items([('teacher', 'evan'), ('class', 604), ('students', 24), ('학생이름', ['A', 'B'])]) 123print(dict_01.get(&quot;teacher&quot;, &quot;값 없음&quot;))print(dict_01.get(&quot;선생님&quot;, &quot;값 없음&quot;))print(dict_01.get(&quot;class&quot;)) evan 값 없음 604 조건문 &amp; 반복문 일상에서의 조건문 조건문12345weather = &quot;맑음&quot;if weather == &quot;비&quot;: print(&quot;우산을 가져간다.&quot;)else : print(&quot;우산을 가져가지 않는다.&quot;) 우산을 가져가지 않는다. 등급표 만들기 60점 이상 합격/ 불합격 12345result = int(input())if result &gt;= 60: print(&quot;합격입니다.&quot;)else : print(&quot;불합격입니다.&quot;) 59 불합격입니다. 12345678910import randomscore = random.randrange(50,101)print(str(score) + &quot;점&quot;)if score &gt;= 90: print(&quot;A등급입니다&quot;)elif score &gt;= 80: print(&quot;B등급입니다&quot;)else : print(&quot;F등급입니다.&quot;) 90점 A등급입니다 반복문 안녕하세요 10번 반복하세요 12for i in range(10) : print(&quot;안녕하세요&quot;, i+1) 안녕하세요 1 안녕하세요 2 안녕하세요 3 안녕하세요 4 안녕하세요 5 안녕하세요 6 안녕하세요 7 안녕하세요 8 안녕하세요 9 안녕하세요 10 123456789count = range(50)print(count)for n in count: print(str(n + 1) + &quot;번째&quot;) if (n + 1 ) == 5: print(&quot;그만합시다!&quot;) break print(&quot;도전&quot;) range(0, 50) 1번째 도전 2번째 도전 3번째 도전 4번째 도전 5번째 그만합시다! 123456a = &quot;hello&quot;for x in a: print(x) if x == &quot;l&quot;: break h e l 12345alphabets = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]for index, value in enumerate(alphabets): print(index, value)# enumerate() 는 index 와 밸류값을 호출 0 a 1 b 2 c 종합문제 Q1 문자열 바꾸기 12345test = &quot;a:b:c:d&quot;test = test.split(&quot;:&quot;)print(test)test = &quot;#&quot;.join(test)print(test) ['a', 'b', 'c', 'd'] a#b#c#d 종합문제 Q2 딕셔너리값 추출하기 12a = {'A':90, 'B':80}print(a.get(&quot;C&quot;, &quot;70&quot;)) 70 종합문제 Q3 extend의 특징 1주소값이 변하지 않는것을 확인 할 수 있다.","link":"/2022/03/21/0321_basic_grammar_prac/"},{"title":"파이썬 기초문법 연습3","text":"클래스를 만드는 목적 코드의 간결화! 코드를 재사용! 여러 라이브러리를 사용 –&gt; 클래스로 구현이 됨 list 클래스, str 클래스 객체로 씀 변수명으로 정의! 여러 클래스들이 모여서 하나의 라이브러리가 됨. 장고 / 웹개발 / 머신러닝 / 시각화 / 데이터 전처리 1234567891011121314151617class Person: # class attribute country = &quot;korean&quot; #instance attribute def __init__(self, name, age): self.name = name self.age = ageif __name__ == &quot;__main__&quot;: kim = Person(&quot;Kim&quot;, 27) Lee = Person(&quot;Lee&quot;, 25) # access class attribute print(&quot;Kim은 {}&quot;.format(kim.__class__.country)) print(&quot;Lee는 {}&quot;.format(Lee.__class__.country)) Kim은 korean Lee는 korean instance 메서드 생성 list.append(), list.extend() 1234567891011121314151617181920212223242526class Person: # class attribute country = &quot;korean&quot; # instance attribute def __init__(self, name, age): self.name = name self.age = age # instance method 정의 def sining(self, songtitle, sales): return &quot;{} 판매량 {} 된 {}을 노래합니다.&quot;.format(self.name, sales, songtitle)if __name__ == &quot;__main__&quot;: Kim = Person(&quot;Kim&quot;, 27) Lee = Person(&quot;Lee&quot;, 25) # access class attribute print(&quot;Kim은 {}&quot;.format(kim.__class__.country)) print(&quot;Lee는 {}&quot;.format(Lee.__class__.country)) # call instance method print(Kim.sining(&quot;좋은 날&quot;, 10)) print(Lee.sining(&quot;나쁜 날&quot;, 99)) Kim은 korean Lee는 korean Kim 판매량 10 된 좋은 날을 노래합니다. Lee 판매량 99 된 나쁜 날을 노래합니다. 클래스 상속 ex) 부모님 유산… 부모님 집 (냉자고, 세탁기, TV, etc) # instance method, attribute 사용은 같이 함 돈을 모음 개인 노트북 구매(내 방에 구비) # 자식 클래스 instance method, attribute 추가 확장 노트북은 내 것이지만, 가전제품을 구매해서 확장시켰다! 12345678910111213141516171819202122232425262728293031323334353637class Parent: # instance attribute def __init__(self, name, age): self.name = name self.age = age # instance method 정의 def whoAmI(self): print(&quot;I am Parent!!&quot;) def singing(self, songtitle): return &quot;{} {}을 노래합니다.&quot;.format(self.name, songtitle) def dancing(self): return &quot;{} 현재 춤을 춥니다.&quot;.format(self.name)class Child(Parent): def __init__(self, name, age): # super() function super().__init__(name, age) print(&quot;Child Class is ON&quot;) def whoAmI(self): print(&quot;I am Child&quot;) def studying(self): print(&quot;I am Fast Runner&quot;)if __name__ == &quot;__main__&quot;: child_kim = Child(&quot;kim&quot;, 15) parent_kim = Parent(&quot;kim&quot;, 45) print(child_kim.dancing()) print(child_kim.singing(&quot;연애&quot;)) # print(parent_kim.studying()) child_kim.whoAmI() parent_kim.whoAmI() Child Class is ON kim 현재 춤을 춥니다. kim 연애을 노래합니다. I am Child I am Parent!! 12345678910111213141516171819202122232425class TV: # init constructor def __init__(self): self.__maxprice = 500 def sell(self): print(&quot;Selling Price: {}&quot;.format(self.__maxprice)) def setMaxPrice(self, price): self.__maxprice = priceif __name__ == &quot;__main__&quot;: tv = TV() tv.sell() # change price # 안바뀌는 코드의 예시 tv.__maxprice = 1000 tv.sell() # setMaxPrice # 값을 바꿀 수 있다?! 외부의 입력값을 업데이트 할 수 있다. tv.setMaxPrice(1000) tv.sell() Selling Price: 500 Selling Price: 500 Selling Price: 1000 클래스 내부에 조건문 init constructor 123456789101112131415161718192021222324252627282930class Employee: # init constructor def __init__(self, name, salary): self.name = name # 조건문 추가 if salary &gt;= 0 : self.salary = salary else: self.salary = 0 print(&quot;급여는 0원이 될 수 없다!. 다시 입력하십시요!&quot;) def update_salary(self, amount): # self.salary = self.salary+ amount self.salary += amount def weekly_salary(self): return self.salary / 7if __name__ == &quot;__main__&quot;: emp01 = Employee(&quot;Woobin&quot;, -50000) print(emp01.name) print(emp01.salary) emp01.salary = emp01.salary + 1500 print(emp01.salary) emp01.update_salary(3000) print(emp01.salary) week_salary = emp01.weekly_salary() print(week_salary) 급여는 0원이 될 수 없다!. 다시 입력하십시요! Woobin 0 클래스 Docstring12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Person: &quot;&quot;&quot; 사람을 표현하는 클래스 ... Attributes ----------- name : str name of the person age : int age if the person Methods -------- info(additional=&quot;&quot;): prints the person's name and age &quot;&quot;&quot; def __init__(self, name, age): &quot;&quot;&quot; Constructs all the neccessary attributes for the person object Parameters ---------- name : str name of the person age : int age if the person &quot;&quot;&quot; self.name = name self.age = age def info(self, additional=None): &quot;&quot;&quot; ~~~ Parameters --------- additional = str, optional more info to be displayed (Default is None) / A, B, C Returns ------- None &quot;&quot;&quot; print(f'My name is {self.name}. I am {self.age} years old.'+ additional)if __name__ == &quot;__main__&quot;: Person = Person(&quot;Woobin&quot;, age = 27) Person.info(&quot;직장은 없음&quot;) help(Person) My name is Woobin. I am 27 years old.직장은 없음 Help on Person in module __main__ object: class Person(builtins.object) | Person(name, age) | | 사람을 표현하는 클래스 | | ... | | Attributes | ----------- | name : str | name of the person | | age : int | age if the person | | Methods | -------- | | info(additional=&quot;&quot;): | prints the person's name and age | | Methods defined here: | | __init__(self, name, age) | Constructs all the neccessary attributes for the person object | | Parameters | ---------- | name : str | name of the person | | age : int | age if the person | | info(self, additional=None) | ~~~ | | Parameters | --------- | additional = str, optional | more info to be displayed (Default is None) / A, B, C | | | Returns | ------- | None | | ---------------------------------------------------------------------- | Data descriptors defined here: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) 클래스 객체를 만들어내기 위한 설계도 혹은 틀 연관되어 있는 변수와 메서드의 집합 객체 소프트웨어 세계에 구현할 대상 클래스에 선언된 모양 그대로 생성된 실체 ‘클래스의 인스턴스’라고도 부른다 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다. 인스턴스 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체 즉, 객체를 소프트웨어에 실체화 하면 그것을 ‘인스턴스’라고 부른다. 실체화된 인스턴스는 메모리에 할당된다. 인스턴스는 객체에 포함된다고 볼 수 있다. 객체는 클래스의 인스턴스이다. 객체와 인스턴스의 차이클래스로 만든 객체를 인스턴스라고도 한다. 그렇다면 객체와 인스턴스의 차이는 무엇일까? 이렇게 생각해 보자. a = Cookie() 이렇게 만든 a는 객체이다. 그리고 a 객체는 Cookie의 인스턴스이다. 즉 인스턴스라는 말은 특정 객체(a)가 어떤 클래스(Cookie)의 객체인지를 관계 위주로 설명할 때 사용한다. “a는 인스턴스”보다는 “a는 객체”라는 표현이 어울리며 “a는 Cookie의 객체”보다는 “a는 Cookie의 인스턴스”라는 표현이 훨씬 잘 어울린다.","link":"/2022/03/22/0322_basic_grammar_prac_3/"},{"title":"파이썬 기초문법 연습2","text":"기초 문법 리뷰1234567891011# 리스트book_list = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]# append, extend, insert, remove, pop, etc# 튜플book_tuple = (&quot;A&quot;, &quot;B&quot;,, &quot;C&quot;)# 수정 삭제가 불가능# 딕셔너리book_dictionary = {&quot;책 제목&quot; : [&quot;A&quot;, &quot;B&quot;], &quot;출판년도&quot; : [2011, 2002]}#keys(), values(), items(), get() 조건문 &amp; 반복문1234567# 조건문if True : print(&quot;코드 실행&quot;)elif True : pirnt(&quot;코드 실행&quot;)else : pirnt(&quot;코드 실행&quot;) 코드 실행 123# 반복문for i in range (3): print(i+1, &quot;안녕하세요&quot;) 1 안녕하세요 2 안녕하세요 3 안녕하세요 123book_list = [&quot;프로그래밍 R&quot;, &quot;혼자 공부하는 머신러닝&quot;]for book in book_list: print(book) 프로그래밍 R 혼자 공부하는 머신러닝 123strings01 = &quot;Hello world&quot;for char in strings01: print(char) H e l l o w o r l d 123num_tuple = (1, 2, 3, 4)for num in num_tuple: print(num) 1 2 3 4 1234num_dict = {&quot;A&quot;: 1, &quot;B&quot;: 2}for num in num_dict: # print(num) print(num, num_dict[num]) A 1 B 2 반복문의 필요성1234567891011product = [&quot;요구르트&quot;, &quot;우유&quot;]price = [1000, 1500]quantities = [5, 3]name = product[0]sales = price[0] * quantities[0]print(name + &quot;의 매출액은 &quot; + str(sales) + &quot;원 입니다.&quot;)name = product[1]sales = price[1] * quantities[1]print(name + &quot;의 매출액은 &quot; + str(sales) + &quot;원 입니다.&quot;) 요구르트의 매출액은 5000원 입니다. 우유의 매출액은 4500원 입니다. 12345678910111213product = [&quot;요구르트&quot;, &quot;우유&quot;]price = [1000, 1500]quantities = [5, 3]for i in range(2) : name = product[i] sales = price[i] * quantities[i] print(name + &quot;의 매출액은 &quot;+ str(sales) + &quot;원 입니다.&quot;)for i in range(len(product)) : name = product[i] sales = price[i] * quantities[i] print(name + &quot;의 매출액은 &quot;+ str(sales) + &quot;원 입니다.&quot;) 요구르트의 매출액은 5000원 입니다. 우유의 매출액은 4500원 입니다. 요구르트의 매출액은 5000원 입니다. 우유의 매출액은 4500원 입니다. while 조건식이 들어간 반복문 if) for-loop: 정해진 범위 내에서 작동 1234567# 증가하는 식count = 1while count &lt;= 5: print(count) count = count + 1print(&quot;5를 초과했군요...&quot;) 1 2 3 4 5 5를 초과했군요... 1234567# 감소하는 식count = 3while count &gt; 0: print(count) count = count - 1print(&quot;0 미만이군요...&quot;) 3 2 1 0 미만이군요... 사용자 정의 함수 (user-Defined Function) why? 클래스(class)를 왜 쓸까 코드의 반복성을 줄이기 위해서 사용! if) len() –&gt; 누군가가 만들었고, 우리는 그걸 쓰는거임. 리스트의 길이 구할 때 씀. 리스트의 전체 길이를 구하겠다. –&gt; 1회성? 범용성? 123456# 형식def 함수명(): # 코드 실행 return 값함수명() 1234567891011121314151617181920def add(a, b): c = a + b return cadd(1,2)def abs(a): if a &lt; 0: a = -a return a else: return aabs(-5)def squared(): a = int(input()) a = a * a return aprint(add(1,2))print(abs(-5))print(squared()) 3 5 3 9 basic.py로 저장할때 예시 1234567891011121314151617181920212223# /user/local/bin/python# -*- coding : utf-8 -*-def temp(content, letter): &quot;&quot;&quot;content안에 있는 문자를 세는 함수 Args: content(str): 탐색 문자열 letter(str) : 찾을 문자열 Return: int &quot;&quot;&quot; print(&quot;함수 테스트&quot;) cnt = len([char for char in content if char == letter]) return cntif __name__ == &quot;__main__&quot;: # help(temp) docstring = temp.__doc__ print(docstring) content안에 있는 문자를 세는 함수 Args: content(str): 탐색 문자열 letter(str) : 찾을 문자열 Return: int 리스트 컴프리헨션 for-loop 반복문을 한줄로 처리 123456789# 풀어서 쓴 것my_list = [[10], [20, 30]]# 목표 : [10, 20, 30]flattened_list = []for value_list in my_list: for value in value_list: flattened_list.append(value)print(flattened_list) [10, 20, 30] 1234# 한줄로 줄이기my_list = [[10], [20, 30]]flattened_list = [value for value_list in my_list for value in value_list]print(flattened_list) [10, 20, 30] 예시1234letters = []for char in &quot;hello world&quot;: letters.append(char)print(letters) ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'] 12letters2 = [char for char in &quot;hello world&quot;]print(letters2) ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'] 12345678value_list = [1, 2, 3, 4, 5, 6]print(&quot;평균: &quot;+ str(sum(value_list) / len(value_list)))midpoint = int(len(value_list) / 2)# len(value_list) / 2 == 0 :print((value_list[midpoint - 1] + value_list[midpoint]))print((value_list[midpoint - 1] + value_list[midpoint]) / 2)print(midpoint) 평균: 3.5 7 3.5 3 1234567891011121314151617181920212223242526def mean_and_midian(value_list): &quot;&quot;&quot;숫자 리스트의 요소들의 평균과 중간값을 구하는 코드를 작성해라 Args: value_list (iterable of int / float) : A list of int numbers Returns: tuple(float, float) &quot;&quot;&quot; # 평균 mean = sum(value_list) / len(value_list) # 중간값 midpoint = int(len(value_list) / 2) if len(value_list) / 2 == 0: median = (value_list[midpoint - 1] + value_list[midpoint]) / 2 else: median = value_list[midpoint] return mean, medianif __name__ == &quot;__main__&quot;: value_list = [1, 1, 2, 2, 3, 4, 5] avg, median = mean_and_midian(value_list) print(&quot;avg:&quot;, avg) print(&quot;median&quot;, median) avg: 2.5714285714285716 median 2 그 외 데코레이터, 변수명 immutable, mutable, contex manager 개별 연습팩토리얼 구현하기1234567891011def factorial(): print(&quot;a를 입력하세요&quot;) a = int(input()) print(type(a)) result = 1 for num in range(a): num = num + 1 result = result * num return resultfactorial() a를 입력하세요 3 &lt;class 'int'&gt; 6","link":"/2022/03/22/0322_basic_grammar_prac_2/"},{"title":"Numpy 연습","text":"오늘의 오프닝.txt 머신러닝 / 딥러닝 –&gt; 수학을 잘하는 사람 vs 수학을 처음 하는 사람–&gt; 머신러닝 / 딥러닝 (인간이 만든 수식)–&gt; 개념을 이해하고, 수식을 히해하고, 코드로 그 수식을 구현–&gt; 머신러닝과 딥러닝을 쓰기 위해서는 수학자만 하는가?!—&gt; NO!–&gt; 머신러닝 / 딥러닝의 주 목적이 인간 생활의 보편적인 문제 해결을 위해서 나온것–&gt; 프레임워크 형태로 내놨음(개념은 이해함.) 개념만 문자열 타입으로 매개변수를 잘 조정하면 모델 만들어짐 –&gt; 성과를 내야함(개발자: 배포를 잘해야함.) 이미지 인식 모델을 만들었지만 배포를안하면 쓸대없음.. 안드로이드 앱/ 웹앱에 탑재할줄만 알아도… 기획(어떤 문제를 풀까?) –&gt; AutoML 코드 4~5줄 치면 머신러닝 모델이 만들어짐. 파이썬 라이브러리 설치 방법 (vsR) 123456789101112# install.pakages(&quot;패키지명&quot;)# 파이썬 라이브러리 설치 코드에서 실행 안함. # 터미널에서 설치.. # 방법 1. conda 설치 # 아나콘다 설치 후, conda 설치(주 사용목적: 데이터 과학) # conda 라이브러리 관리 ( 약간 버전 업데이트가 느림) # 방법 2. pip설치 (개발 + 데인터과학 + 그 외) # 아나콘다 설치 안함 / 파이썬만 설치# git bash - pip install numpy# pip install numpy NumPy 라이브러리 불러오기 NumPy: 배열간 계산이 필요할 때 12import numpy as npprint(np.__version__) 1.21.5 배열로 변환 1부터 10까지의 리스트를 만든다. NumPy 배열로 변환해서 저장한다. 123456temp = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]arr = np.array(temp)print(arr)print(temp)print(type(arr))print(type(temp)) [ 1 2 3 4 5 6 7 8 9 10] [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] &lt;class 'numpy.ndarray'&gt; &lt;class 'list'&gt; arr배열 숫자 5 출력 12print(arr[4])print(arr[4:8]) 5 [5 6 7 8] NumPy를 사용하여 기초 통계 함수를 사용한다. 1234print(np.mean(arr))print(np.sum(arr))print(np.median(arr))print(np.std(arr)) # 표준편차 5.5 55 5.5 2.8722813232690143 사칙연산12345math_scores = [90, 80, 88]english_scores = [80, 70, 90]total_scores = math_scores + english_scoresprint(total_scores) [90, 80, 88, 80, 70, 90] 1234567891011121314math_scores = [90, 80, 88]english_scores = [80, 70, 90]math_arr = np.array(math_scores)english_arr = np.array(english_scores)total_scores = math_arr + english_arrprint(total_scores)min = np.min(total_scores)print(min)max = np.max(total_scores)print(max) [170 150 178] 150 178 1234567891011math_scores = [2, 3, 4]english_scores = [1, 2, 3]math_arr = np.array(math_scores)english_arr = np.array(english_scores)print(&quot;덧셈: &quot;, np.add(math_arr, english_arr))print(&quot;뺄셈: &quot;, np.subtract(math_arr, english_arr))print(&quot;곱셈: &quot;, np.multiply(math_arr, english_arr))print(&quot;나눗셈: &quot;, np.divide(math_arr, english_arr))print(&quot;거듭제곱: &quot;, np.power(math_arr, english_arr)) 덧셈: [3 5 7] 뺄셈: [1 1 1] 곱셈: [ 2 6 12] 나눗셈: [2. 1.5 1.33333333] 거듭제곱: [ 2 9 64] 배열의 생성 0차원부터 3차원까지 생성하는 방법 12345temp_arr = np.array(20)print(temp_arr)print(type(temp_arr))print(temp_arr.shape)print(temp_arr.ndim) # 차원 확인 20 &lt;class 'numpy.ndarray'&gt; () 0 123456# 1차원 배열temp_arr = np.array([1, 2, 3])print(temp_arr)print(type(temp_arr))print(temp_arr.shape)print(temp_arr.ndim) # 차원 확인 [1 2 3] &lt;class 'numpy.ndarray'&gt; (3,) 1 1234567# 2차원 배열temp_arr = np.array([[1, 2, 3], [4, 5, 6]])#temp_arr = np.array([[1], [4]])print(temp_arr)print(type(temp_arr))print(temp_arr.shape)print(temp_arr.ndim) [[1 2 3] [4 5 6]] &lt;class 'numpy.ndarray'&gt; (2, 3) 2 123456# 3차원 배열temp_arr = np.array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]])print(temp_arr)print(type(temp_arr))print(temp_arr.shape)print(temp_arr.ndim) [[[1 2 3] [4 5 6]] [[1 2 3] [4 5 6]]] &lt;class 'numpy.ndarray'&gt; (2, 2, 3) 3 12345temp_arr = np.array([1, 2, 3, 4], ndmin= 2)print(temp_arr)print(type(temp_arr))print(temp_arr.shape)print(temp_arr.ndim) [[1 2 3 4]] &lt;class 'numpy.ndarray'&gt; (1, 4) 2 소수점 정렬12temp_arr = np.trunc([-1.23, 1.23])temp_arr array([-1., 1.]) 12temp_arr = np.fix([-1.5, 1.5])temp_arr array([-1., 1.]) 12temp_arr = np.around([-1.23456, 1.54321], 4)temp_arr array([-1.2346, 1.5432]) 12temp_arr = np.round([-1.23456, 1.54321], 4)temp_arr array([-1.2346, 1.5432]) 12temp_arr = np.floor([-1.23456, 1.54321])temp_arr array([-2., 1.]) 12temp_arr = np.ceil([-1.23456, 1.54321])temp_arr array([-1., 2.]) 배열을 생성하는 다양한 방법들12temp_arr = np.arange(2,12,3)print(temp_arr) [ 2 5 8 11] 123456zero_arr = np.zeros((2,3))print(zero_arr)print(type(zero_arr))print(zero_arr.shape)print(zero_arr.ndim)print(zero_arr.dtype) [[0. 0. 0.] [0. 0. 0.]] &lt;class 'numpy.ndarray'&gt; (2, 3) 2 float64 123456temp_arr = np.ones((4, 5), dtype=&quot;int32&quot;)print(temp_arr)print(type(temp_arr))print(temp_arr.shape)print(temp_arr.ndim)print(temp_arr.dtype) [[1 1 1 1 1] [1 1 1 1 1] [1 1 1 1 1] [1 1 1 1 1]] &lt;class 'numpy.ndarray'&gt; (4, 5) 2 int32 1234567temp_arr = np.ones((12, 12), dtype=&quot;int32&quot;)temp_res_arr = temp_arr.reshape(8, -1) # 재 배열print(temp_res_arr)print(type(temp_res_arr))print(temp_res_arr.shape)print(temp_res_arr.ndim)print(temp_res_arr.dtype) [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1] [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1] [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1] [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1] [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1] [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1] [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1] [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]] &lt;class 'numpy.ndarray'&gt; (8, 18) 2 int32 NumPy 조건식12temp_arr = np.arange(10)temp_arr array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 123# 5보다 작은 값은 원래 값으로 반환# 5보다 큰 값은 +10으로 반환np.where(temp_arr &lt; 5, temp_arr, temp_arr + 10) array([ 0, 1, 2, 3, 4, 15, 16, 17, 18, 19]) 1234# 0~100까지의 배열을 만들고, 50보다 작은 값은 곱하기 10, 나머지는 원래 값으로 반환# 조건식이 하나만 필요할 때 사용temp_arr = np.arange(1, 101)np.where(temp_arr &gt;= 50, temp_arr, temp_arr * 10) array([ 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290, 300, 310, 320, 330, 340, 350, 360, 370, 380, 390, 400, 410, 420, 430, 440, 450, 460, 470, 480, 490, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) np.select 다중 조건식 1234temp_arr = np.arange(10)temp_arr# 5보다 크면 곱하기 2, 2보다 작으면 더하기 100 array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 123condist = [temp_arr &gt; 5, temp_arr &lt; 2, temp_arr &lt; 4]condlist = [temp_arr * 2, temp_arr + 100, temp_arr * 10]np.select(condist, condlist, default = temp_arr) array([100, 101, 20, 30, 4, 5, 12, 14, 16, 18]) 개인 연습123456prac = np.arange(24)sec = prac[0:24:2]sec = sec.reshape(3, -1)condist = [sec &gt; 19, 13 &lt; sec, sec &lt;= 2]condlist = [sec, sec * 2, sec + 10]np.select(condist, condlist, default = sec) array([[10, 12, 4, 6], [ 8, 10, 12, 28], [32, 36, 20, 22]])","link":"/2022/03/23/0323_NumPy_01/"},{"title":"Pandas 연습1","text":"Pandas 라이브러리 불러오기 데이터 전처리에 이용 12import pandas as pdprint(pd.__version__) 1.3.5 테스트123456temp_dict = {&quot;col1&quot;: [1, 2, 3], &quot;col2&quot;: [3, 4, 5]}df = pd.DataFrame(temp_dict)print(df)print(type(df)) col1 col2 0 1 3 1 2 4 2 3 5 &lt;class 'pandas.core.frame.DataFrame'&gt; 1234temp_dic = {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}ser = pd.Series(temp_dic)print(ser)print(type(ser)) a 1 b 2 c 3 dtype: int64 &lt;class 'pandas.core.series.Series'&gt; 구글 드라이브 연동12from google.colab import drivedrive.mount('/content/drive') Mounted at /content/drive 123DATA_PATH = '/content/drive/MyDrive/Colab Notebooks/data/Lemonade2016.csv'juice = pd.read_csv(DATA_PATH)juice .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price 0 7/1/2016 Park 97 67 70 90.0 0.25 1 7/2/2016 Park 98 67 72 90.0 0.25 2 7/3/2016 Park 110 77 71 104.0 0.25 3 7/4/2016 Beach 134 99 76 98.0 0.25 4 7/5/2016 Beach 159 118 78 135.0 0.25 5 7/6/2016 Beach 103 69 82 90.0 0.25 6 7/6/2016 Beach 103 69 82 90.0 0.25 7 7/7/2016 Beach 143 101 81 135.0 0.25 8 NaN Beach 123 86 82 113.0 0.25 9 7/9/2016 Beach 134 95 80 126.0 0.25 10 7/10/2016 Beach 140 98 82 131.0 0.25 11 7/11/2016 Beach 162 120 83 135.0 0.25 12 7/12/2016 Beach 130 95 84 99.0 0.25 13 7/13/2016 Beach 109 75 77 99.0 0.25 14 7/14/2016 Beach 122 85 78 113.0 0.25 15 7/15/2016 Beach 98 62 75 108.0 0.50 16 7/16/2016 Beach 81 50 74 90.0 0.50 17 7/17/2016 Beach 115 76 77 126.0 0.50 18 7/18/2016 Park 131 92 81 122.0 0.50 19 7/19/2016 Park 122 85 78 113.0 0.50 20 7/20/2016 Park 71 42 70 NaN 0.50 21 7/21/2016 Park 83 50 77 90.0 0.50 22 7/22/2016 Park 112 75 80 108.0 0.50 23 7/23/2016 Park 120 82 81 117.0 0.50 24 7/24/2016 Park 121 82 82 117.0 0.50 25 7/25/2016 Park 156 113 84 135.0 0.50 26 7/26/2016 Park 176 129 83 158.0 0.35 27 7/27/2016 Park 104 68 80 99.0 0.35 28 7/28/2016 Park 96 63 82 90.0 0.35 29 7/29/2016 Park 100 66 81 95.0 0.35 30 7/30/2016 Beach 88 57 82 81.0 0.35 31 7/31/2016 Beach 76 47 82 68.0 0.35 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-288b57ac-64cf-4074-bdbe-540411381788 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-288b57ac-64cf-4074-bdbe-540411381788'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 데이터를 불러왔다. 첫번째 파악해야 하는것 : 데이터 구조 1juice.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 32 entries, 0 to 31 Data columns (total 7 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Date 31 non-null object 1 Location 32 non-null object 2 Lemon 32 non-null int64 3 Orange 32 non-null int64 4 Temperature 32 non-null int64 5 Leaflets 31 non-null float64 6 Price 32 non-null float64 dtypes: float64(2), int64(3), object(2) memory usage: 1.9+ KB 12juice.head()juice.tail() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price 27 7/27/2016 Park 104 68 80 99.0 0.35 28 7/28/2016 Park 96 63 82 90.0 0.35 29 7/29/2016 Park 100 66 81 95.0 0.35 30 7/30/2016 Beach 88 57 82 81.0 0.35 31 7/31/2016 Beach 76 47 82 68.0 0.35 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-fecc57cf-8b22-4d92-a620-cf238bc3af05 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-fecc57cf-8b22-4d92-a620-cf238bc3af05'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Describe() 함수 기술통계량 확인 해주는 함수 12juice.describe()# type(juice.describe()) # DataFrame .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Lemon Orange Temperature Leaflets Price count 32.000000 32.000000 32.000000 31.000000 32.000000 mean 116.156250 80.000000 78.968750 108.548387 0.354687 std 25.823357 21.863211 4.067847 20.117718 0.113137 min 71.000000 42.000000 70.000000 68.000000 0.250000 25% 98.000000 66.750000 77.000000 90.000000 0.250000 50% 113.500000 76.500000 80.500000 108.000000 0.350000 75% 131.750000 95.000000 82.000000 124.000000 0.500000 max 176.000000 129.000000 84.000000 158.000000 0.500000 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-01f6bcd9-5587-4428-8810-41e9e206384f button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-01f6bcd9-5587-4428-8810-41e9e206384f'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Value_counts() 12juice['Location'].value_counts()# type(juice['Location'].value_counts()) # Series Beach 17 Park 15 Name: Location, dtype: int64 데이터 다뤄보기 행과 열을 핸들링 해보기. 12juice['Sold'] = 0print(juice.head(3)) Date Location Lemon Orange Temperature Leaflets Price Sold 0 7/1/2016 Park 97 67 70 90.0 0.25 0 1 7/2/2016 Park 98 67 72 90.0 0.25 0 2 7/3/2016 Park 110 77 71 104.0 0.25 0 12juice['Sold'] = juice['Lemon'] + juice['Orange']print(juice.head(3)) Date Location Lemon Orange Temperature Leaflets Price Sold 0 7/1/2016 Park 97 67 70 90.0 0.25 164 1 7/2/2016 Park 98 67 72 90.0 0.25 165 2 7/3/2016 Park 110 77 71 104.0 0.25 187 Revenue 매출액 구하기 매출액 = 가격 * 판매량 12juice['Revenue'] = juice['Sold'] * juice['Price']print(juice.head(3)) Date Location Lemon Orange Temperature Leaflets Price Sold \\ 0 7/1/2016 Park 97 67 70 90.0 0.25 164 1 7/2/2016 Park 98 67 72 90.0 0.25 165 2 7/3/2016 Park 110 77 71 104.0 0.25 187 Revenue 0 41.00 1 41.25 2 46.75 drop(axis=0 or 1) axis를 0으로 설정시, 행(=index) 방향으로 drop() 실행 axis를 1로 설정시, 열방향으로 drop() 수행함 12juice_column_drop = juice.drop(&quot;Sold&quot;, axis = 1)print(juice_column_drop.head(3)) Date Location Lemon Orange Temperature Leaflets Price Revenue 0 7/1/2016 Park 97 67 70 90.0 0.25 41.00 1 7/2/2016 Park 98 67 72 90.0 0.25 41.25 2 7/3/2016 Park 110 77 71 104.0 0.25 46.75 12juice_row_drop = juice.drop(0, axis = 0)print(juice_row_drop.head(3)) Date Location Lemon Orange Temperature Leaflets Price Sold \\ 1 7/2/2016 Park 98 67 72 90.0 0.25 165 2 7/3/2016 Park 110 77 71 104.0 0.25 187 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 Revenue 1 41.25 2 46.75 3 58.25 데이터 인덱싱1juice[0:5] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price Sold Revenue 0 7/1/2016 Park 97 67 70 90.0 0.25 164 41.00 1 7/2/2016 Park 98 67 72 90.0 0.25 165 41.25 2 7/3/2016 Park 110 77 71 104.0 0.25 187 46.75 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 58.25 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 69.25 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-f61445f4-81f7-4360-b1d8-647a7b12a87f button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-f61445f4-81f7-4360-b1d8-647a7b12a87f'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; boolean 값을 활용한 데이터 추출1234# Location이 Beach인 경우# juice[juice['Location'] == &quot;Beach&quot;]# juice['Location'] == &quot;Beach&quot;juice[juice['Leaflets'] &gt;= 100] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price Sold Revenue 2 7/3/2016 Park 110 77 71 104.0 0.25 187 46.75 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 69.25 7 7/7/2016 Beach 143 101 81 135.0 0.25 244 61.00 8 NaN Beach 123 86 82 113.0 0.25 209 52.25 9 7/9/2016 Beach 134 95 80 126.0 0.25 229 57.25 10 7/10/2016 Beach 140 98 82 131.0 0.25 238 59.50 11 7/11/2016 Beach 162 120 83 135.0 0.25 282 70.50 14 7/14/2016 Beach 122 85 78 113.0 0.25 207 51.75 15 7/15/2016 Beach 98 62 75 108.0 0.50 160 80.00 17 7/17/2016 Beach 115 76 77 126.0 0.50 191 95.50 18 7/18/2016 Park 131 92 81 122.0 0.50 223 111.50 19 7/19/2016 Park 122 85 78 113.0 0.50 207 103.50 22 7/22/2016 Park 112 75 80 108.0 0.50 187 93.50 23 7/23/2016 Park 120 82 81 117.0 0.50 202 101.00 24 7/24/2016 Park 121 82 82 117.0 0.50 203 101.50 25 7/25/2016 Park 156 113 84 135.0 0.50 269 134.50 26 7/26/2016 Park 176 129 83 158.0 0.35 305 106.75 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-3fbca3f1-39da-418e-b5a2-2fde08a03d57 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-3fbca3f1-39da-418e-b5a2-2fde08a03d57'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; iloc 와 loc 차이를 확인한다. iloc : 인덱스 기준 처리속도가 빠름 가독성이 떨어짐 loc : 라벨 기준 처리속도가 느림 가독성이 좋음 1juice.head(3) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price Sold Revenue 0 7/1/2016 Park 97 67 70 90.0 0.25 164 41.00 1 7/2/2016 Park 98 67 72 90.0 0.25 165 41.25 2 7/3/2016 Park 110 77 71 104.0 0.25 187 46.75 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-bc495528-996d-4cc1-9d9d-b4a53e9be78f button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-bc495528-996d-4cc1-9d9d-b4a53e9be78f'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; iloc는 인덱스 기반 123%%timejuice.iloc[0:3, 0:2] CPU times: user 888 µs, sys: 0 ns, total: 888 µs Wall time: 986 µs .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location 0 7/1/2016 Park 1 7/2/2016 Park 2 7/3/2016 Park &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-636022bd-7583-4130-bcb4-a888bfd04161 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-636022bd-7583-4130-bcb4-a888bfd04161'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; loc—&gt; 라벨 기반 123%%timejuice.loc[0:2, [&quot;Date&quot;, &quot;Location&quot;]] CPU times: user 2.77 ms, sys: 0 ns, total: 2.77 ms Wall time: 3 ms .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location 0 7/1/2016 Park 1 7/2/2016 Park 2 7/3/2016 Park &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-8cf31adb-ef4c-4eae-8626-cba8eebe4d6c button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-8cf31adb-ef4c-4eae-8626-cba8eebe4d6c'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1juice.loc[juice['Leaflets'] &gt;= 100, [&quot;Date&quot;, &quot;Location&quot;]] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location 2 7/3/2016 Park 4 7/5/2016 Beach 7 7/7/2016 Beach 8 NaN Beach 9 7/9/2016 Beach 10 7/10/2016 Beach 11 7/11/2016 Beach 14 7/14/2016 Beach 15 7/15/2016 Beach 17 7/17/2016 Beach 18 7/18/2016 Park 19 7/19/2016 Park 22 7/22/2016 Park 23 7/23/2016 Park 24 7/24/2016 Park 25 7/25/2016 Park 26 7/26/2016 Park &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-f933b0b7-c6cc-4d5b-9cd8-2e0e784d02c1 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-f933b0b7-c6cc-4d5b-9cd8-2e0e784d02c1'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 정렬 sort_values() 1juice.sort_values(by=['Revenue'], ascending=False).head(3) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price Sold Revenue 25 7/25/2016 Park 156 113 84 135.0 0.50 269 134.50 18 7/18/2016 Park 131 92 81 122.0 0.50 223 111.50 26 7/26/2016 Park 176 129 83 158.0 0.35 305 106.75 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-b048eb90-dd56-4600-834d-a15994f8f9cf button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-b048eb90-dd56-4600-834d-a15994f8f9cf'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 123juice2 = juice.sort_values(by=['Price', 'Temperature'], ascending=[False, True]).reset_index(drop=True)# reset_index(drop=True) ==&gt; index 재부여juice2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price Sold Revenue 0 7/20/2016 Park 71 42 70 NaN 0.50 113 56.50 1 7/16/2016 Beach 81 50 74 90.0 0.50 131 65.50 2 7/15/2016 Beach 98 62 75 108.0 0.50 160 80.00 3 7/17/2016 Beach 115 76 77 126.0 0.50 191 95.50 4 7/21/2016 Park 83 50 77 90.0 0.50 133 66.50 5 7/19/2016 Park 122 85 78 113.0 0.50 207 103.50 6 7/22/2016 Park 112 75 80 108.0 0.50 187 93.50 7 7/18/2016 Park 131 92 81 122.0 0.50 223 111.50 8 7/23/2016 Park 120 82 81 117.0 0.50 202 101.00 9 7/24/2016 Park 121 82 82 117.0 0.50 203 101.50 10 7/25/2016 Park 156 113 84 135.0 0.50 269 134.50 11 7/27/2016 Park 104 68 80 99.0 0.35 172 60.20 12 7/29/2016 Park 100 66 81 95.0 0.35 166 58.10 13 7/28/2016 Park 96 63 82 90.0 0.35 159 55.65 14 7/30/2016 Beach 88 57 82 81.0 0.35 145 50.75 15 7/31/2016 Beach 76 47 82 68.0 0.35 123 43.05 16 7/26/2016 Park 176 129 83 158.0 0.35 305 106.75 17 7/1/2016 Park 97 67 70 90.0 0.25 164 41.00 18 7/3/2016 Park 110 77 71 104.0 0.25 187 46.75 19 7/2/2016 Park 98 67 72 90.0 0.25 165 41.25 20 7/4/2016 Beach 134 99 76 98.0 0.25 233 58.25 21 7/13/2016 Beach 109 75 77 99.0 0.25 184 46.00 22 7/5/2016 Beach 159 118 78 135.0 0.25 277 69.25 23 7/14/2016 Beach 122 85 78 113.0 0.25 207 51.75 24 7/9/2016 Beach 134 95 80 126.0 0.25 229 57.25 25 7/7/2016 Beach 143 101 81 135.0 0.25 244 61.00 26 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 27 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 28 NaN Beach 123 86 82 113.0 0.25 209 52.25 29 7/10/2016 Beach 140 98 82 131.0 0.25 238 59.50 30 7/11/2016 Beach 162 120 83 135.0 0.25 282 70.50 31 7/12/2016 Beach 130 95 84 99.0 0.25 225 56.25 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-01726fb0-ad5d-4c27-8854-1c16be47eb57 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-01726fb0-ad5d-4c27-8854-1c16be47eb57'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; GroupBy 피벗테이블 R dplyr groupby() %&gt;% summarise() –&gt; 데이터 요약 –&gt; 엑셀로 피벗테이블 1juice.groupby(by = 'Location').count() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Lemon Orange Temperature Leaflets Price Sold Revenue Location Beach 16 17 17 17 17 17 17 17 Park 15 15 15 15 14 15 15 15 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-a4c7e270-f5f6-490c-8a9d-5cb6518120e2 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-a4c7e270-f5f6-490c-8a9d-5cb6518120e2'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1234import numpy as np# juice.groupby(['Location'])['Revenue'].agg([max, min, sum, np.mean])juice.groupby(['Location'])['Revenue', 'Lemon'].agg([max, min, sum, np.mean]) /usr/local/lib/python3.7/dist-packages/ipykernel_launcher.py:3: FutureWarning: Indexing with multiple keys (implicitly converted to a tuple of keys) will be deprecated, use a list instead. This is separate from the ipykernel package so we can avoid doing imports until .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead tr th { text-align: left; } .dataframe thead tr:last-of-type th { text-align: right; } Revenue Lemon max min sum mean max min sum mean Location Beach 95.5 43.0 1002.8 58.988235 162 76 2020 118.823529 Park 134.5 41.0 1178.2 78.546667 176 71 1697 113.133333 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-adba7483-c832-4148-981e-d4674267382a button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-adba7483-c832-4148-981e-d4674267382a'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt;","link":"/2022/03/23/0323_Pandas_tutorial/"},{"title":"Pandas-10minutes","text":"라이브러리 불러오기1234567import pandas as pdimport numpy as npimport matplotlib.pyplot as pltprint(pd.__version__)print(np.__version__)print(plt) 1.3.5 1.21.5 &lt;module 'matplotlib.pyplot' from '/usr/local/lib/python3.7/dist-packages/matplotlib/pyplot.py'&gt; Object Creation (객체 생성)123from pandas._libs.tslibs import dtypess = pd.Series([1, 3, 5, np.nan, 6, 8])print(s) 0 1.0 1 3.0 2 5.0 3 NaN 4 6.0 5 8.0 dtype: float64 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-33-14eb9ffeb2ec&gt; in &lt;module&gt;() 2 s = pd.Series([1, 3, 5, np.nan, 6, 8]) 3 print(s) ----&gt; 4 dtypes(s) TypeError: 'module' object is not callable datetime 인덱스와 레이블이 있는 열을 가지고 있는 numpy배열을 전달하여 데이터 프레임을 만듦. 12dates = pd.date_range('20130101', periods = 6)dates DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05', '2013-01-06'], dtype='datetime64[ns]', freq='D') 12df = pd.DataFrame(np.random.randn(6,4), index = dates, columns= list('ABCD'))df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 -0.677426 -2.196739 0.738424 -0.962850 2013-01-02 -1.199929 1.319515 0.777609 -0.392175 2013-01-03 0.805624 0.050666 -1.464994 1.084636 2013-01-04 0.959534 0.795302 -0.095255 0.772399 2013-01-05 0.793272 -0.111170 -1.448753 -1.231591 2013-01-06 -0.365826 -0.042358 -0.063809 -0.829247 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-345b081b-e35d-4f4b-bc89-2ed611d36f5f button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-345b081b-e35d-4f4b-bc89-2ed611d36f5f'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; series 와 같은 것으로 변환 될 수 있는 객체들의 dict로 구성된 데이터 프레임을 만듭니다. 123456789101112from pandas.core.arrays.sparse import dtypedf2 = pd.DataFrame({'A': 1., 'B': pd.Timestamp('20130102'), 'C': pd.Series(1, index= list(range(4)), dtype='float32'), 'D': np.array([3] * 4, dtype = 'int32'), &quot;E&quot;: pd.Categorical([&quot;test&quot;, &quot;train&quot;, &quot;test&quot;, &quot;train&quot;]), &quot;F&quot;: &quot;foo&quot;})print(df2)df3 = pd.DataFrame({'A': 1., 'C': pd.Series(1, index= list(range(5)), dtype='float32'), &quot;B&quot;: 2.}) A B C D E F 0 1.0 2013-01-02 1.0 3 test foo 1 1.0 2013-01-02 1.0 3 train foo 2 1.0 2013-01-02 1.0 3 test foo 3 1.0 2013-01-02 1.0 3 train foo 데이터 프레임 결과물의 열은 다양한 데이터 타입(dtypes)으로 구성됩니다. 1df2.dtypes A float64 B datetime64[ns] C float32 D int32 E category F object dtype: object Viewing Data (데이터 확인하기)12df.tail(2)df.head() # 숫자를 입력하지 않으면 default값인 5로 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 -0.677426 -2.196739 0.738424 -0.962850 2013-01-02 -1.199929 1.319515 0.777609 -0.392175 2013-01-03 0.805624 0.050666 -1.464994 1.084636 2013-01-04 0.959534 0.795302 -0.095255 0.772399 2013-01-05 0.793272 -0.111170 -1.448753 -1.231591 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-b2678df4-0f17-4d31-aac8-58ad617d25bd button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-b2678df4-0f17-4d31-aac8-58ad617d25bd'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 인덱스(index), 열(column), numpy데이터에 대한 세부정보를 봅니다. 123print(&quot;인덱스: &quot;, df.index)print(&quot;열: &quot;, df.columns)print(&quot;데이터 정보: &quot;, df.values) 인덱스: DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05', '2013-01-06'], dtype='datetime64[ns]', freq='D') 열: Index(['A', 'B', 'C', 'D'], dtype='object') 데이터 정보: [[-0.67742608 -2.19673867 0.73842372 -0.96284978] [-1.19992881 1.31951476 0.77760924 -0.39217529] [ 0.80562441 0.05066603 -1.4649944 1.0846364 ] [ 0.95953417 0.79530189 -0.09525536 0.7723991 ] [ 0.79327228 -0.11116996 -1.44875254 -1.2315911 ] [-0.36582647 -0.04235798 -0.06380873 -0.82924664]] describe()는 대략적인 통계적 정보 요약을 보여줍니다. 1df.describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D count 6.000000 6.000000 6.000000 6.000000 mean 0.052542 -0.030797 -0.259463 -0.259805 std 0.918152 1.200859 1.000426 0.964717 min -1.199929 -2.196739 -1.464994 -1.231591 25% -0.599526 -0.093967 -1.110378 -0.929449 50% 0.213723 0.004154 -0.079532 -0.610711 75% 0.802536 0.609143 0.537866 0.481256 max 0.959534 1.319515 0.777609 1.084636 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-39c60ada-9901-4c6a-8a75-60a7ec8e7188 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-39c60ada-9901-4c6a-8a75-60a7ec8e7188'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 데이터를 전치합니다. 행과 열을 전환 1df.T .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 2013-01-01 2013-01-02 2013-01-03 2013-01-04 2013-01-05 2013-01-06 A -0.677426 -1.199929 0.805624 0.959534 0.793272 -0.365826 B -2.196739 1.319515 0.050666 0.795302 -0.111170 -0.042358 C 0.738424 0.777609 -1.464994 -0.095255 -1.448753 -0.063809 D -0.962850 -0.392175 1.084636 0.772399 -1.231591 -0.829247 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-6b9933ab-ddad-4860-aac0-e6048c2c221a button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-6b9933ab-ddad-4860-aac0-e6048c2c221a'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 축별로 정렬합니다. axis= : 0 =&gt; 행기준 , 1 =&gt; 열기준 default 값 : 0(행기준) ascending=False : 내림차순 정렬 default 값 : True(오름차순) 1df.sort_index(axis=1, ascending=False) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } D C B A 2013-01-01 -0.962850 0.738424 -2.196739 -0.677426 2013-01-02 -0.392175 0.777609 1.319515 -1.199929 2013-01-03 1.084636 -1.464994 0.050666 0.805624 2013-01-04 0.772399 -0.095255 0.795302 0.959534 2013-01-05 -1.231591 -1.448753 -0.111170 0.793272 2013-01-06 -0.829247 -0.063809 -0.042358 -0.365826 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-443c8902-8f35-493e-9fce-86b7d95b95b1 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-443c8902-8f35-493e-9fce-86b7d95b95b1'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 값별로 정렬합니다. B의 값을 기준으로 오름차순. 1df.sort_values(by=&quot;B&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 -0.677426 -2.196739 0.738424 -0.962850 2013-01-05 0.793272 -0.111170 -1.448753 -1.231591 2013-01-06 -0.365826 -0.042358 -0.063809 -0.829247 2013-01-03 0.805624 0.050666 -1.464994 1.084636 2013-01-04 0.959534 0.795302 -0.095255 0.772399 2013-01-02 -1.199929 1.319515 0.777609 -0.392175 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-86aaa540-7bd7-4a45-bb80-d078e6e0642a button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-86aaa540-7bd7-4a45-bb80-d078e6e0642a'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Selection(선택)Getting (데이터 얻기) df.A 와 동일한 series를 생성하는 단일열을 선택합니다. 1df[&quot;A&quot;] 2013-01-01 -0.677426 2013-01-02 -1.199929 2013-01-03 0.805624 2013-01-04 0.959534 2013-01-05 0.793272 2013-01-06 -0.365826 Freq: D, Name: A, dtype: float64 행을 분할하는 [ ] 를 통해 선택합니다. 1df[0:3] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 -0.677426 -2.196739 0.738424 -0.962850 2013-01-02 -1.199929 1.319515 0.777609 -0.392175 2013-01-03 0.805624 0.050666 -1.464994 1.084636 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-5f128668-ad35-45bb-9007-81a32547b1cb button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-5f128668-ad35-45bb-9007-81a32547b1cb'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df[&quot;2013-01-02&quot;:&quot;2013-01-04&quot;] # 20130102 형태로도 가능 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-02 -1.199929 1.319515 0.777609 -0.392175 2013-01-03 0.805624 0.050666 -1.464994 1.084636 2013-01-04 0.959534 0.795302 -0.095255 0.772399 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-31710cdf-3515-4a3d-87ef-54f0f70ed7b2 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-31710cdf-3515-4a3d-87ef-54f0f70ed7b2'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Selection by Label (Label을 통한 선택) 라벨을 사용하여 횡단면을 얻습니다. 1df.loc[dates[0]] A -0.677426 B -2.196739 C 0.738424 D -0.962850 Name: 2013-01-01 00:00:00, dtype: float64 라벨을 사용하여 여러 축의 데이터를 얻습니다. 1df.loc[:,[&quot;A&quot;,&quot;B&quot;]] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B 2013-01-01 -0.677426 -2.196739 2013-01-02 -1.199929 1.319515 2013-01-03 0.805624 0.050666 2013-01-04 0.959534 0.795302 2013-01-05 0.793272 -0.111170 2013-01-06 -0.365826 -0.042358 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-35c852b9-23a9-49e9-bbd0-33b3153a74c3 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-35c852b9-23a9-49e9-bbd0-33b3153a74c3'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 양쪽 종단점을 포함한 라벨 슬라이싱을 봅니다. 1df.loc[&quot;2013-01-02&quot;: &quot;2013-01-04&quot;, [&quot;A&quot;,&quot;B&quot;]] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B 2013-01-02 -1.199929 1.319515 2013-01-03 0.805624 0.050666 2013-01-04 0.959534 0.795302 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-94f185fc-c3bf-4fac-a75f-fff3b7ec6e61 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-94f185fc-c3bf-4fac-a75f-fff3b7ec6e61'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 반환되는 객체의 차원을 줄입니다. 1df.loc[&quot;2013-01-02&quot;, [&quot;A&quot;,&quot;B&quot;]] A -1.199929 B 1.319515 Name: 2013-01-02 00:00:00, dtype: float64 스칼라 값을 얻습니다. 1df.loc[dates[0],&quot;A&quot;] -0.6774260779872779 Selection by Position (위치로 선택하기)1df.iloc[3] A 0.959534 B 0.795302 C -0.095255 D 0.772399 Name: 2013-01-04 00:00:00, dtype: float64 정수로 표기된 슬라이스들을 통해, numpy / python과 유사하게 작동합니다. 1df.iloc[3:5, 0:2] #df.iloc[행, 열] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B 2013-01-04 0.959534 0.795302 2013-01-05 0.793272 -0.111170 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-cd151b88-e0bd-4e10-9361-de70a1a23121 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-cd151b88-e0bd-4e10-9361-de70a1a23121'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 정수로 표기된 위치값의 리스트들을 통해, numpy / python 의 스타일과 유사해집니다. 1df.iloc[[1,2,4],[0,2]] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A C 2013-01-02 -1.199929 0.777609 2013-01-03 0.805624 -1.464994 2013-01-05 0.793272 -1.448753 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-dbffe2fb-e83f-4b4c-8a9a-e521cad0b148 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-dbffe2fb-e83f-4b4c-8a9a-e521cad0b148'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 명시적으로 행을 나누고자 하는 경우입니다. 1df.iloc[1:3,:] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-02 -1.199929 1.319515 0.777609 -0.392175 2013-01-03 0.805624 0.050666 -1.464994 1.084636 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-26cb4538-20ec-493a-924a-def57038f219 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-26cb4538-20ec-493a-924a-def57038f219'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 명시적으로 열을 나누고자 하는 경우입니다. 1df.iloc[:,1:3] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } B C 2013-01-01 -2.196739 0.738424 2013-01-02 1.319515 0.777609 2013-01-03 0.050666 -1.464994 2013-01-04 0.795302 -0.095255 2013-01-05 -0.111170 -1.448753 2013-01-06 -0.042358 -0.063809 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-fa12cd8e-b7ee-4d46-a9d8-f3936f4f3c05 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-fa12cd8e-b7ee-4d46-a9d8-f3936f4f3c05'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 명시적으로 특정한 값을 얻고자 하는 경우입니다. 12print(df.iloc[1,2])print(df.iat[1,2]) 0.7776092446304973 0.7776092446304973 Boolean indexing 데이터를 선택하기 위해 단일 열의 값을 사용합니다. 1df[df.A&gt; 0] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-03 0.805624 0.050666 -1.464994 1.084636 2013-01-04 0.959534 0.795302 -0.095255 0.772399 2013-01-05 0.793272 -0.111170 -1.448753 -1.231591 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-d7d039fd-1e57-4402-98ea-dcc411a3a60e button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-d7d039fd-1e57-4402-98ea-dcc411a3a60e'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Boolean 조건을 충족하는 데이터 프레임에서 값을 선택합니다. 1df[df &gt; 0] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 NaN NaN 0.738424 NaN 2013-01-02 NaN 1.319515 0.777609 NaN 2013-01-03 0.805624 0.050666 NaN 1.084636 2013-01-04 0.959534 0.795302 NaN 0.772399 2013-01-05 0.793272 NaN NaN NaN 2013-01-06 NaN NaN NaN NaN &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-44c86211-7ece-4974-9d24-1c203511eb72 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-44c86211-7ece-4974-9d24-1c203511eb72'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 필터링을 위한 메소드 isin()을 사용합니다. 123df2 = df.copy()df2[&quot;E&quot;] = [&quot;one&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;three&quot;]df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E 2013-01-01 -0.677426 -2.196739 0.738424 -0.962850 one 2013-01-02 -1.199929 1.319515 0.777609 -0.392175 one 2013-01-03 0.805624 0.050666 -1.464994 1.084636 two 2013-01-04 0.959534 0.795302 -0.095255 0.772399 three 2013-01-05 0.793272 -0.111170 -1.448753 -1.231591 four 2013-01-06 -0.365826 -0.042358 -0.063809 -0.829247 three &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-17d8fa64-3090-417c-91d3-133d3b338da3 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-17d8fa64-3090-417c-91d3-133d3b338da3'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df2[df2[&quot;E&quot;].isin([&quot;two&quot;,&quot;four&quot;])] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E 2013-01-03 0.805624 0.050666 -1.464994 1.084636 two 2013-01-05 0.793272 -0.111170 -1.448753 -1.231591 four &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-e38d8f9c-7925-4fdf-bb9f-fb3ca65cc04d button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-e38d8f9c-7925-4fdf-bb9f-fb3ca65cc04d'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Setting (설정) 새 열을 설정하면 데이터가 인덱스 별로 자동 정렬됩니다. 12s1 = pd.Series([1, 2, 3, 4, 5, 6], index=pd.date_range(&quot;2013-01-02&quot;, periods= 6))s1 2013-01-02 1 2013-01-03 2 2013-01-04 3 2013-01-05 4 2013-01-06 5 2013-01-07 6 Freq: D, dtype: int64 1df[&quot;F&quot;] = s1 2013-01-01 NaN 2013-01-02 1.0 2013-01-03 2.0 2013-01-04 3.0 2013-01-05 4.0 2013-01-06 5.0 Freq: D, Name: F, dtype: float64 라벨에 의해 값을 설정 위치에 의해 값을 설정 Numpy 배열을 사용한 할당에 의해 값을 설정 1234df.at[dates[0],&quot;A&quot;] = 0df.iat[0,1] = 0df.loc[:, &quot;D&quot;] = np.array([5] * len(df))df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2013-01-01 0.000000 0.000000 0.738424 5 NaN 2013-01-02 -1.199929 1.319515 0.777609 5 1.0 2013-01-03 0.805624 0.050666 -1.464994 5 2.0 2013-01-04 0.959534 0.795302 -0.095255 5 3.0 2013-01-05 0.793272 -0.111170 -1.448753 5 4.0 2013-01-06 -0.365826 -0.042358 -0.063809 5 5.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-2c3aadf9-8da3-4708-bf50-2593cefed2c5 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-2c3aadf9-8da3-4708-bf50-2593cefed2c5'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; where 연산을 설정 123df2 = df.copy()df2[df2 &gt; 0] = -df2 # 모든 데이터를 음수로 변환df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2013-01-01 0.000000 0.000000 -0.738424 -5 NaN 2013-01-02 -1.199929 -1.319515 -0.777609 -5 -1.0 2013-01-03 -0.805624 -0.050666 -1.464994 -5 -2.0 2013-01-04 -0.959534 -0.795302 -0.095255 -5 -3.0 2013-01-05 -0.793272 -0.111170 -1.448753 -5 -4.0 2013-01-06 -0.365826 -0.042358 -0.063809 -5 -5.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-f72cdfe9-be3a-48c0-be30-5b18a92e3d76 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-f72cdfe9-be3a-48c0-be30-5b18a92e3d76'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Missing Data (결측치)123df1 = df.reindex(index= dates[0:4], columns= list(df.columns) + [&quot;E&quot;])df1.loc[dates[0]: dates[1], &quot;E&quot;] = 1df1 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2013-01-01 0.000000 0.000000 0.738424 5 NaN 1.0 2013-01-02 -1.199929 1.319515 0.777609 5 1.0 1.0 2013-01-03 0.805624 0.050666 -1.464994 5 2.0 NaN 2013-01-04 0.959534 0.795302 -0.095255 5 3.0 NaN &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-f61d202d-58dd-4723-867e-543f5876e8cf button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-f61d202d-58dd-4723-867e-543f5876e8cf'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 결측치를 가지고 있는 행들을 지웁니다 1df1.dropna(how=&quot;any&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2013-01-02 -1.199929 1.319515 0.777609 5 1.0 1.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-d09293c5-de39-44d1-bf7b-0474939fd7f4 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-d09293c5-de39-44d1-bf7b-0474939fd7f4'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 결측치를 채워 넣습니다. 1df1.fillna(value = 5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2013-01-01 0.000000 0.000000 0.738424 5 5.0 1.0 2013-01-02 -1.199929 1.319515 0.777609 5 1.0 1.0 2013-01-03 0.805624 0.050666 -1.464994 5 2.0 5.0 2013-01-04 0.959534 0.795302 -0.095255 5 3.0 5.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-5f617de5-b3ad-4032-9547-1f9724e1d683 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-5f617de5-b3ad-4032-9547-1f9724e1d683'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; nan인 값에 boolean을 통한 표식을 얻습니다. 1pd.isna(df1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2013-01-01 False False False False True False 2013-01-02 False False False False False False 2013-01-03 False False False False False True 2013-01-04 False False False False False True &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-ead6838a-6332-476d-897a-d9704fb082be button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-ead6838a-6332-476d-897a-d9704fb082be'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Operation (연산)Stats (통계) 일반적으로 결측치를 제외한 후 연산됩니다. 기술 통계를 수행합니다. 12df.mean()df.mean(1) 2013-01-01 1.434606 2013-01-02 1.379439 2013-01-03 1.278259 2013-01-04 1.931916 2013-01-05 1.646670 2013-01-06 1.905601 Freq: D, dtype: float64 정렬이 필요하며, 차원이 다른 객체로 연산해보겠습니다 또한 pandas는 지정된 차원을 따라 자동으로 브로드캐스팅됩니다. 12s = pd.Series([1, 3, 5, np.nan, 6, 8], index= dates).shift(2)df.sub(s, axis=&quot;index&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2013-01-01 NaN NaN NaN NaN NaN 2013-01-02 NaN NaN NaN NaN NaN 2013-01-03 -0.194376 -0.949334 -2.464994 4.0 1.0 2013-01-04 -2.040466 -2.204698 -3.095255 2.0 0.0 2013-01-05 -4.206728 -5.111170 -6.448753 0.0 -1.0 2013-01-06 NaN NaN NaN NaN NaN &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-e783541b-ea91-438d-ba25-841021ec301c button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-e783541b-ea91-438d-ba25-841021ec301c'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Apply (적용)1df.apply(np.cumsum) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2013-01-01 0.000000 0.000000 0.738424 5 NaN 2013-01-02 -1.199929 1.319515 1.516033 10 1.0 2013-01-03 -0.394304 1.370181 0.051039 15 3.0 2013-01-04 0.565230 2.165483 -0.044217 20 6.0 2013-01-05 1.358502 2.054313 -1.492969 25 10.0 2013-01-06 0.992676 2.011955 -1.556778 30 15.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-359430a0-ed3f-4c6b-ac2d-b5a98ea550f1 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-359430a0-ed3f-4c6b-ac2d-b5a98ea550f1'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df.apply(lambda x: x.max() - x.min()) A 2.159463 B 1.430685 C 2.242604 D 0.000000 F 4.000000 dtype: float64 Histogramming (히스토그래밍)12s = pd.Series(np.random.randint(0, 7, size = 10))s.value_counts() 6 3 2 2 4 2 1 2 0 1 dtype: int64 String Methods (문자열 메소드)12s = pd.Series([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;aaba&quot;, &quot;baca&quot;, np.nan, &quot;caba&quot;, &quot;dog&quot;, &quot;cat&quot;])s.str.lower() 0 a 1 b 2 c 3 aaba 4 baca 5 NaN 6 caba 7 dog 8 cat dtype: object Merge (병합)Concat (연결)123df = pd.DataFrame(np.random.randn(10, 4))pieces = [df[:3], df[3:7], df[7:]]pd.concat(pieces) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 3 0 -0.829811 0.305457 0.604381 0.809243 1 -0.755741 -1.013979 -1.169954 -0.234035 2 0.124383 0.805705 -1.430164 1.402136 3 1.740482 -0.199307 1.340367 -0.024811 4 -0.781526 -0.157126 -1.945904 -1.566165 5 -1.050021 -0.649171 1.744635 1.051927 6 1.342340 -0.459930 -0.330127 1.141308 7 0.452604 -2.557386 -1.576515 -0.313172 8 0.068089 0.133163 0.470251 0.912866 9 0.808804 -0.714312 1.347808 0.108039 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-a4408af2-8393-4e84-88a1-a056c4a62e31 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-a4408af2-8393-4e84-88a1-a056c4a62e31'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Join (결합)123left = pd.DataFrame({&quot;key&quot;: [&quot;foo&quot;, &quot;foo&quot;], &quot;lva1&quot;: [1, 2]})right = pd.DataFrame({&quot;key&quot;: [&quot;foo&quot;, &quot;foo&quot;], &quot;rva1&quot;: [4, 5]})pd.merge(left, right, on= &quot;key&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } key lva1 rva1 0 foo 1 4 1 foo 1 5 2 foo 2 4 3 foo 2 5 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-2955d2a7-1efe-4a61-82d3-1f7b51f59e86 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-2955d2a7-1efe-4a61-82d3-1f7b51f59e86'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 123left = pd.DataFrame({&quot;key&quot;: [&quot;foo&quot;, &quot;bar&quot;], &quot;lva1&quot;: [1, 2]})right = pd.DataFrame({&quot;key&quot;: [&quot;foo&quot;, &quot;bar&quot;], &quot;rva1&quot;: [4, 5]})pd.merge(left, right, on= &quot;key&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } key lva1 rva1 0 foo 1 4 1 bar 2 5 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-b59f499a-21d0-41e1-b256-a332d956546d button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-b59f499a-21d0-41e1-b256-a332d956546d'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Append (추가)123df = pd.DataFrame(np.random.randn(8, 4), columns=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])s = df.iloc[3]df.append(s, ignore_index=True) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } a b c d 0 -0.204723 0.489053 -0.894074 -0.351580 1 0.511574 0.238418 0.002020 0.661753 2 0.486480 0.138538 -0.521380 0.256900 3 -1.227130 0.288621 -0.622474 0.049596 4 0.042815 -0.383467 0.499939 1.288639 5 -1.069577 -0.775831 1.065877 -0.924868 6 0.536642 1.962266 -1.454352 0.027589 7 -0.661381 1.468953 -0.376752 -0.102585 8 -1.227130 0.288621 -0.622474 0.049596 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-89214779-99f5-4f68-9062-1808af0b4d07 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-89214779-99f5-4f68-9062-1808af0b4d07'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Grouping (그룹화)123456789df = pd.DataFrame( { &quot;a&quot;: [&quot;foo&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;foo&quot;], &quot;b&quot;: [&quot;one&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;two&quot;, &quot;two&quot;, &quot;one&quot;, &quot;three&quot;], &quot;c&quot;: np.random.randn(8), &quot;d&quot;: np.random.randn(8) })df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } a b c d 0 foo one 0.959407 1.008019 1 bar one 0.719167 -0.018181 2 foo two -0.499245 -0.315099 3 bar three -0.024763 -0.961644 4 foo two 0.525711 -0.981306 5 bar two -0.512849 1.625778 6 foo one 0.127170 1.642398 7 foo three 0.657616 -1.092527 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-7df61f7f-4d8d-4a64-b854-56e703902ca9 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-7df61f7f-4d8d-4a64-b854-56e703902ca9'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 생성된 데이터 프레임을 그룹화 한 후 각 그룹에 sum() 함수를 적용시킨다. 1df.groupby(&quot;a&quot;).sum() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } c d a bar 0.181555 0.645952 foo 1.770659 0.261486 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-982a6307-9e77-4be7-bebd-378a34ae0c04 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-982a6307-9e77-4be7-bebd-378a34ae0c04'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 여러 열을 기준으로 그룹화 하면 계층적 인덱스가 형성됩니다. 1df.groupby([&quot;a&quot;, &quot;b&quot;]).sum() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } c d a b bar one 0.719167 -0.018181 three -0.024763 -0.961644 two -0.512849 1.625778 foo one 1.086577 2.650417 three 0.657616 -1.092527 two 0.026466 -1.296404 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-1a6ab397-f129-4bf7-89b5-0590c5a1f4e7 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-1a6ab397-f129-4bf7-89b5-0590c5a1f4e7'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Reshaping (변형)Stack (스택)12345678tuples = list(zip(*[[&quot;bar&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;baz&quot;, &quot;foo&quot;, &quot;foo&quot;, &quot;qux&quot;, &quot;qux&quot;], [&quot;one&quot;, &quot;two&quot;, &quot;one&quot;, &quot;two&quot;, &quot;one&quot;, &quot;two&quot;, &quot;one&quot;, &quot;two&quot;,]]))index = pd.MultiIndex.from_tuples(tuples, names= [&quot;first&quot;, &quot;second&quot;])df = pd.DataFrame(np.random.randn(8, 2), index= index, columns= [&quot;a&quot;, &quot;b&quot;])df2 = df[:4]df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } a b first second bar one 0.111431 -0.713655 two 0.336854 0.659695 baz one 0.240226 1.015802 two -0.069205 1.544390 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-0c2df5de-cb87-4d4d-badf-7084cf416ea5 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-0c2df5de-cb87-4d4d-badf-7084cf416ea5'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Stack() 메소드는 데이터 프레임 열들의 계층을 압축합니다. 12stacked = df2.stack()stacked first second bar one a 0.111431 b -0.713655 two a 0.336854 b 0.659695 baz one a 0.240226 b 1.015802 two a -0.069205 b 1.544390 dtype: float64 Stack된 데이터 프레임 또는 (MultiIndex를 인덱스로 사용하는) Series인 경우, Stack()의 역 연산은 Unstack()이며, 기본적으로 마지막 계층을 Unstack 합니다. 1stacked.unstack() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } a b first second bar one 0.111431 -0.713655 two 0.336854 0.659695 baz one 0.240226 1.015802 two -0.069205 1.544390 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-eaecb9d5-af3c-4453-a80b-f47e4e379a6e button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-eaecb9d5-af3c-4453-a80b-f47e4e379a6e'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1stacked.unstack(1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } second one two first bar a 0.111431 0.336854 b -0.713655 0.659695 baz a 0.240226 -0.069205 b 1.015802 1.544390 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-9ee9cdf7-8d3c-4722-9921-4115b741c0b1 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-9ee9cdf7-8d3c-4722-9921-4115b741c0b1'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1stacked.unstack(0) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } first bar baz second one a 0.111431 0.240226 b -0.713655 1.015802 two a 0.336854 -0.069205 b 0.659695 1.544390 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-4ef7bccd-b9ea-4de3-a2f5-399b2e8730a6 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-4ef7bccd-b9ea-4de3-a2f5-399b2e8730a6'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Pivot Tables (피벗 테이블)123456df = pd.DataFrame({&quot;a&quot;: [&quot;one&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;]* 3, &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]* 4, &quot;c&quot;: [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;bar&quot;, &quot;bar&quot;]* 2, &quot;d&quot;: np.random.randn(12), &quot;e&quot;: np.random.randn(12)})df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } a b c d e 0 one a foo 1.334789 0.841909 1 one b foo -2.257890 1.049709 2 two c foo 0.415195 1.111372 3 three a bar 0.833915 0.154236 4 one b bar -0.276610 0.694393 5 one c bar -1.476431 0.393172 6 two a foo -0.623332 -0.114777 7 three b foo 1.280424 -1.779510 8 one c foo -0.747539 -0.131925 9 one a bar -0.835340 0.918856 10 two b bar -0.305618 -0.278606 11 three c bar -1.226162 -0.408292 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-78bea9c0-5dd4-4d0b-93fc-509a404732ec button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-78bea9c0-5dd4-4d0b-93fc-509a404732ec'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 피벗테이블 생성 1pd.pivot_table(df, values= &quot;d&quot;, index= [&quot;a&quot;, &quot;b&quot;], columns= [&quot;c&quot;]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } c bar foo a b one a -0.835340 1.334789 b -0.276610 -2.257890 c -1.476431 -0.747539 three a 0.833915 NaN b NaN 1.280424 c -1.226162 NaN two a NaN -0.623332 b -0.305618 NaN c NaN 0.415195 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-deee4ffb-0db7-4cdb-bdc9-e444f8f6dfc4 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-deee4ffb-0db7-4cdb-bdc9-e444f8f6dfc4'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Time Series (시계열)123rng = pd.date_range(&quot;1/1/2012&quot;, periods= 100, freq= &quot;S&quot;)ts = pd.Series(np.random.randint(0, 500, len(rng)), index= rng)ts.resample(&quot;5Min&quot;).sum() 2012-01-01 26850 Freq: 5T, dtype: int64 123rng = pd.date_range(&quot;3/6/2012 00:00&quot;, periods = 5, freq= &quot;D&quot;)ts = pd. Series(np.random.randn(len(rng)), rng)ts 2012-03-06 -1.090691 2012-03-07 -0.189600 2012-03-08 0.461211 2012-03-09 0.079665 2012-03-10 0.112384 Freq: D, dtype: float64 12ts_utc = ts.tz_localize(&quot;utc&quot;)ts_utc 2012-03-06 00:00:00+00:00 -1.090691 2012-03-07 00:00:00+00:00 -0.189600 2012-03-08 00:00:00+00:00 0.461211 2012-03-09 00:00:00+00:00 0.079665 2012-03-10 00:00:00+00:00 0.112384 Freq: D, dtype: float64 다른 시간대로 변환합니다. 1ts_utc.tz_convert(&quot;US/Eastern&quot;) 2012-03-05 19:00:00-05:00 -1.090691 2012-03-06 19:00:00-05:00 -0.189600 2012-03-07 19:00:00-05:00 0.461211 2012-03-08 19:00:00-05:00 0.079665 2012-03-09 19:00:00-05:00 0.112384 Freq: D, dtype: float64 시간 표현 &lt;-&gt; 기간 표현으로 변환합니다. 123rng = pd.date_range(&quot;1/1/2012&quot;, periods=5, freq= &quot;M&quot;)ts = pd.Series(np.random.randn(len(rng)), index= rng)ts 2012-01-31 0.751707 2012-02-29 -0.065882 2012-03-31 -0.015339 2012-04-30 1.058019 2012-05-31 0.186747 Freq: M, dtype: float64 12ps = ts.to_period()ps 2012-01 0.751707 2012-02 -0.065882 2012-03 -0.015339 2012-04 1.058019 2012-05 0.186747 Freq: M, dtype: float64 1ps.to_timestamp() 2012-01-01 0.751707 2012-02-01 -0.065882 2012-03-01 -0.015339 2012-04-01 1.058019 2012-05-01 0.186747 Freq: MS, dtype: float64 기간 &lt;-&gt; 시간 변환은 편리한 산술 기능들을 사용 할 수 있도록 만들어줍니다. 다음 예제에서 우리는 11월에 끝나는 연말 결산의 분기별 비녿를 분기말 익월의 월말일 오전 9시로 변환합니다. 1234prng = pd.period_range(&quot;1990Q1&quot;, &quot;2000Q4&quot;, freq= &quot;Q-NOV&quot;)ts = pd.Series(np.random.randn(len(prng)), prng)ts.index = (prng.asfreq(&quot;M&quot;, &quot;e&quot;) + 1).asfreq(&quot;H&quot;, &quot;s&quot;) + 9ts.head() 1990-03-01 09:00 1.377842 1990-06-01 09:00 -0.317984 1990-09-01 09:00 -0.229224 1990-12-01 09:00 -0.378939 1991-03-01 09:00 -0.829271 Freq: H, dtype: float64 Categoricals (범주화)123df = pd.DataFrame({&quot;id&quot;: [1,2,3,4,5,6], &quot;raw_grade&quot;: [&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;a&quot;,&quot;e&quot;]})df[&quot;grade&quot;] = df[&quot;raw_grade&quot;].astype(&quot;category&quot;)df[&quot;grade&quot;] 0 a 1 b 2 b 3 a 4 a 5 e Name: grade, dtype: category Categories (3, object): ['a', 'b', 'e'] 범주에 더 의미 있는 이름을 붙여주세요. series.cat.categories로 할당하는것이 적합합니다. 123df[&quot;grade&quot;].cat.categories = [&quot;very good&quot;, &quot;good&quot;, &quot;very bad&quot;]df[&quot;grade&quot;] = df[&quot;grade&quot;].cat.set_categories([&quot;very bad&quot;, &quot;bad&quot;, &quot;medium&quot;, &quot;good&quot;, &quot;very good&quot;])df[&quot;grade&quot;] 0 very good 1 good 2 good 3 very good 4 very good 5 very bad Name: grade, dtype: category Categories (5, object): ['very bad', 'bad', 'medium', 'good', 'very good'] 정렬은 사전 순서가 아닌, 해당 범주에서 지정된 순서대로 배열됨. 1df.sort_values(by=&quot;grade&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } id raw_grade grade 5 6 e very bad 1 2 b good 2 3 b good 0 1 a very good 3 4 a very good 4 5 a very good &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-606cacd1-0dd9-4532-9f2c-03ce41c039d5 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-606cacd1-0dd9-4532-9f2c-03ce41c039d5'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df.groupby(&quot;grade&quot;).size() grade very bad 1 bad 0 medium 0 good 2 very good 3 dtype: int64 Plotting (그래프)123ts = pd.Series(np.random.randn(1000), index= pd.date_range(&quot;1/1/2000&quot;, periods=1000))ts = ts.cumsum()ts.plot() &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f9fac7de9d0&gt; 데이터 프레임에서 plot() 메소드는 라벨이 존재하는 모든 열을 그릴 때 편리합니다. 1234df = pd.DataFrame(np.random.randn(1000, 4), index = ts.index, columns=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])df = df.cumsum()plt.figure(); df.plot(); plt.legend(loc=&quot;best&quot;) &lt;matplotlib.legend.Legend at 0x7f9fac4b3710&gt; &lt;Figure size 432x288 with 0 Axes&gt; Getting Data In / Out (데이터 입/출력)CSV12df.to_csv(&quot;foo.csv&quot;)pd.read_csv(&quot;foo.csv&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Unnamed: 0 a b c d 0 2000-01-01 0.602289 -0.232301 0.916654 2.266257 1 2000-01-02 1.015143 -0.490518 0.073563 0.787056 2 2000-01-03 -0.896743 0.202568 1.268194 -0.536958 3 2000-01-04 -1.865754 1.233353 3.414621 2.454318 4 2000-01-05 -2.284890 1.609294 3.185290 1.382976 ... ... ... ... ... ... 995 2002-09-22 -73.320784 -18.595650 -29.400863 -14.579961 996 2002-09-23 -72.320465 -17.659652 -29.681909 -14.400609 997 2002-09-24 -72.690819 -17.669215 -30.550358 -15.263950 998 2002-09-25 -71.966416 -17.371709 -30.298391 -14.388399 999 2002-09-26 -72.741877 -16.666626 -29.623592 -13.877525 1000 rows × 5 columns &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-bea5bb1b-501e-4dad-ab2f-3e30389db5e4 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-bea5bb1b-501e-4dad-ab2f-3e30389db5e4'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; HDF512df.to_hdf(&quot;foo.h5&quot;, &quot;df&quot;)pd.read_hdf(&quot;foo.h5&quot;, &quot;df&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } a b c d 2000-01-01 0.602289 -0.232301 0.916654 2.266257 2000-01-02 1.015143 -0.490518 0.073563 0.787056 2000-01-03 -0.896743 0.202568 1.268194 -0.536958 2000-01-04 -1.865754 1.233353 3.414621 2.454318 2000-01-05 -2.284890 1.609294 3.185290 1.382976 ... ... ... ... ... 2002-09-22 -73.320784 -18.595650 -29.400863 -14.579961 2002-09-23 -72.320465 -17.659652 -29.681909 -14.400609 2002-09-24 -72.690819 -17.669215 -30.550358 -15.263950 2002-09-25 -71.966416 -17.371709 -30.298391 -14.388399 2002-09-26 -72.741877 -16.666626 -29.623592 -13.877525 1000 rows × 4 columns &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-40089fdc-0976-4e3b-a987-3943205a33ca button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-40089fdc-0976-4e3b-a987-3943205a33ca'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Excel12df.to_excel(&quot;foo.xlsx&quot;, sheet_name = &quot;Sheet1&quot;)pd.read_excel(&quot;foo.xlsx&quot;, &quot;Sheet1&quot;, index_col= None, na_values= [&quot;NA&quot;]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Unnamed: 0 a b c d 0 2000-01-01 0.602289 -0.232301 0.916654 2.266257 1 2000-01-02 1.015143 -0.490518 0.073563 0.787056 2 2000-01-03 -0.896743 0.202568 1.268194 -0.536958 3 2000-01-04 -1.865754 1.233353 3.414621 2.454318 4 2000-01-05 -2.284890 1.609294 3.185290 1.382976 ... ... ... ... ... ... 995 2002-09-22 -73.320784 -18.595650 -29.400863 -14.579961 996 2002-09-23 -72.320465 -17.659652 -29.681909 -14.400609 997 2002-09-24 -72.690819 -17.669215 -30.550358 -15.263950 998 2002-09-25 -71.966416 -17.371709 -30.298391 -14.388399 999 2002-09-26 -72.741877 -16.666626 -29.623592 -13.877525 1000 rows × 5 columns &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-1d1ffc62-76b1-42fd-a1a9-0f5b276cf5b3 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-1d1ffc62-76b1-42fd-a1a9-0f5b276cf5b3'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Gotchas (잡았다!) 연산 수행시 볼 수 있는 예외상황 12if pd.Series([False, True, False]): print(&quot;I was true&quot;) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-221-06fa23a4b3e2&gt; in &lt;module&gt;() ----&gt; 1 if pd.Series([False, True, False]): 2 print(&quot;I was true&quot;) /usr/local/lib/python3.7/dist-packages/pandas/core/generic.py in __nonzero__(self) 1536 def __nonzero__(self): 1537 raise ValueError( -&gt; 1538 f&quot;The truth value of a {type(self).__name__} is ambiguous. &quot; 1539 &quot;Use a.empty, a.bool(), a.item(), a.any() or a.all().&quot; 1540 ) ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all(). 이런 경우 any(), all(), empty 등을 사용해서 무엇을 원하는지를 선택(반영)해 주어야 합니다. 12if pd.Series([False, True, False])is not None: print(&quot;I was true&quot;) I was true","link":"/2022/03/23/0323_10minutes_pandas/"},{"title":"Pandas 연습2","text":"Pandas practice 2 라이브러리 불러오기 12import pandas as pdpd.__version__ '1.3.5' 구글 드라이브 연동 12from google.colab import drivedrive.mount('/content/drive') Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(&quot;/content/drive&quot;, force_remount=True). 불러오기 123DATA_PATH = '/content/drive/MyDrive/Colab Notebooks/data/supermarket_sales.csv'sales = pd.read_csv(DATA_PATH)sales .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Invoice ID Branch City Customer type Gender Product line Unit price Quantity Date Time Payment 0 750-67-8428 A Yangon Member Female Health and beauty 74.69 7 1/5/2019 13:08 Ewallet 1 226-31-3081 C Naypyitaw Normal Female Electronic accessories 15.28 5 3/8/2019 10:29 Cash 2 631-41-3108 A Yangon Normal Male Home and lifestyle 46.33 7 3/3/2019 13:23 Credit card 3 123-19-1176 A Yangon Member Male Health and beauty 58.22 8 1/27/2019 20:33 Ewallet 4 373-73-7910 A Yangon Normal Male Sports and travel 86.31 7 2/8/2019 10:37 Ewallet ... ... ... ... ... ... ... ... ... ... ... ... 995 233-67-5758 C Naypyitaw Normal Male Health and beauty 40.35 1 1/29/2019 13:46 Ewallet 996 303-96-2227 B Mandalay Normal Female Home and lifestyle 97.38 10 3/2/2019 17:16 Ewallet 997 727-02-1313 A Yangon Member Male Food and beverages 31.84 1 2/9/2019 13:22 Cash 998 347-56-2442 A Yangon Normal Male Home and lifestyle 65.82 1 2/22/2019 15:33 Cash 999 849-09-3807 A Yangon Member Female Fashion accessories 88.34 7 2/18/2019 13:28 Cash 1000 rows × 11 columns &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-50d48947-61ce-44e9-b68e-d829efe5c1c6 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-50d48947-61ce-44e9-b68e-d829efe5c1c6'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 결측치가 있는지 파악 1sales.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 1000 entries, 0 to 999 Data columns (total 11 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Invoice ID 1000 non-null object 1 Branch 1000 non-null object 2 City 1000 non-null object 3 Customer type 1000 non-null object 4 Gender 1000 non-null object 5 Product line 1000 non-null object 6 Unit price 1000 non-null float64 7 Quantity 1000 non-null int64 8 Date 1000 non-null object 9 Time 1000 non-null object 10 Payment 1000 non-null object dtypes: float64(1), int64(1), object(9) memory usage: 86.1+ KB Group by == 집계함수를 배운다. 데이터 분석 1sales[&quot;City&quot;].value_counts() Yangon 340 Mandalay 332 Naypyitaw 328 Name: City, dtype: int64 groupby 적용 1sales.groupby(&quot;City&quot;)[&quot;Quantity&quot;].sum() City Mandalay 1820 Naypyitaw 1831 Yangon 1859 Name: Quantity, dtype: int64 groupby 다중 조건으로 적용 1sales.groupby([&quot;City&quot;, &quot;Customer type&quot;])[&quot;Quantity&quot;].sum() City Customer type Mandalay Member 924 Normal 896 Naypyitaw Member 897 Normal 934 Yangon Member 964 Normal 895 Name: Quantity, dtype: int64 1print(type(sales.groupby([&quot;City&quot;, &quot;Customer type&quot;])[&quot;Quantity&quot;].sum())) &lt;class 'pandas.core.series.Series'&gt; 1sales.groupby([&quot;City&quot;, &quot;Customer type&quot;])[&quot;Quantity&quot;].agg([&quot;sum&quot;,&quot;mean&quot;]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } sum mean City Customer type Mandalay Member 924 5.600000 Normal 896 5.365269 Naypyitaw Member 897 5.307692 Normal 934 5.874214 Yangon Member 964 5.772455 Normal 895 5.173410 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-32446840-9e52-42c8-9421-ee0c915979b8 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-32446840-9e52-42c8-9421-ee0c915979b8'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1print(type(sales.groupby([&quot;City&quot;, &quot;Customer type&quot;])[&quot;Quantity&quot;].agg([&quot;sum&quot;,&quot;mean&quot;]))) &lt;class 'pandas.core.frame.DataFrame'&gt; 1sales.groupby([&quot;City&quot;, &quot;Customer type&quot;], as_index=False)[&quot;Quantity&quot;].agg([&quot;sum&quot;,&quot;mean&quot;]).reset_index &lt;bound method DataFrame.reset_index of sum mean City Customer type Mandalay Member 924 5.600000 Normal 896 5.365269 Naypyitaw Member 897 5.307692 Normal 934 5.874214 Yangon Member 964 5.772455 Normal 895 5.173410&gt; 결측치 다루기결측치 데이터 생성12345678910import pandas as pdimport numpy as npdict_01 = { &quot;Score_A&quot;: [80, 90, np.nan, 80], &quot;Score_B&quot;: [30, 45, np.nan, np.nan], &quot;Score_C&quot;: [np.nan, 50, 80, 90]}df = pd.DataFrame(dict_01)df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Score_A Score_B Score_C 0 80.0 30.0 NaN 1 90.0 45.0 50.0 2 NaN NaN 80.0 3 80.0 NaN 90.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-14a5b830-837e-45fa-b9a1-4bebee9a75ed button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-14a5b830-837e-45fa-b9a1-4bebee9a75ed'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df.isnull().sum() # 데이터 타입 : Series Score_A 1 Score_B 2 Score_C 1 dtype: int64 12# fillna() : na를 채움.df.fillna(0) # fill: 채우다 ==&gt; NaN을 0으로 채움. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Score_A Score_B Score_C 0 80.0 30.0 0.0 1 90.0 45.0 50.0 2 0.0 0.0 80.0 3 80.0 0.0 90.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-62bcc06f-f400-4044-99f5-1494e7410213 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-62bcc06f-f400-4044-99f5-1494e7410213'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df.fillna(method=&quot;pad&quot;) # 위에 있는 데이터를 가져오는 방법 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Score_A Score_B Score_C 0 80.0 30.0 NaN 1 90.0 45.0 50.0 2 90.0 45.0 80.0 3 80.0 45.0 90.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-646f26f3-1ec1-4ad6-9785-1bc0ac89aef9 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-646f26f3-1ec1-4ad6-9785-1bc0ac89aef9'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1234567dict_01 = { &quot;성별&quot;: [&quot;남자&quot;, &quot;여자&quot;, np.nan, &quot;남자&quot;], &quot;Salary&quot;: [30, 45, 90, 70]}df = pd.DataFrame(dict_01)df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 성별 Salary 0 남자 30 1 여자 45 2 NaN 90 3 남자 70 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-42dee5c1-8082-4569-b11d-10055ee62263 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-42dee5c1-8082-4569-b11d-10055ee62263'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df[&quot;성별&quot;].fillna(&quot;성별 없음&quot;) 0 남자 1 여자 2 성별 없음 3 남자 Name: 성별, dtype: object 결측치 –&gt; 문자열 타입이랑/ 숫자 타입이랑 접근 방법이 다름.–&gt; 문자열 (빈도 –&gt; 가장 많이 나타나는 문자열 넣어주기!(최빈값))–&gt; 숫자열 (평균, 최대, 최소, 중간, 0, 기타 등등…) 12345678910111213import pandas as pdimport numpy as npprint(pd.__version__)print(np.__version__)dict_01 = { &quot;Score_A&quot;: [80, 90, np.nan, 80], &quot;Score_B&quot;: [30, 45, np.nan, 60], &quot;Score_C&quot;: [np.nan, 50, 80, 90], &quot;Score_D&quot;: [50, 30, 80, 60]}df = pd.DataFrame(dict_01)df 1.3.5 1.21.5 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Score_A Score_B Score_C Score_D 0 80.0 30.0 NaN 50 1 90.0 45.0 50.0 30 2 NaN NaN 80.0 80 3 80.0 60.0 90.0 60 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-d4b1192a-4329-4caf-89ff-e4a25fbc7b87 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-d4b1192a-4329-4caf-89ff-e4a25fbc7b87'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df.dropna(axis = 0) # na 데이터를 drop한다. axis=0(행) 기준으로 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Score_A Score_B Score_C Score_D 1 90.0 45.0 50.0 30 3 80.0 60.0 90.0 60 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-9e9fb79c-c188-48f1-b0c6-5a48971df6d9 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-9e9fb79c-c188-48f1-b0c6-5a48971df6d9'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 이상치1sales .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Invoice ID Branch City Customer type Gender Product line Unit price Quantity Date Time Payment 0 750-67-8428 A Yangon Member Female Health and beauty 74.69 7 1/5/2019 13:08 Ewallet 1 226-31-3081 C Naypyitaw Normal Female Electronic accessories 15.28 5 3/8/2019 10:29 Cash 2 631-41-3108 A Yangon Normal Male Home and lifestyle 46.33 7 3/3/2019 13:23 Credit card 3 123-19-1176 A Yangon Member Male Health and beauty 58.22 8 1/27/2019 20:33 Ewallet 4 373-73-7910 A Yangon Normal Male Sports and travel 86.31 7 2/8/2019 10:37 Ewallet ... ... ... ... ... ... ... ... ... ... ... ... 995 233-67-5758 C Naypyitaw Normal Male Health and beauty 40.35 1 1/29/2019 13:46 Ewallet 996 303-96-2227 B Mandalay Normal Female Home and lifestyle 97.38 10 3/2/2019 17:16 Ewallet 997 727-02-1313 A Yangon Member Male Food and beverages 31.84 1 2/9/2019 13:22 Cash 998 347-56-2442 A Yangon Normal Male Home and lifestyle 65.82 1 2/22/2019 15:33 Cash 999 849-09-3807 A Yangon Member Female Fashion accessories 88.34 7 2/18/2019 13:28 Cash 1000 rows × 11 columns &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-2ce50727-41a8-45a1-b73d-bbc238009252 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-2ce50727-41a8-45a1-b73d-bbc238009252'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 일반적인 공식 IQR - 박스플롯 - 사분위수 Q0(0%), Q1(25%), Q2(50%), Q3(75%), Q4(100%) 이상치의 하한 경계값: Q1 - (1.5 * (Q3 - Q1)) 이상치의 상한 경계값: Q3 + (1.5 * (Q3 - Q1)) 도메인(각 비즈니스 영역, 미래 일자리)에서 바라보는 이상치 기준(관습) 123sales[[&quot;Unit price&quot;]].describe() # 최소값 10.08, 최대값 99.96# print(type(sales[[&quot;Unit price&quot;]].describe())) ## DataFrame# print(type(sales[&quot;Unit price&quot;].describe())) ## Series .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Unit price count 1000.000000 mean 55.672130 std 26.494628 min 10.080000 25% 32.875000 50% 55.230000 75% 77.935000 max 99.960000 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-31840d4d-5e2c-4390-b26a-f53bf8db1e75 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-31840d4d-5e2c-4390-b26a-f53bf8db1e75'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 12345678910Q1 = sales[&quot;Unit price&quot;].quantile(0.25) # quantile(0.25): 1사분위를 구하라.Q3 = sales[&quot;Unit price&quot;].quantile(0.75)#Q1보다 낮은 값을 이상치로 간주outliers_q1 = (sales[&quot;Unit price&quot;] &lt; Q1)# Q3볻 높은 값을 이상치로 간주outliers_q3 = (sales[&quot;Unit price&quot;] &gt; Q3)print(outliers_q1)print(outliers_q3) 0 False 1 True 2 False 3 False 4 False ... 995 False 996 False 997 True 998 False 999 False Name: Unit price, Length: 1000, dtype: bool 0 False 1 False 2 False 3 False 4 True ... 995 False 996 True 997 False 998 False 999 True Name: Unit price, Length: 1000, dtype: bool 1print(sales[&quot;Unit price&quot;][~(outliers_q1 | outliers_q3)]) 0 74.69 2 46.33 3 58.22 6 68.84 7 73.56 ... 991 76.60 992 58.03 994 60.95 995 40.35 998 65.82 Name: Unit price, Length: 500, dtype: float64","link":"/2022/03/24/0324_Pandas_Tutorial_02/"},{"title":"시각화 연습1","text":"라이브러리 불러오기1234import matplotlibimport seaborn as snsprint(matplotlib.__version__)print(sns.__version__) 3.2.2 0.11.2 시각화 그려보기123456789101112131415import matplotlib.pyplot as pltdates = [ '2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08', '2021-01-09', '2021-01-10']min_temperature = [20.7, 17.9, 18.8, 14.6, 15.8, 15.8, 15.8, 17.4, 21.8, 20.0]max_temperature = [34.7, 28.9, 31.8, 25.6, 28.8, 21.8, 22.8, 28.4, 30.8, 32.0]# 앞으로 아래와 같이 코드를 작성하면 됩니다.fig, ax = plt.subplots(nrows = 1, ncols = 1, figsize = (10, 6))ax.plot(dates, min_temperature, label = &quot;Min Temp.&quot;)ax.plot(dates, max_temperature, label = &quot;Max Temp.&quot;)ax.legend()plt.show() 주식 데이터 다운로드 받기1!pip install yfinance --upgrade --no-cache-dir Collecting yfinance Downloading yfinance-0.1.70-py2.py3-none-any.whl (26 kB) Requirement already satisfied: numpy&gt;=1.15 in /usr/local/lib/python3.7/dist-packages (from yfinance) (1.21.5) Requirement already satisfied: pandas&gt;=0.24.0 in /usr/local/lib/python3.7/dist-packages (from yfinance) (1.3.5) Collecting requests&gt;=2.26 Downloading requests-2.27.1-py2.py3-none-any.whl (63 kB) \u001b[K |████████████████████████████████| 63 kB 6.4 MB/s \u001b[?25hCollecting lxml&gt;=4.5.1 Downloading lxml-4.8.0-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.manylinux_2_24_x86_64.whl (6.4 MB) \u001b[K |████████████████████████████████| 6.4 MB 11.0 MB/s \u001b[?25hRequirement already satisfied: multitasking&gt;=0.0.7 in /usr/local/lib/python3.7/dist-packages (from yfinance) (0.0.10) Requirement already satisfied: pytz&gt;=2017.3 in /usr/local/lib/python3.7/dist-packages (from pandas&gt;=0.24.0-&gt;yfinance) (2018.9) Requirement already satisfied: python-dateutil&gt;=2.7.3 in /usr/local/lib/python3.7/dist-packages (from pandas&gt;=0.24.0-&gt;yfinance) (2.8.2) Requirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.7/dist-packages (from python-dateutil&gt;=2.7.3-&gt;pandas&gt;=0.24.0-&gt;yfinance) (1.15.0) Requirement already satisfied: certifi&gt;=2017.4.17 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.26-&gt;yfinance) (2021.10.8) Requirement already satisfied: urllib3&lt;1.27,&gt;=1.21.1 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.26-&gt;yfinance) (1.24.3) Requirement already satisfied: idna&lt;4,&gt;=2.5 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.26-&gt;yfinance) (2.10) Requirement already satisfied: charset-normalizer~=2.0.0 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.26-&gt;yfinance) (2.0.12) Installing collected packages: requests, lxml, yfinance Attempting uninstall: requests Found existing installation: requests 2.23.0 Uninstalling requests-2.23.0: Successfully uninstalled requests-2.23.0 Attempting uninstall: lxml Found existing installation: lxml 4.2.6 Uninstalling lxml-4.2.6: Successfully uninstalled lxml-4.2.6 \u001b[31mERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts. google-colab 1.0.0 requires requests~=2.23.0, but you have requests 2.27.1 which is incompatible. datascience 0.10.6 requires folium==0.2.1, but you have folium 0.8.3 which is incompatible.\u001b[0m Successfully installed lxml-4.8.0 requests-2.27.1 yfinance-0.1.70 12345import yfinance as yfdata = yf.download(&quot;AAPL&quot;, start= &quot;2019-08-01&quot;, end=&quot;2022-03-23&quot;)ts = data[&quot;Open&quot;]print(ts.head())print(type(ts)) [*********************100%***********************] 1 of 1 completed Date 2019-08-01 53.474998 2019-08-02 51.382500 2019-08-05 49.497501 2019-08-06 49.077499 2019-08-07 48.852501 Name: Open, dtype: float64 &lt;class 'pandas.core.series.Series'&gt; pyplot 형태123456import matplotlib.pyplot as pltplt.plot(ts)plt.title(&quot;Stokc Market of AAPL&quot;)plt.xlabel(&quot;Date&quot;)plt.ylabel(&quot;Open Price&quot;)plt.show() 객체지향으로 그리기123456789# 필수 fig ax = plt.subplots()import matplotlib.pyplot as pltfig, ax = plt.subplots()ax.plot(ts)ax.set_title(&quot;Stokc Market of AAPL&quot;)ax.set_xlabel(&quot;Date&quot;)ax.set_ylabel(&quot;Open Price&quot;)plt.show() 막대 그래프1234567891011121314151617181920212223242526import matplotlib.pyplot as pltimport numpy as npimport calendarmonth_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]sold_list = [300, 400, 550, 900, 600, 960, 900, 910, 800, 700, 550, 450]# print(month_list)# print(sold_list)fig, ax= plt.subplots(figsize = (10, 6))barplots = ax.bar(month_list, sold_list)print(&quot;barplots: &quot;, barplots)for plot in barplots: print(plot) # print(plot.get_height()) # print(plot.get_x()) # print(plot.get_y()) # print(plot.get_width()) height = plot.get_height() ax.text(plot.get_x() + plot.get_width()/2, height, height, ha = &quot;center&quot;, va = &quot;bottom&quot;)plt.xticks(month_list, calendar.month_name[1:13])plt.show() barplots: &lt;BarContainer object of 12 artists&gt; Rectangle(xy=(0.6, 0), width=0.8, height=300, angle=0) Rectangle(xy=(1.6, 0), width=0.8, height=400, angle=0) Rectangle(xy=(2.6, 0), width=0.8, height=550, angle=0) Rectangle(xy=(3.6, 0), width=0.8, height=900, angle=0) Rectangle(xy=(4.6, 0), width=0.8, height=600, angle=0) Rectangle(xy=(5.6, 0), width=0.8, height=960, angle=0) Rectangle(xy=(6.6, 0), width=0.8, height=900, angle=0) Rectangle(xy=(7.6, 0), width=0.8, height=910, angle=0) Rectangle(xy=(8.6, 0), width=0.8, height=800, angle=0) Rectangle(xy=(9.6, 0), width=0.8, height=700, angle=0) Rectangle(xy=(10.6, 0), width=0.8, height=550, angle=0) Rectangle(xy=(11.6, 0), width=0.8, height=450, angle=0) 12345678910111213from IPython.core.pylabtools import figsizeimport seaborn as snstips = sns.load_dataset(&quot;tips&quot;)x= tips[&quot;total_bill&quot;]y= tips[&quot;tip&quot;]# 산점도fig, ax= plt.subplots(figsize= (10, 6)) # figsize=(가로길이, 세로길이)ax.scatter(x, y)ax.set_xlabel(&quot;Total_Bill&quot;)ax.set_ylabel(&quot;Tip&quot;)plt.show() 12345678910111213141516label, data = tips.groupby(&quot;sex&quot;)#print(label)#print(data)tips[&quot;sex_color&quot;] = tips[&quot;sex&quot;].map({&quot;Male&quot;: &quot;#2521F6&quot;, &quot;Female&quot;: &quot;#EB4036&quot;})# print(tips.head())fig, ax = plt.subplots(figsize= (10, 6))for label, data in tips.groupby(&quot;sex&quot;): # print(label) # print(data) ax.scatter(data[&quot;total_bill&quot;], data[&quot;tip&quot;], label = label, color = data[&quot;sex_color&quot;], alpha = 0.5) ax.set_xlabel(&quot;Total_Bill&quot;) ax.set_ylabel(&quot;Tip&quot;)ax.legend() # 범례plt.show() seaborn12345678import matplotlib.pyplot as pltimport seaborn as snstips = sns.load_dataset(&quot;tips&quot;)fig, ax = plt.subplots(figsize=(10, 6))sns.scatterplot(x= &quot;total_bill&quot;, y =&quot;tip&quot;, hue = &quot;sex&quot;, data = tips)plt.show() 12345678# 두개의 그래프를 동시에 표현fig, ax = plt.subplots(nrows= 1 , ncols=2, figsize=(15, 5))sns.regplot(x= &quot;total_bill&quot;, y =&quot;tip&quot;, data = tips, ax = ax[1], fit_reg = True)ax[1].set_title(&quot;with linear regression line&quot;)sns.regplot(x= &quot;total_bill&quot;, y =&quot;tip&quot;, data = tips, ax = ax[0], fit_reg = False) # ax = ax[0] 선 있음ax[0].set_title(&quot;without linear regression line&quot;)plt.show() 막대 그래프 그리기 seaborn 방식 12sns.countplot(x= &quot;day&quot;, data = tips)plt.show() 123print(tips[&quot;day&quot;].value_counts().index)print(tips[&quot;day&quot;].value_counts().values)print(tips[&quot;day&quot;].value_counts(ascending= True)) # 오름차순 CategoricalIndex(['Sat', 'Sun', 'Thur', 'Fri'], categories=['Thur', 'Fri', 'Sat', 'Sun'], ordered=False, dtype='category') [87 76 62 19] Fri 19 Thur 62 Sun 76 Sat 87 Name: day, dtype: int64 12345678910fig, ax = plt.subplots()ax = sns.countplot(x = &quot;day&quot;, data= tips, order= tips[&quot;day&quot;].value_counts().index)for plot in ax.patches: # matplotlib # print(plot) height = plot.get_height() ax.text(plot.get_x() + plot.get_width()/2, height, height, ha = &quot;center&quot;, va = &quot;bottom&quot;)ax.set_ylim(-5, 100) # y축을 100까지 확장plt.show() 어려운 시각화 그래프1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import matplotlib.pyplot as pltimport seaborn as snsimport numpy as npfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator, FuncFormatter) # ticker : 증권 시세 표시기def major_formatter(x, pos): return &quot;%.2f$&quot; % xformatter = FuncFormatter(major_formatter)tips = sns.load_dataset(&quot;tips&quot;)fig, ax = plt.subplots(nrows = 1, ncols= 2, figsize= (16, 6))ax0 = sns.barplot(x= &quot;day&quot;, y= &quot;total_bill&quot;, data= tips, ci = None, color= &quot;lightgray&quot;, alpha= 0.85, zorder= 2, ax= ax[0])# groupbygroup_mean = tips.groupby([&quot;day&quot;])[&quot;total_bill&quot;].agg(&quot;mean&quot;)# print(group_mean)h_day = group_mean.sort_values(ascending= False).index[0]# print(h_day)h_mean= group_mean.sort_values(ascending= False).values[0]# print(h_mean)# text 추가for plot in ax0.patches: height = np.round(plot.get_height(), 2) # print(height) # Default fontweight = &quot;normal&quot; color = &quot;k&quot; if h_mean == height: fontweight = &quot;bold&quot; color = &quot;darkred&quot; plot.set_facecolor(color) plot.set_edgecolor(&quot;black&quot;) ax0.text(plot.get_x()+ plot.get_width()/2., height + 1, height, ha = &quot;center&quot;, size= 12, fontweight= fontweight, color = color)# 축 수정ax0.set_ylim(-3,30)ax0.set_title(&quot;Bar Graph&quot;, size= 16)# spines 제거ax0.spines[&quot;top&quot;].set_visible(False)ax0.spines[&quot;left&quot;].set_position((&quot;outward&quot;, 20))ax0.spines[&quot;left&quot;].set_visible(False)ax0.spines[&quot;right&quot;].set_visible(False)ax0.yaxis.set_major_locator(MultipleLocator(10))ax0.yaxis.set_major_formatter(formatter)ax0.yaxis.set_minor_locator(MultipleLocator(5))ax0.set_ylabel(&quot;Avg. Total Bill($)&quot;, fontsize=14)ax0.grid(axis=&quot;y&quot;, which=&quot;major&quot;, color= &quot;lightgray&quot;)ax0.grid(axis=&quot;y&quot;, which=&quot;minor&quot;, ls= &quot;:&quot;)ax0.set_xlabel(&quot;Weekday&quot;, fontsize= 14)for xtick in ax0.get_xticklabels(): # print(xtick) if xtick.get_text() == h_day: xtick.set_color(&quot;darkred&quot;) xtick.set_fontweight(&quot;demibold&quot;)ax0.set_xticklabels([&quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;], size = 12)plt.show()","link":"/2022/03/24/0324_Visualization_Tutorial_01/"},{"title":"아나콘다 설치","text":"아나콘다 설치웹사이트 주소: https://www.**anaconda**.com/products/individual-b#Downloads 깃허브에서 R_edu 프로젝트를 다운로드 받는다. 1$ git clone 주소 - 다운로드 받는다.","link":"/2022/03/10/0318_anaconda_install.md/"},{"title":"Corab_intro","text":"Colab이란? Colaboratory&amp;#40;줄여서 ‘Colab’이라고 함&amp;#41;을 통해 브라우저 내에서 Python 스크립트를 작성하고 실행할 수 있습니다. 구성이 필요하지 않음 GPU 무료 액세스 간편한 공유 학생이든, 데이터 과학자든, AI 연구원이든 Colab으로 업무를 더욱 간편하게 처리할 수 있습니다. Colab 소개 영상에서 자세한 내용을 확인하거나 아래에서 시작해 보세요. 시작하기지금 읽고 계신 문서는 정적 웹페이지가 아니라 코드를 작성하고 실행할 수 있는 대화형 환경인 Colab 메모장입니다. 예를 들어 다음은 값을 계산하여 변수로 저장하고 결과를 출력하는 간단한 Python 스크립트가 포함된 코드 셀입니다. 12seconds_in_a_day = 24 * 60 * 60seconds_in_a_day 86400 위 셀의 코드를 실행하려면 셀을 클릭하여 선택한 후 코드 왼쪽의 실행 버튼을 누르거나 단축키 ‘Command/Ctrl+Enter’를 사용하세요. 셀을 클릭하면 코드 수정을 바로 시작할 수 있습니다. 특정 셀에서 정의한 변수를 나중에 다른 셀에서 사용할 수 있습니다. 12seconds_in_a_week = 7 * seconds_in_a_dayseconds_in_a_week 604800 Colab 메모장을 사용하면 실행 코드와 서식 있는 텍스트를 이미지, HTML, LaTeX 등과 함께 하나의 문서로 통합할 수 있습니다. Colab 메모장을 만들면 Google Drive 계정에 저장됩니다. Colab 메모장을 간편하게 공유하여 동료나 친구들이 댓글을 달거나 수정하도록 할 수 있습니다. 자세히 알아보려면 Colab 개요를 참조하세요. 새 Colab 메모장을 만들려면 위의 파일 메뉴를 사용하거나 다음 링크로 이동하세요. 새 Colab 메모장 만들기 Colab 메모장은 Colab에서 호스팅하는 Jupyter 메모장입니다. Jupyter 프로젝트에 관해 자세히 알아보려면 jupyter.org를 참조하세요. 데이터 과학Colab을 통해 인기 있는 Python 라이브러리를 최대한 활용하여 데이터를 분석하고 시각화할 수 있습니다. 아래 코드 셀에서는 Numpy를 사용하여 임의의 데이터를 생성하고 매트플롯립으로 이를 시각화합니다. 셀을 클릭하면 코드 수정을 바로 시작할 수 있습니다. 1234567891011import numpy as npfrom matplotlib import pyplot as pltys = 200 + np.random.randn(100)x = [x for x in range(len(ys))]plt.plot(x, ys, '-')plt.fill_between(x, ys, 195, where=(ys &gt; 195), facecolor='g', alpha=0.6)plt.title(&quot;Sample Visualization&quot;)plt.show() Google Drive 계정에서 스프레드시트를 비롯한 데이터를 Colab 메모장으로 가져오거나 GitHub 등의 여러 다른 소스에서 데이터를 가져올 수 있습니다. Colab을 데이터 과학에 활용하는 방법과 데이터 가져오기에 관해 자세히 알아보려면 데이터 사용하기 아래 링크를 참조하세요. 머신러닝Colab을 사용하면 코드 몇 줄만으로 이미지 데이터세트를 가져오고, 이 데이터세트로 이미지 분류기를 학습시키며, 모델을 평가할 수 있습니다. Colab 메모장은 Google 클라우드 서버에서 코드를 실행하므로 사용 중인 컴퓨터의 성능과 관계없이 GPU 및 TPU를 포함한 Google 하드웨어의 성능을 활용할 수 있습니다. 브라우저만 있으면 사용 가능합니다. Colab은 다음과 같은 분야의 머신러닝 커뮤니티에서 널리 쓰이고 있습니다. TensorFlow 시작하기 신경망 개발 및 학습시키기 TPU로 실험하기 AI 연구 보급하기 튜토리얼 만들기 머신러닝 적용 사례를 보여 주는 Colab 메모장 샘플을 확인하려면 아래 머신러닝 예시를 참조하세요. 추가 리소스Colab에서 메모장 사용하기 Colaboratory 개요 Markdown 가이드 라이브러리 가져오기 및 종속 항목 설치하기 GitHub에서 노트 저장 및 로드하기 대화형 양식 대화형 위젯 Colab의 TensorFlow 2 데이터로 작업하기 데이터 로드: 드라이브, 스프레드시트, Google Cloud Storage 차트: 데이터 시각화하기 BigQuery 시작하기 머신러닝 단기집중과정다음은 Google 온라인 머신러닝 과정에서 가져온 일부 메모장입니다. 전체 과정 웹사이트에서 자세한 내용을 확인하세요. Pandas DataFrame 소개 합성 데이터를 사용하는 tf.keras 선형 회귀 가속 하드웨어 사용하기 GPU를 사용한 TensorFlow TPU를 사용한 TensorFlow 추천 예시 NeMo Voice Swap: Nvidia의 NeMo 대화형 AI 툴킷을 사용하여 오디오 파일의 음성을 컴퓨터에서 생성된 음성으로 변환하세요. 이미지 분류기 재훈련: 사전에 훈련된 이미지 분류기를 기반으로 꽃을 분류하기 위한 Keras 모델을 구축합니다. 텍스트 분류: IMDB 영화 리뷰를 긍정적인 리뷰 또는 부정적인 리뷰로 분류합니다. 스타일 트랜스퍼: 딥 러닝을 사용하여 이미지 간에 스타일을 전이시킵니다. Multilingual Universal Sentence Encoder Q&amp;A: 머신러닝 모델을 사용하여 SQuAD 데이터 세트의 질문에 답변합니다. 동영상 보간 유형: 동영상에서 첫 프레임과 마지막 프레임 사이에 발생한 내용을 예측합니다.","link":"/2022/03/17/0319_Colab_Intro/"},{"title":"마크다운 연습","text":"4. 데이터 전처리1) 분석 파일을 R로 불러오기1library(dplyr) 12## ## 다음의 패키지를 부착합니다: 'dplyr' 123## The following objects are masked from 'package:stats':## ## filter, lag 123## The following objects are masked from 'package:base':## ## intersect, setdiff, setequal, union 1library(ggplot2) 메뉴얼 : https://bookdown.org/yihui/rmarkdown/ 2) 시각화 코드 데이터를 불러옵니다 12ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point()","link":"/2022/03/14/0314_report2/"},{"title":"머신러닝 교재 실습 01","text":"데이터 불러오기 kaggle 데이터를 구글drive에 저장 후 연동해서 불러옴 123456789101112import pandas as pdimport numpy as npfrom google.colab import drivedrive.mount(&quot;/content/drive&quot;)DATA = &quot;/content/drive/MyDrive/Colab Notebooks/data/Fish.csv&quot;fish = pd.read_csv(DATA)print(fish)# Series01 = fish.iloc[:,0]print(fish[&quot;Species&quot;].value_counts())print(fish.describe()) Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(&quot;/content/drive&quot;, force_remount=True). Species Weight Length1 Length2 Length3 Height Width 0 Bream 242.0 23.2 25.4 30.0 11.5200 4.0200 1 Bream 290.0 24.0 26.3 31.2 12.4800 4.3056 2 Bream 340.0 23.9 26.5 31.1 12.3778 4.6961 3 Bream 363.0 26.3 29.0 33.5 12.7300 4.4555 4 Bream 430.0 26.5 29.0 34.0 12.4440 5.1340 .. ... ... ... ... ... ... ... 154 Smelt 12.2 11.5 12.2 13.4 2.0904 1.3936 155 Smelt 13.4 11.7 12.4 13.5 2.4300 1.2690 156 Smelt 12.2 12.1 13.0 13.8 2.2770 1.2558 157 Smelt 19.7 13.2 14.3 15.2 2.8728 2.0672 158 Smelt 19.9 13.8 15.0 16.2 2.9322 1.8792 [159 rows x 7 columns] Perch 56 Bream 35 Roach 20 Pike 17 Smelt 14 Parkki 11 Whitefish 6 Name: Species, dtype: int64 Weight Length1 Length2 Length3 Height Width count 159.000000 159.000000 159.000000 159.000000 159.000000 159.000000 mean 398.326415 26.247170 28.415723 31.227044 8.970994 4.417486 std 357.978317 9.996441 10.716328 11.610246 4.286208 1.685804 min 0.000000 7.500000 8.400000 8.800000 1.728400 1.047600 25% 120.000000 19.050000 21.000000 23.150000 5.944800 3.385650 50% 273.000000 25.200000 27.300000 29.400000 7.786000 4.248500 75% 650.000000 32.700000 35.500000 39.650000 12.365900 5.584500 max 1650.000000 59.000000 63.400000 68.000000 18.957000 8.142000 도미와 빙어 분류하기123456789bream_length = [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 31.0, 31.0, 31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5, 34.0, 34.0, 34.5, 35.0, 35.0, 35.0, 35.0, 36.0, 36.0, 37.0, 38.5, 38.5, 39.5, 41.0, 41.0]bream_weight = [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0, 450.0, 500.0, 475.0, 500.0, 500.0, 340.0, 600.0, 600.0, 700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0, 700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0, 925.0, 975.0, 950.0]print(bream_length)print(bream_weight) [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 31.0, 31.0, 31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5, 34.0, 34.0, 34.5, 35.0, 35.0, 35.0, 35.0, 36.0, 36.0, 37.0, 38.5, 38.5, 39.5, 41.0, 41.0] [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0, 450.0, 500.0, 475.0, 500.0, 500.0, 340.0, 600.0, 600.0, 700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0, 700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0, 925.0, 975.0, 950.0] 도미의 데이터를 산점도로 표현.12345import matplotlib.pyplot as pltplt.scatter(bream_length, bream_weight) # scatter() : 산점도plt.xlabel(&quot;weight&quot;)plt.ylabel(&quot;length&quot;)plt.show() 1234smelt_length = [9.8, 10.5, 10.6, 11.0, 11.2, 11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0]smelt_weight = [6.7, 7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9]print(smelt_length)print(smelt_weight) [9.8, 10.5, 10.6, 11.0, 11.2, 11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0] [6.7, 7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9] 빙어의 데이터를 산점도로 표현.12345import matplotlib.pyplot as pltplt.scatter(smelt_length, smelt_weight)plt.xlabel(&quot;weight&quot;)plt.ylabel(&quot;length&quot;)plt.show() 12length = bream_length + smelt_lengthweight = bream_weight + smelt_weight 123# print(type(length))fish_data = [[l,w]for l, w in zip(length, weight)]print(fish_data) [[25.4, 242.0], [26.3, 290.0], [26.5, 340.0], [29.0, 363.0], [29.0, 430.0], [29.7, 450.0], [29.7, 500.0], [30.0, 390.0], [30.0, 450.0], [30.7, 500.0], [31.0, 475.0], [31.0, 500.0], [31.5, 500.0], [32.0, 340.0], [32.0, 600.0], [32.0, 600.0], [33.0, 700.0], [33.0, 700.0], [33.5, 610.0], [33.5, 650.0], [34.0, 575.0], [34.0, 685.0], [34.5, 620.0], [35.0, 680.0], [35.0, 700.0], [35.0, 725.0], [35.0, 720.0], [36.0, 714.0], [36.0, 850.0], [37.0, 1000.0], [38.5, 920.0], [38.5, 955.0], [39.5, 925.0], [41.0, 975.0], [41.0, 950.0], [9.8, 6.7], [10.5, 7.5], [10.6, 7.0], [11.0, 9.7], [11.2, 9.8], [11.3, 8.7], [11.8, 10.0], [11.8, 9.9], [12.0, 9.8], [12.2, 12.2], [12.4, 13.4], [13.0, 12.2], [14.3, 19.7], [15.0, 19.9]] 123# 도미는 1, 빙어는 0으로 표현fish_target = [1] * 35 + [0] * 14print(fish_target) [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] 머신러닝 사이킷런 패키지 k-최근접 이웃 ( k- Nearest Neighbors) 123from sklearn.neighbors import KNeighborsClassifier# sklearn : 패키지 , # neighbors , KNeighborsClassifier : 클래스kn = KNeighborsClassifier() 123kn.fit(fish_data, fish_target) # fit() : 주어진 데이터로 알고리즘 훈련kn.score(fish_data, fish_target) # scroe() : 0~1 (&quot;kn이 맞춘 비율&quot;) 의 값을 반환함# 1은 모든 데이터를 맞췄다는 의미 1.0 12kn.predict([[30, 600]])## (30과 600)를 가진 데이터는 도미로 규정한 1이 출력됨을 볼 수 있음. array([1]) 123print(kn._fit_X)print(&quot; &quot;)print(kn._y) [[ 25.4 242. ] [ 26.3 290. ] [ 26.5 340. ] [ 29. 363. ] [ 29. 430. ] [ 29.7 450. ] [ 29.7 500. ] [ 30. 390. ] [ 30. 450. ] [ 30.7 500. ] [ 31. 475. ] [ 31. 500. ] [ 31.5 500. ] [ 32. 340. ] [ 32. 600. ] [ 32. 600. ] [ 33. 700. ] [ 33. 700. ] [ 33.5 610. ] [ 33.5 650. ] [ 34. 575. ] [ 34. 685. ] [ 34.5 620. ] [ 35. 680. ] [ 35. 700. ] [ 35. 725. ] [ 35. 720. ] [ 36. 714. ] [ 36. 850. ] [ 37. 1000. ] [ 38.5 920. ] [ 38.5 955. ] [ 39.5 925. ] [ 41. 975. ] [ 41. 950. ] [ 9.8 6.7] [ 10.5 7.5] [ 10.6 7. ] [ 11. 9.7] [ 11.2 9.8] [ 11.3 8.7] [ 11.8 10. ] [ 11.8 9.9] [ 12. 9.8] [ 12.2 12.2] [ 12.4 13.4] [ 13. 12.2] [ 14.3 19.7] [ 15. 19.9]] [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 12345# 참고 데이터를 49개로 한 kn49모델kn49 = KNeighborsClassifier(n_neighbors=49)kn49.fit(fish_data, fish_target)kn49.score(fish_data, fish_target)## 49개의 데이터중 도미인 35개만 맞춘 결과를 보여줌 0.7142857142857143 12345# 참고 데이터를 5개로 한 kn49모델kn50 = KNeighborsClassifier(n_neighbors=5)kn50.fit(fish_data, fish_target)kn50.score(fish_data, fish_target)## n_neighbors 의 데이터가 17 이하일때까지 1의 결과를 출력함. 1.0 마무리 정리 사이킷런 ( scikit-learn ) 패키지 KNeighborsClassfier() : k-최근접 이웃 분류 모델을 만듬, n_neighbors 매개변수로 이웃의 개수를 지정함. [default : 5] fit() : 사이킷런을 훈련 할 때 사용함, 처음 두 매개변수로 훈련에 사용 할특성과 정답데이터를 전달 predict() : 사이킷런 모델을 훈련하고 예측할 때 사용, 특성 데이터만 매개변수로 받음. score(): 훈련된 사이킷런 모델의 성능을 측정","link":"/2022/03/26/0326_Machine_Learning/"},{"title":"k-최근접 이웃 회귀 01","text":"k-최근접 이웃 회귀(Regression) 중요도: 하 (그냥 넘어갈것) 데이터 준비12345678910111213141516171819import numpy as npperch_length = np.array( [8.4, 13.7, 15.0, 16.2, 17.4, 18.0, 18.7, 19.0, 19.6, 20.0, 21.0, 21.0, 21.0, 21.3, 22.0, 22.0, 22.0, 22.0, 22.0, 22.5, 22.5, 22.7, 23.0, 23.5, 24.0, 24.0, 24.6, 25.0, 25.6, 26.5, 27.3, 27.5, 27.5, 27.5, 28.0, 28.7, 30.0, 32.8, 34.5, 35.0, 36.5, 36.0, 37.0, 37.0, 39.0, 39.0, 39.0, 40.0, 40.0, 40.0, 40.0, 42.0, 43.0, 43.0, 43.5, 44.0] )perch_weight = np.array( [5.9, 32.0, 40.0, 51.5, 70.0, 100.0, 78.0, 80.0, 85.0, 85.0, 110.0, 115.0, 125.0, 130.0, 120.0, 120.0, 130.0, 135.0, 110.0, 130.0, 150.0, 145.0, 150.0, 170.0, 225.0, 145.0, 188.0, 180.0, 197.0, 218.0, 300.0, 260.0, 265.0, 250.0, 250.0, 300.0, 320.0, 514.0, 556.0, 840.0, 685.0, 700.0, 700.0, 690.0, 900.0, 650.0, 820.0, 850.0, 900.0, 1015.0, 820.0, 1100.0, 1000.0, 1100.0, 1000.0, 1000.0] ) 시각화 객체지향으로 변경할것 fig, ax = plt.subplots() ax.scatter(Xdata, Ydata) 1234567import matplotlib.pyplot as pltfig, ax = plt.subplots()ax.scatter(perch_length, perch_weight)ax.set_xlabel(&quot;length&quot;)ax.set_ylabel(&quot;weight&quot;)plt.show() 훈련 데이터 테스트 데이터셋 분리12345from sklearn.model_selection import train_test_splittrain_input, test_input, train_target, test_target = train_test_split( perch_length, perch_weight, random_state = 42)train_input.shape, test_input.shape, train_target.shape, test_target.shape ((42,), (14,), (42,), (14,)) reshape() 사용하여 2차원 배열로 바꿈 1234train_input= train_input.reshape(-1, 1)test_input= test_input.reshape(-1, 1)print(train_input.shape, test_input.shape) (42, 1) (14, 1) 결정계수 R^2 모델이 얼마만큼 정확한가 99.3% 절댓값은 아님 ==&gt; 상대적인 값임 12345678910from sklearn.neighbors import KNeighborsRegressor# 클래스 불러오기knr = KNeighborsRegressor()# 모형학습knr.fit(train_input, train_target)# 테스트 점수 확인knr.score(test_input, test_target) 0.992809406101064 MAE 타깃과 얘측의 절댓값 오차를 평균하여 반환 12345from sklearn.metrics import mean_absolute_error# 예측 데이터 만들기test_prediction = knr.predict(test_input)test_prediction array([ 60. , 79.6, 248. , 122. , 136. , 847. , 311.4, 183.4, 847. , 113. , 1010. , 60. , 248. , 248. ]) 123mae = mean_absolute_error(test_target, test_prediction)print(mae)# 평균적으로 19g정도 다름 19.157142857142862 과대적합 vs 과소적합 공통점: 머신러닝 모형이 실제 테스트 시 잘 예측을 못함. 차이점: 과대적합: 훈련데이터에는 예측 잘함, 테스트데이터에서는 예측을 잘 못함. 처리하기 곤란. 과소적합: 훈련데이터에서는 예측을 못하고, 테스트데이터에서는 예측을 잘하거나 or 둘 다 예측을 잘 못함. 데이터양이 적거나, 모델을 너무 간단하게 만듬 12# 훈련 데이터 점수 확인knr.score(train_input, train_target) # 0.97정도 나옴 0.9698823289099254 1234567# Default 5를 3으로 변경# 머신러닝 모형을 변경knr.n_neighbors = 3# 모델을 다시 훈련knr.fit(train_input, train_target)print(knr.score(train_input, train_target)) # 0.98정도 나옴 0.9804899950518966 1print(knr.score(test_input, test_target)) # 0.97 0.9746459963987609 MAE구하기 12345# 예측 데이터 만들기test_prediction = knr.predict(test_input)mae = mean_absolute_error(test_target, test_prediction)# test_predictionprint(mae) # 35.4정도 나옴 35.42380952380951 1234567# 머신러닝 모형을 변경knr.n_neighbors = 7# 모델을 다시 훈련knr.fit(train_input, train_target)print(knr.score(train_input, train_target)) # print(knr.score(test_input, test_target)) # 0.9761170732051527 0.9781383949643516 1234# 예측 데이터 만들기test_prediction = knr.predict(test_input)mae = mean_absolute_error(test_target, test_prediction)print(mae) # 32.512244897959185 결론 k그룹을 5로 했을때 R2는 0.98 mae는 19정도 였음 k그룹을 3으로 했을때 R2는 0.97 mae는 35.4정도 였음 k그룹을 7로 했을때 R2는 0.98 mae는 32.5정도 였음 내맘대로 코딩 R^2와 mae의 값을 찾기 123456789101112TEST = np.arange(1, 10)# float R0 = 0for i in TEST: knr.n_neighbors = i knr.fit(train_input, train_target) print(knr.score(test_input, test_target)) R2= knr.score(test_input, test_target) test_prediction = knr.predict(test_input) mae = mean_absolute_error(test_target, test_prediction) print(mae, i) 0.991309195814175 22.685714285714287 1 0.9725010241788556 35.292857142857144 2 0.9746459963987609 35.42380952380951 3 0.9840231023848637 28.38214285714286 4 0.992809406101064 19.157142857142862 5 0.9855001139899048 28.388095238095243 6 0.9781383949643516 32.512244897959185 7 0.9780541148735824 34.88214285714286 8 0.9692647749722698 43.987301587301594 9 마무리 정리 키워드 회귀: 임의의 수치를 예측하는 문제 k-최근접 이웃 회귀: 가장 가까운 이웃 샘플을 찾고 그 샘플들의 평균으로 예측 결정계수(R²)대표적인 회귀문제의 성능 측정 도구. 1에 가까울수록 좋고 0에 가까울수록 나쁜 모델임 과대적합: 훈련데이터에는 예측 잘함, 테스트데이터에서는 예측을 잘 못함 과소적합: 훈련데이터에서는 예측을 못하고, 테스트데이터에서는 예측을 잘하거나 or 둘 다 예측을 잘 못함 Scikit-learn 패키지 KNeighborsRegressor: k-최근접 이웃 회귀 모델을 만드는 사이킷런 클래스. n_neighbors 매개변수를 지정함. [default: 5] mean_absolute_error(A, B): 회귀모델의 평균 절댓값 오차를 계산. A는 타깃, B는 예측값. 타깃과 예측을 뺀 값을 제곱한 다음 전체 샘플에 대해 평균한 값을 반환함. Numpy 패키지 reshape(): 배열의 크기를 바꾸는 메서드. -1은 적용 가능한 정수를 자동으로 찾아주는 역할","link":"/2022/03/28/0328_Regression_01/"},{"title":"k-최근접 이웃 회귀 02","text":"선형회귀데이터 불러오기12345678910111213141516171819import numpy as npperch_length = np.array( [8.4, 13.7, 15.0, 16.2, 17.4, 18.0, 18.7, 19.0, 19.6, 20.0, 21.0, 21.0, 21.0, 21.3, 22.0, 22.0, 22.0, 22.0, 22.0, 22.5, 22.5, 22.7, 23.0, 23.5, 24.0, 24.0, 24.6, 25.0, 25.6, 26.5, 27.3, 27.5, 27.5, 27.5, 28.0, 28.7, 30.0, 32.8, 34.5, 35.0, 36.5, 36.0, 37.0, 37.0, 39.0, 39.0, 39.0, 40.0, 40.0, 40.0, 40.0, 42.0, 43.0, 43.0, 43.5, 44.0] )perch_weight = np.array( [5.9, 32.0, 40.0, 51.5, 70.0, 100.0, 78.0, 80.0, 85.0, 85.0, 110.0, 115.0, 125.0, 130.0, 120.0, 120.0, 130.0, 135.0, 110.0, 130.0, 150.0, 145.0, 150.0, 170.0, 225.0, 145.0, 188.0, 180.0, 197.0, 218.0, 300.0, 260.0, 265.0, 250.0, 250.0, 300.0, 320.0, 514.0, 556.0, 840.0, 685.0, 700.0, 700.0, 690.0, 900.0, 650.0, 820.0, 850.0, 900.0, 1015.0, 820.0, 1100.0, 1000.0, 1100.0, 1000.0, 1000.0] ) 훈련 데이터 테스트 데이터셋 분리12345from sklearn.model_selection import train_test_splittrain_input, test_input, train_target, test_target = train_test_split( perch_length, perch_weight, random_state = 42)train_input.shape, test_input.shape, train_target.shape, test_target.shape ((42,), (14,), (42,), (14,)) reshape() 사용하여 2차원 배열로 바꿈 1234train_input= train_input.reshape(-1, 1)test_input= test_input.reshape(-1, 1)print(train_input.shape, test_input.shape) (42, 1) (14, 1) 모델만들기1234567from sklearn.neighbors import KNeighborsRegressor# 클래스 불러오기knr = KNeighborsRegressor(n_neighbors=3)# 모형학습knr.fit(train_input, train_target) KNeighborsRegressor(n_neighbors=3) 1print(knr.predict([[50]])) [1033.33333333] 시각화12345678910111213141516# # 원본# import matplotlib.pyplot as plt# # 50cm 농어의 이웃을 구하기# distances, indexes= knr.kneighbors([[50]])# # 훈련세트의 산점도를 그리기# plt.scatter(train_input, train_target)# # 훈련 세트 중에서 이웃 샘플만 다시 그립니다.# plt.scatter(train_input[indexes], train_target[indexes], marker= &quot;D&quot;)# # 50cm 농어 데이터# plt.scatter(50, 1033, marker= &quot;^&quot;)# plt.xlabel(&quot;length&quot;)# plt.show() 123456789101112131415161718import matplotlib.pyplot as plt# 50cm 농어의 이웃을 구하기distances, indexes= knr.kneighbors([[50]])# 훈련세트의 산점도를 그리기# plt.scatter(train_input, train_target)fig, ax = plt.subplots()ax.scatter(train_input, train_target)# 훈련 세트 중에서 이웃 샘플만 다시 그립니다.ax.scatter(train_input[indexes], train_target[indexes], marker= &quot;D&quot;)# 50cm 농어 데이터ax.scatter(50, 1033, marker= &quot;^&quot;)ax.set_xlabel(&quot;length&quot;)ax.set_ylabel(&quot;weight&quot;)plt.show() 머신러닝 모델은 주기적으로 훈련해야 합니다. MLOps(Machine Learning &amp; Operations) 최근에 각광받는 데이터 관련 직업 필수 입사와 함께 공부시작 (데이터 분석가, 머신러닝 엔지니어, 데이터 싸이언티스트 희망자) 선형회귀 (머신러닝) 평가지표 확이이 더 중요 - R2점수, MAE, MSE, 등등 선형회귀 (통계) 5가지 가정들 장차의 정규성, 등분상성, 다중공선성, 등등… 종속변수 ~ 독립변수간의 “인과관계”를 찾는 과정 12345678from sklearn.linear_model import LinearRegressionlr = LinearRegression()# 선형 회귀 모델 훈련lr.fit(train_input, train_target)print(lr.predict([[50]])) [1241.83860323] 12345678import matplotlib.pyplot as pltfig, ax= plt.subplots()ax.scatter(train_input, train_target)ax.scatter(train_input[indexes], train_target[indexes], marker= &quot;D&quot;)ax.scatter(50, 1241, marker= &quot;^&quot;)ax.set_xlabel(&quot;length&quot;)ax.set_ylabel(&quot;weight&quot;)plt.show() - 농어무게 = 기울기(a) * 농어 길이 + 절편(b) 회귀식 찾기 기울기 절편 12# 기울기, 절편print(lr.coef_, lr.intercept_) [39.01714496] -709.0186449535477 - 기울기 a: 39.01714496 - 절편 b: 709.0186449535477 기울기: 계수 = 가중치 (딥러닝) 12345678910111213import matplotlib.pyplot as pltfig, ax= plt.subplots()ax.scatter(train_input, train_target)# 15~50까지의 1차 방정식 그래프ax.plot([15,50], [15 * lr.coef_ + lr.intercept_, 50 * lr.coef_ + lr.intercept_],)plt.scatter(50, 1241.8, marker= &quot;^&quot;)plt.show() 모형 평가 과대적합 발생 다항회귀 ax^2 + by + c if) 치어 1cm -670g이 나옴 1print(lr.predict([[1]])) [-670.00149999] 1차 방정식을 2차 방정식으로 만드는 과정 필요 넘파이 브로드캐스팅 배열의 크기가 동일하면 상관없음 배열의 크기가 다른데 연산을 할 때 브로드캐스팅 원리가 적용됨. 1234train_poly = np.column_stack((train_input **2, train_input))test_poly = np.column_stack((test_input **2, test_input))print(train_poly.shape, test_poly.shape) (42, 2) (14, 2) 12345lr = LinearRegression()lr.fit(train_poly, train_target)print(lr.predict([[50**2,50]])) [1573.98423528] 1print(lr.coef_, lr.intercept_) [ 1.01433211 -21.55792498] 116.0502107827827 -knn의 문제점 농어의 길이가 커져도 무게가 동일함 현실성없음 단순 선형회귀(1차방정식)의 문제점 치어(1cm)의 무게가 음수로 나옴 현실성없음 다항회귀(2차 방정식)로 변경 현실성 있음 마무리 정리 키워드 선형회귀: 특성과 타깃 사이의 관계를 가장 잘 나타내는 선형 방정식을 찾음. 특성이 하나면 직선 방정식이 됨. 모델 파라미터: 선형회귀가 찾은 가중치처럼 머신러닝 모델이 특성에서 학습한 파라미터 다항 회귀: 다항식을 사용하여 특성과 타깃 사이의 관계를 나타냄 Scikit-learn 패키지 LinearRegression: 선형 회귀 클래스","link":"/2022/03/28/0328_Regression_02/"},{"title":"k-최근접 이웃 회귀 03","text":"특성 공학과 규제 다중회귀: 여러가지 특성을 사용한 선형회귀 특성공학: 기존의 특성을 사용해 새로운 특성을 뽑아내는 작업 데이터 준비 판다스: 유명한 데이터 분석 라이브러리 데이터프레임: 판다스의 핵심 데이터 구조 12345import pandas as pd# pd.__version__df = pd.read_csv(&quot;https://bit.ly/perch_csv_data&quot;)perch_full = df.to_numpy()# print(perch_full) 12345678910# https://gist.github.com/rickiepark/2cd82455e985001542047d7d55d50630import numpy as npperch_weight = np.array([5.9, 32.0, 40.0, 51.5, 70.0, 100.0, 78.0, 80.0, 85.0, 85.0, 110.0, 115.0, 125.0, 130.0, 120.0, 120.0, 130.0, 135.0, 110.0, 130.0, 150.0, 145.0, 150.0, 170.0, 225.0, 145.0, 188.0, 180.0, 197.0, 218.0, 300.0, 260.0, 265.0, 250.0, 250.0, 300.0, 320.0, 514.0, 556.0, 840.0, 685.0, 700.0, 700.0, 690.0, 900.0, 650.0, 820.0, 850.0, 900.0, 1015.0, 820.0, 1100.0, 1000.0, 1100.0, 1000.0, 1000.0]) perch_full과 perch_weight를 훈련세트와 테스트 세트로 나눔 123from sklearn.model_selection import train_test_splittrain_input, test_input, train_target, test_target = train_test_split(perch_full, perch_weight, random_state= 42)print(train_target) [ 85. 135. 78. 70. 700. 180. 850. 820. 1000. 120. 85. 130. 225. 260. 1100. 900. 145. 115. 265. 1015. 514. 218. 685. 32. 145. 40. 690. 840. 300. 170. 650. 110. 150. 110. 1000. 150. 80. 700. 120. 197. 1100. 556.] 사이킷런의 변환기 변환기: 특성을 만들거나 전처리하기 위한 다양한 클래스들 fit(), score(), predict(), transform(), 등등… 12345from sklearn.preprocessing import PolynomialFeaturespoly = PolynomialFeatures()poly.fit([[2,3]]) # 변환 전 학습시키기print(poly.transform([[2,3]])) # 2,3의 특성을 변환시킨것 [[1. 2. 3. 4. 6. 9.]] - 2와 3을 곱한 6, 각각 제곱한 4, 9, 절편인 1이 추가되었다. 사이킷런 특성상 절편을 자동으로 추가하므로 1은 필요 없음. include_bias= False로 제거 123poly = PolynomialFeatures(include_bias= False)poly.fit([[2,3]])print(poly.transform([[2, 3]])) [[2. 3. 4. 6. 9.]] train_input에 적용 12345poly = PolynomialFeatures(include_bias= False) # 1은 제외poly.fit(train_input) # 변환 전 학습시키기train_poly = poly.transform(train_input) # 변환print(train_poly.shape)# print(train_poly) (42, 9) PolynomiaFeatures클래스의 get_feature_names_/Images/0328_Regression_03/out()의 메서드로 9개의 특성이 각각 어떤 입력의 조합으로 만들어졌는지 알 수 있다. 1poly.get_feature_names_/Images/0328_Regression_03/out() array(['x0', 'x1', 'x2', 'x0^2', 'x0 x1', 'x0 x2', 'x1^2', 'x1 x2', 'x2^2'], dtype=object) 각각 x0, x1, x2에서 파생된 값들 12test_poly= poly.transform(test_input) # test_input 을 변환# print(test_poly) poly: 2,3을 transform한 값 train_poly: train_input을 transform한 값 test_poly: test_input을 transform한 값 다중회귀 모델 훈련1234from sklearn.linear_model import LinearRegressionlr = LinearRegression()lr.fit(train_poly, train_target) # fit(): 훈련시키기print(lr.score(train_poly, train_target)) # 정답률 99퍼센트 0.9903183436982124 1print(lr.score(test_poly, test_target)) # 정답률 97퍼센트 0.9714559911594134 12345poly = PolynomialFeatures(degree= 5, include_bias= False) # 5제곱까지 특성을 만들어 출력, 1은 제외poly.fit(train_input) # 변환 전 학습시키기train_poly = poly.transform(train_input) # 변환시키기test_poly = poly.transform(test_input) # 변환시키기print(train_poly.shape) (42, 55) 12lr.fit(train_poly, train_target) # fit(): 훈련시키기print(lr.score(train_poly, train_target)) # 정답률 100퍼센트에 가까움 0.9999999999991097 1print(lr.score(test_poly, test_target)) # 점수가 음수로 나옴 -144.40579242684848 144로 음수가 나와 과대적합이 되었음. 특성을 줄일 필요가 있음. 규제(Regularization) 머신러닝 모델이 훈련세트를 너무 과도하게 학습하지 못하도록 훼방하는 것 123456# 정규화 우선from sklearn.preprocessing import StandardScalerss = StandardScaler()ss.fit(train_poly) # 변환 전 학습시키기 train_scaled = ss.transform(train_poly) # 정규화test_scaled = ss.transform(test_poly) # 정규화 릿지(Ridge)와 라쏘(Lasso) 선형 회귀모델에 규제를 추가한 모델 릿지 회귀 (Ridge)12345from sklearn.linear_model import Ridgeridge = Ridge()ridge.fit(train_scaled, train_target) # fit()로 학습시키기print(ridge.score(train_scaled, train_target)) # 0.99의 점수가 나옴print(ridge.score(test_scaled, test_target)) # 점수가 정상으로 돌아옴 0.9896101671037343 0.9790693977615397 릿지와 라쏘 모델을 사용 할 때 alpha매개변수로 규제의 강도를 조절 가능 alpha값이 크면 규제강도가 세지므로 과소적합되도록 유도 alpha값이 작으면 규제강도가 세지므로 과대적합되도록 유도 적절한 alpha값을 찾는 방법중 하나로는 alpha값에 대한 R^2값의 그래프를 그려보는것. 훈련세트와 테스트 세트의 점수가 가장 가까운 지점이 최적의 alpha값 123456789101112131415train_score = []test_score = []# alpha값을 0.001~100까지 10배씩 늘리며 회귀모델을 훈련alpha_list = [0.001, 0.01, 0.1, 1, 10, 100]for alpha in alpha_list: # 릿지모델을 만듬 ridge = Ridge(alpha=alpha) # 릿지모델을 훈련 ridge.fit(train_scaled, train_target) # 훈련 점수와 테스트 점수를 저장 train_score.append(ridge.score(train_scaled, train_target)) test_score.append(ridge.score(test_scaled, test_target)) 123456789# 로그함수로 나타내어 그래프 그리기# 객체지향 함수로 진행import matplotlib.pyplot as pltfig, ax= plt.subplots()ax.plot(np.log10(alpha_list), train_score) # 위에 그려질 그래프ax.plot(np.log10(alpha_list), test_score) # 아래에 그려질 그래프ax.set_xlabel(&quot;alpha&quot;) # x축은 지수를 나타냄ax.set_ylabel(&quot;R^2&quot;) # == score의 점수plt.show() 0.1인 -1에서 가장 가깝고 결정계수가 가장 높기때문에 alpha로 선정 1234ridge = Ridge(alpha=0.1)ridge.fit(train_scaled, train_target)print(ridge.score(train_scaled, train_target))print(ridge.score(test_scaled, test_target)) # 둘이 비슷하게 높은 점수가 나옴. 0.9903815817570366 0.9827976465386926 라쏘 (Lasso)12345from sklearn.linear_model import Lassolasso = Lasso()lasso.fit(train_scaled, train_target) # fit()로 학습시키기print(lasso.score(train_scaled, train_target)) # 0.99의 점수가 나옴print(lasso.score(test_scaled, test_target)) # 점수가 정상으로 돌아옴 0.989789897208096 0.9800593698421883 적절한 alpha 값 찾기 123456789101112131415train_score = []test_score = []# alpha값을 0.001~100까지 10배씩 늘리며 회귀모델을 훈련alpha_list = [0.001, 0.01, 0.1, 1, 10, 100]for alpha in alpha_list: # 라쏘모델을 만듬 lasso = Lasso(alpha=alpha, max_iter=10000) # 라쏘모델을 훈련 lasso.fit(train_scaled, train_target) # 훈련 점수와 테스트 점수를 저장 train_score.append(lasso.score(train_scaled, train_target)) test_score.append(lasso.score(test_scaled, test_target)) /usr/local/lib/python3.7/dist-packages/sklearn/linear_model/_coordinate_descent.py:648: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.878e+04, tolerance: 5.183e+02 coef_, l1_reg, l2_reg, X, y, max_iter, tol, rng, random, positive /usr/local/lib/python3.7/dist-packages/sklearn/linear_model/_coordinate_descent.py:648: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.297e+04, tolerance: 5.183e+02 coef_, l1_reg, l2_reg, X, y, max_iter, tol, rng, random, positive 123456789# 로그함수로 나타내어 그래프 그리기# 객체지향 함수로 진행import matplotlib.pyplot as pltfig, ax= plt.subplots()ax.plot(np.log10(alpha_list), train_score) # 위에 그려질 그래프ax.plot(np.log10(alpha_list), test_score) # 아래에 그려질 그래프ax.set_xlabel(&quot;alpha&quot;) # x축은 지수를 나타냄ax.set_ylabel(&quot;R^2&quot;) # == score의 점수plt.show() alpha가 2인 값은 훈련세트와 테스트세트의 점수가 좁음 하지만 결정계수가 낮기때문에 10을 의미하는 1이 최적의 alpha값임. 1234lasso = Lasso(alpha=0.1)lasso.fit(train_scaled, train_target)print(lasso.score(train_scaled, train_target))print(lasso.score(test_scaled, test_target)) # 라쏘 또한 둘이 비슷하게 높은 점수가 나옴. 0.990137631128448 0.9819405116249363 /usr/local/lib/python3.7/dist-packages/sklearn/linear_model/_coordinate_descent.py:648: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.062e+02, tolerance: 5.183e+02 coef_, l1_reg, l2_reg, X, y, max_iter, tol, rng, random, positive 라쏘모델의 계수값을 아예 0으로 만들 수 있음. 라쏘 모델의 계수는 coef_ 속성에 저장되어 있음. 1print(np.sum(lasso.coef_ == 0)) 52 마무리 정리 키워드 다중회귀: 여러개의 특성을 사용하는 회귀모델 특성공학: 주어진 특성을 조합하여 새로운 특성을 만드는 일련의 작업과정 릿지: 규제가 있는 선형 회귀모델중 하나이며 선형 모델의 계수를 작게 만들어 과대적합을 완화시킴 라쏘: 또 다른 규제가 있는 선형회귀 모델. 릿지와 달리 계수값을 0으로 만들 수 있음. 하이퍼파라미터: 머신러닝 알고리즘이 학습하지 않는 파라미터. 사람이 지정해야함. 대표적으로 릿지와 라쏘의 규제 강도 alpha파라미터가 있음. Pandas 패키지 유명한 데이터 분석 라이브러리 read_csv(): 로컬 컴퓨터나 인터넷에 있는 csv파일을 읽어 판다스 데이터프레임으로 변환하는 함수 Scikit-learn 패키지 PolynomialFeatures: 주어진 특성을 조합하여 새로운 특성을 만듬 degree: 최고 차수를 지정함. [default: 2] interactopm_only: True이면 거듭제곱항은 제외되고 특성간의 곱셈항만 추가됨. [default: False] include_bias: False이면 절편을 위한 특성을 추가하지 않음. [default: True] Ridge: 규제가 있는 회귀 알고리즘인 릿지 회귀모델을 훈련함. alpha: 매개변수로 규제의 강도를 조절함. 값이 클수록 규제가 강함. [default: 1] Lasso: 규제가 있는 회귀 알고리즘인 라쏘 회귀모델을 훈련함. 최적의 모델을 찾기 위해 좌표축을 따라 최적화를 수행해가는 좌표 하강법을 사용 alpha와 random_state매개변수는 Ridge클래스와 동일 max_iter: 알고리즘의 수행 반복 횟수를 지정함. [default: 1000]","link":"/2022/03/28/0328_Regression_03/"},{"title":"로지스틱 회귀 01","text":"로지스틱 회귀(Logistic Regression)데이터 불러오기12345import pandas as pdimport numpyfish = pd.read_csv('https://bit.ly/fish_csv_data')fish.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Species Weight Length Diagonal Height Width 0 Bream 242.0 25.4 30.0 11.5200 4.0200 1 Bream 290.0 26.3 31.2 12.4800 4.3056 2 Bream 340.0 26.5 31.1 12.3778 4.6961 3 Bream 363.0 29.0 33.5 12.7300 4.4555 4 Bream 430.0 29.0 34.0 12.4440 5.1340 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-933200f5-54dd-47e4-9481-6ae409c19d41 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-933200f5-54dd-47e4-9481-6ae409c19d41'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 데이터 변환 배열로 변환 to_numpy(): 이용하여 넘파이 배열로 새로 저장 123fish_input = fish[[&quot;Weight&quot;, &quot;Length&quot;, &quot;Diagonal&quot;, &quot;Height&quot;, &quot;Width&quot;]].to_numpy() # 특성별로 구분해서 저장print(fish_input[:5])fish_input.shape [[242. 25.4 30. 11.52 4.02 ] [290. 26.3 31.2 12.48 4.3056] [340. 26.5 31.1 12.3778 4.6961] [363. 29. 33.5 12.73 4.4555] [430. 29. 34. 12.444 5.134 ]] (159, 5) 종류를 target 배열로 변환 종속변수 12fish_target= fish[&quot;Species&quot;].to_numpy()# fish_target.shape 훈련 데이터와 테스트 데이터123456# from sklearn.model_selection import train_test_split# train_input, test_input, train_target, test_target = train_test_split(fish_input, fish_target, random_state= 42)from sklearn.model_selection import train_test_splittrain_input, test_input, train_target, test_target = train_test_split( fish_input, fish_target, random_state= 42) 표준화 전처리 1234567from sklearn.preprocessing import StandardScalerss = StandardScaler()ss.fit(train_input) # 변환 전 훈련train_scaled = ss.transform(train_input) # 변환test_scaled = ss.transform(test_input) # 변환test_scaled[:5] array([[-0.88741352, -0.91804565, -1.03098914, -0.90464451, -0.80762518], [-1.06924656, -1.50842035, -1.54345461, -1.58849582, -1.93803151], [-0.54401367, 0.35641402, 0.30663259, -0.8135697 , -0.65388895], [-0.34698097, -0.23396068, -0.22320459, -0.11905019, -0.12233464], [-0.68475132, -0.51509149, -0.58801052, -0.8998784 , -0.50124996]]) k최근접 이웃 분류기 확률 예측 1234567from sklearn.neighbors import KNeighborsClassifierkn = KNeighborsClassifier(n_neighbors=3) # 3개의 이웃 데이터의 평균으로 유추kn.fit(train_scaled, train_target) # 흔랸print(kn.score(train_scaled, train_target)) # 훈련 후 점수 확인print(kn.score(test_scaled, test_target)) 0.8907563025210085 0.85 182p 1234import numpy as npproba = kn.predict_proba(test_scaled[:5])print(np.round(proba, decimals= 4))print(kn.classes_) [[0. 0. 1. 0. 0. 0. 0. ] [0. 0. 0. 0. 0. 1. 0. ] [0. 0. 0. 1. 0. 0. 0. ] [0. 0. 0.6667 0. 0.3333 0. 0. ] [0. 0. 0.6667 0. 0.3333 0. 0. ]] ['Bream' 'Parkki' 'Perch' 'Pike' 'Roach' 'Smelt' 'Whitefish'] 로지스틱 회귀 (분류모델) 중요도: 최상 *** 로지스틱 회귀의 이론이 나온 이유: *** 범주형( True, False ) 의 경우 선형함수로 표현하기엔 오류가 발생하여 굴곡이 있는 모델을 제시함. 유튜브 시청 필요 https://youtu.be/zASrGSHoqL4 개념 재복습 필수 중요한 이유: 기초통계로도 활용(의학통계) 머신러닝 분류모형의 기초 모형인데, 성능이 나쁘지 않음. 데이터셋, 수치 데이터 기반 딥러닝: 초기모형에 해당됨. 시그모이드 함수: z = phi = 1 / (1 + np.exp(-z)) 12345678910# 원본# import numpy as np# import matplotlib.pyplot as plt# z = np.arange(-5, 5, 0.1)# phi = 1 / (1 + np.exp(-z))# # phi# plt.plot(z, phi)# plt.xlabel(&quot;z&quot;)# plt.ylabel(&quot;phi&quot;)# plt.show() 123456789import numpy as npimport matplotlib.pyplot as pltz = np.arange(-5, 5, 0.1) # -5와 5 사이에서 0.1간격으로 배열phi = 1 / (1 + np.exp(-z)) # 지수함수 계산은 np.exp() 함수를 이용fig, ax = plt.subplots()ax.plot(z, phi)ax.set_xlabel(&quot;z&quot;)ax.set_ylabel(&quot;phi&quot;)plt.show &lt;function matplotlib.pyplot.show&gt; 시그모이드 함수의 출력이 0.5보다 크면 양성 클래스, 0.5보다 작으면 음성 클래스로 판단 0.5일때는 라이브러리마다 다르지만 사이킷런은 음성클래스로 판단. 로지스틱 회귀로 이진 분류 수행하기12char_arr = np.array([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;])print(char_arr[[True, False, True, False, False]]) # True, False로 원하는 데이터만 추출 ['A' 'C'] 1234bream_smelt_indexes = (train_target == 'Bream') | (train_target == 'Smelt') # | : OR연산자train_bream_smelt = train_scaled[bream_smelt_indexes]target_bream_smelt = train_target[bream_smelt_indexes]target_bream_smelt array(['Bream', 'Smelt', 'Bream', 'Bream', 'Bream', 'Smelt', 'Bream', 'Bream', 'Bream', 'Bream', 'Bream', 'Bream', 'Bream', 'Smelt', 'Bream', 'Smelt', 'Smelt', 'Bream', 'Bream', 'Bream', 'Bream', 'Bream', 'Bream', 'Bream', 'Bream', 'Smelt', 'Bream', 'Smelt', 'Smelt', 'Bream', 'Smelt', 'Bream', 'Bream'], dtype=object) 186p 모형 만들고 예측하기! 1234from sklearn.linear_model import LogisticRegressionlr = LogisticRegression()# 독립변수 종속변수lr.fit(train_bream_smelt, target_bream_smelt) LogisticRegression() 12345# 예측하기# 클래스로 분류# 확률값 -&gt; 0.5print(lr.predict(train_bream_smelt[:5])) ['Bream' 'Smelt' 'Bream' 'Bream' 'Bream'] 12print(lr.predict_proba(train_bream_smelt[:5]))print(lr.classes_) # smelt: 양성 클래스 , bream: 음성 클래스 [[0.99759855 0.00240145] [0.02735183 0.97264817] [0.99486072 0.00513928] [0.98584202 0.01415798] [0.99767269 0.00232731]] ['Bream' 'Smelt'] 방정식의 각 기울기와 상수를 구하는 코드 123# print(lr.coef_, lr.intercept_)print(lr.coef_)print(lr.intercept_) [[-0.4037798 -0.57620209 -0.66280298 -1.01290277 -0.73168947]] [-2.16155132] 결론 z식 z = -0.4037798 * weight - 0.57620209 *length - -0.66280298 * diagonal -1.01290277 * height -0.73168947 * width - 2.16155132 라는 식이 도출됨 z값을 출력하자 predict_proba() 12decisions = lr.decision_function(train_bream_smelt[:5])print(decisions) [-6.02927744 3.57123907 -5.26568906 -4.24321775 -6.0607117 ] 12from scipy.special import expitprint(expit(decisions)) [0.00240145 0.97264817 0.00513928 0.01415798 0.00232731] 마무리 정리 키워드 로지스틱 회귀: 선형 방정식을 사용한 분류 알고리즘 (시그모이드를 사용하여 클래스 학률을 출력할수 있다.) 다중분류 타깃 클래스가 2개 이상인 분류 문제 시그모이드:0~1사이의 값으로 Scikit-learn 패키지 LogisticRegression:선형분류의 알고리즘인 로지스틱 회귀를 위한 클래스 매개변수 solver: 사용할 알고리즘을 선택 [default: lbfgs] 매개변수 penalty: L2규제(릿지 방식)와 L1규제(라쏘 방식)를 선택 [default: l2] 매개변수 C: 규제의 강도를 제어. 작을수록 규제가 강함 [default: 1.0] predict_proba(): 예측 확률을 반환 decision_function(): 모델이 학습한 선형 방정식의 출력을 반환","link":"/2022/03/29/0329_LogisticRegression_01/"},{"title":"확률적 경사 하강법 01","text":"경사 하강법이 쓰인 여러 알고리즘 - (이미지, 택스트) 딥러닝 기초 알고리즘 - 트리 알고리즘 + 경사하강법 융합 = 부스팅계열 - LightGBM, Xgboost, Catboost ex 1등으로 자주 쓰인 알고리즘: LightGBM, Xgboost - 하이퍼 파라미터의 개수가 80개가 넘음 SGDClassifier 확률적 경사하강법 분류기 1회에 1개의 데이터씩 뽑기: 확률적 경사 하강법 1회에 여러개의 데이터씩 뽑기: 미니배치 경사 하강법 1회에 모든 데이터를 뽑기: 배치 경사 하강법 에포크: 훈련세트를 한번 모두 사용하는 과정 123import pandas as pdfish = pd.read_csv(&quot;https://bit.ly/fish_csv_data&quot;)fish.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 159 entries, 0 to 158 Data columns (total 6 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Species 159 non-null object 1 Weight 159 non-null float64 2 Length 159 non-null float64 3 Diagonal 159 non-null float64 4 Height 159 non-null float64 5 Width 159 non-null float64 dtypes: float64(5), object(1) memory usage: 7.6+ KB 배열로 변환하는 코드 독립변수 = fish_input 종속변수 = fish_target 12fish_input = fish[[&quot;Weight&quot;, &quot;Length&quot;, &quot;Diagonal&quot;, &quot;Height&quot;, &quot;Width&quot;]].to_numpy()fish_target= fish[&quot;Species&quot;].to_numpy() 훈련세트와 테스트세트로 분리 123456from sklearn.model_selection import train_test_splittrain_input, test_input, train_target, test_target = train_test_split( fish_input, fish_target, random_state= 42)train_input.shape, test_input.shape, train_target.shape, test_target.shape, ((119, 5), (40, 5), (119,), (40,)) 표준화 처리 다시 한번 강조하지만 꼭 훈련 세트로 학습한 통계값으로 테스트 세트도 변환한다. 키워드: Data Leakage 방지 (나중에 찾아볼것) 12345678from sklearn.preprocessing import StandardScalerss = StandardScaler()ss.fit(train_input) # 변환 전 훈련세트 학습# ss훈련 데이터만 활용해서 학습이 끝난 상태# 표준화 처리를 훈련데이터와 테스트데이터에 동시 적용train_scaled = ss.transform(train_input) # 변환test_scaled = ss.transform(test_input) # 변환 모델 학습 2개의 매개 변수 지정 loss= “log”= 로지스틱 손실 함수로 지정 max_iter = 에포크 횟수 지정 12345678910from sklearn.linear_model import SGDClassifier# 매개변수 지정# 하이퍼파라미터 설정# 매개변수 값을 dictionary 형태로 추가하는 코드 작성 가능# 입문자들에게는 비추천sc = SGDClassifier(loss=&quot;log&quot;, max_iter= 100, random_state= 42)sc.fit(train_scaled, train_target)print(sc.score(train_scaled, train_target))print(sc.score(test_scaled, test_target)) 0.8403361344537815 0.8 적절한 에포크 숫자 찾기 12345678910111213import numpy as npsc = SGDClassifier(loss= &quot;log&quot;, max_iter=100, tol=None, random_state= 42)train_score=[]test_score= []classes = np.unique(train_target)for _ in range(0,300): # 에포크값 0 ~ 300 , # &quot;_&quot;도 변수가 될 수 있음 sc.partial_fit(train_scaled, train_target, classes= classes) # 훈련 train_score.append(sc.score(train_scaled, train_target)) # 점수로 나오는 값들을 append() test_score.append(sc.score(test_scaled, test_target))print(train_score[:5])print(test_score[:5]) [0.5294117647058824, 0.6218487394957983, 0.6386554621848739, 0.7310924369747899, 0.7226890756302521] [0.65, 0.55, 0.575, 0.7, 0.7] 모형학습 시각화 12345678import matplotlib.pyplot as pltfig, ax = plt.subplots()ax.plot(train_score)ax.plot(test_score)ax.set_xlabel(&quot;Epoch&quot;)ax.set_ylabel(&quot;accuracy&quot;)plt.show() 1234sc = SGDClassifier(loss=&quot;log&quot;, max_iter=100, tol=None, random_state=42) # 반복횟수 100 , # tol(): 반복을 멈추는 기준sc.fit(train_scaled, train_target)print(sc.score(train_scaled, train_target))print(sc.score(test_scaled, test_target)) 0.957983193277311 0.925 마무리 정리 키워드 확률적 경사 하강법: 훈련세트에서 샘플 하나씩 꺼내 손실 함수의 경사를 따라 최적의 모델링을 찾는 알고리즘 손실함수: 확률적 경사 하강법이 최적화 할 대상 ex) 이진분류에는 로지스틱 회귀 손실함수를 사용 에포크: 확률적 경사 하강법에서 전체 샘플을 모두 사용하는 한 번 반복을 의미 Scikit-Learn 패키지 SGDClassifier: 확률적 경사 하강법을 사용한 분류모델을 만듬 매개변수 loss: 최적화 할 손실함수를 지정. 로지스틱 회귀를 위해서는 log로 지정. [default: hinge](서포트 벡터 머신) 매개변수 max_iter: 에포크 횟수를 지정 [default: 1000] 매개변수 tol: 반복을 멈출 조건 [default: 0.001] SGDRegressor: 확률적 경사 하강법을 사용한 회귀모델을 만듬 매개변수 loss: 손실함수를 지정 [default: squared_loss](제곱오차를 나타냄) 매개변수 max_iter: 에포크 횟수를 지정 [default: 1000] 매개변수 tol: 반복을 멈출 조건 [default: 0.001]","link":"/2022/03/29/0329_SGDClassifier01/"},{"title":"교차검증과_랜덤서치_01","text":"교차 검증과 그리드 서치 키워드: 하이퍼 파라미터 데이터가 작을 때, 주로 사용 하이퍼 파라미터 max_depth: 3일때, 정확도가 84% 결론 모르면 default만 쓸것 가성비 (시간 대비 성능 보장 안됨) 검증 세트 테스트 세트 (1회성) 훈련 데이터를 훈련데이터 + 검증 데이터로 재분할 현실 테스트 데이터가 별도로 존재안함 ex) 전체 데이터 = 훈련(6) : 검증(2) : 테스트(2) 테스트 데이터는 모르는 데이터로 간주 123456import pandas as pdwine = pd.read_csv(&quot;https://bit.ly/wine_csv_data&quot;)data = wine[['alcohol', 'sugar', 'pH']].to_numpy()target= wine['class'].to_numpy()wine.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } alcohol sugar pH class 0 9.4 1.9 3.51 0.0 1 9.8 2.6 3.20 0.0 2 9.8 2.3 3.26 0.0 3 9.8 1.9 3.16 0.0 4 9.4 1.9 3.51 0.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-7bbb17c4-c2ff-4a49-b897-7cc39b6d3337 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-7bbb17c4-c2ff-4a49-b897-7cc39b6d3337'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 12345from sklearn.model_selection import train_test_splittrain_input, test_input, train_target, test_target = train_test_split( data, target, test_size= 0.2, random_state= 42)print(train_input.shape, test_input.shape) (5197, 3) (1300, 3) 12345# train 데이터의 20%를 val 데이터로 분류sub_input, val_input, sub_target, val_target = train_test_split( train_input, train_target, test_size= 0.2, random_state= 42 # random_state: 추출값 고정이 목적)print(sub_input.shape, val_input.shape, val_target.shape) (4157, 3) (1040, 3) (1040,) 12345from sklearn.tree import DecisionTreeClassifierdt = DecisionTreeClassifier(random_state=42)dt.fit(sub_input, sub_target)print(dt.score(sub_input, sub_target)) # 0.9971133028626413print(dt.score(val_input, val_target)) # 0.864423076923077 0.9971133028626413 0.864423076923077 교차검증 교차검증의 목적: 좋은 모델이 만들어진다! 좋은 모델 = 과대적합이 아닌 모델 = 모형의 오차가 적은 모델 = 안정적인 모델 성능 좋은 모델이 좋은 모델이란게 아님 교재 245p 모델평가1: 90% (소요시간: 1시간) 모델평가2: 85% 모델평가3: 80% 단점: 시간이 오래 걸림 교차검증 함수123from sklearn.model_selection import cross_validatescores = cross_validate(dt, train_input, train_target)print(scores) {'fit_time': array([0.0083735 , 0.00927544, 0.00848556, 0.00817442, 0.00816131]), 'score_time': array([0.00126314, 0.00097775, 0.00073361, 0.00077486, 0.00080872]), 'test_score': array([0.86923077, 0.84615385, 0.87680462, 0.84889317, 0.83541867])} 최종점수 평균 구하기 12import numpy as npprint(np.mean(scores['test_score'])) 0.855300214703487 훈련 세트 섞은 후, 10-폴드 교차검증 12345from sklearn.model_selection import StratifiedKFoldsplitter = StratifiedKFold(n_splits = 10, shuffle = True, random_state = 42)scores = cross_validate(dt, train_input, train_target, cv= splitter)print(scores['test_score'])print(np.mean(scores['test_score'])) [0.84807692 0.89423077 0.87115385 0.85576923 0.86346154 0.87884615 0.87692308 0.86319846 0.87668593 0.87475915] 0.8703105083740921 하이퍼파라미터 튜닝 그리드 서치 vs 랜덤 서치 꼭 사용하고 싶다면 -&gt; 랜덤 서치 사용 자동으로 잡아주는 라이브러리 등장 hyperopt 등등… 1234567891011from pandas.core.common import random_statefrom sklearn.model_selection import GridSearchCVfrom sklearn.tree import DecisionTreeClassifierparams = {'min_impurity_decrease': [0.0001, 0.0002, 0.0003, 0.0004, 0.0005], # 'max_depth': [3, 4, 5, 6, 7]}# dt = DecisionTreeClassifier(random_state= 42)gs = GridSearchCV(DecisionTreeClassifier(random_state= 42),params, n_jobs= -1)gs.fit(train_input, train_target) GridSearchCV(estimator=DecisionTreeClassifier(random_state=42), n_jobs=-1, param_grid={'min_impurity_decrease': [0.0001, 0.0002, 0.0003, 0.0004, 0.0005]}) 1234dt= gs.best_estimator_print(dt)print(dt.score(train_input, train_target))print(gs.best_params_) DecisionTreeClassifier(min_impurity_decrease=0.0001, random_state=42) 0.9615162593804117 {'min_impurity_decrease': 0.0001} 1print(gs.cv_results_['mean_test_score']) [0.86819297 0.86453617 0.86492226 0.86780891 0.86761605] 랜덤서치 매개변수 값의 목록을 전달하는것이 아니라 매개변수를 샘플링 할 수 있도록 확률 분포 객체를 전달 1234# scipy라이브러리: 적분, 보간, 선형대수, 확률 등을 포함한 수치 계산 전용으로 파이썬의 핵심 과학 라이브러리from scipy.stats import uniform, randint # randint: 정수값을 뽑음, uniform: 실수값을 뽑음.rgen = randint(0,10)rgen.rvs(10) array([0, 4, 9, 5, 9, 9, 1, 0, 2, 1]) 1np.unique(rgen.rvs(1000), return_counts= True) # 각각 추출된 숫자의 갯수 (array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]), array([ 99, 116, 90, 99, 87, 118, 104, 101, 81, 105])) 12ugen= uniform(0, 1)ugen.rvs(10) array([0.4111007 , 0.57571785, 0.55554775, 0.58827729, 0.92876842, 0.98869391, 0.87016065, 0.51721186, 0.54686086, 0.97925777]) 1234567891011from sklearn.model_selection import RandomizedSearchCVparams = { 'min_impurity_decrease': uniform(0.0001, 0.001), 'max_depth': randint(20, 50), 'min_samples_split': randint(2, 25), 'min_samples_leaf': randint(1, 25),}gs = RandomizedSearchCV(DecisionTreeClassifier(random_state= 42), params, # n_iter: 파라미터 검색 횟수 n_iter= 100, n_jobs= -1, random_state= 42) # n_jobs: cpu코어 수gs.fit(train_input, train_target) RandomizedSearchCV(estimator=DecisionTreeClassifier(random_state=42), n_iter=100, n_jobs=-1, param_distributions={'max_depth': &lt;scipy.stats._distn_infrastructure.rv_frozen object at 0x7f6ec0604a90&gt;, 'min_impurity_decrease': &lt;scipy.stats._distn_infrastructure.rv_frozen object at 0x7f6ec0604910&gt;, 'min_samples_leaf': &lt;scipy.stats._distn_infrastructure.rv_frozen object at 0x7f6ec0604e90&gt;, 'min_samples_split': &lt;scipy.stats._distn_infrastructure.rv_frozen object at 0x7f6ec0604a50&gt;}, random_state=42) 1print(gs.best_params_) # 최고의 교차검증 점수 {'max_depth': 39, 'min_impurity_decrease': 0.00034102546602601173, 'min_samples_leaf': 7, 'min_samples_split': 13} 12# 검증 점수print(np.max(gs.cv_results_['mean_test_score'])) 0.8695428296438884 123# 테스트 세트로 성능 확인dt = gs.best_estimator_print(dt.score(test_input, test_target)) 0.86 마무리 정리 키워드 검증세트: 하이퍼파라미터 튜닝을 위해 모델을 평가 할 때, 테스트 세트를 사용하지 않기 위해 훈련세트에서 다시 떼어 낸 데이터 세트 교차검증: 훈련세트를 여러 폴드로 나눈 다음 한 폴드가 검증 세트의 역할을 하고 나머지 폴드에서는 모델을 훈련 그리드 서치: 하이퍼파라미터 탐색을 자동화해주는 도구. 탐색할 매개변수를 나열하면 교차 거증을 수행하여 가장 좋은 검증 점수의 매개변수 조합을 선택. 이 매개변수 조합으로 최종 모델을 훈련 랜덤 서치: 연속된 매개변수 값을 탐색할 때 유용함. 탐색할 값을 직접 나열하는것이 아니고 탐색값을 샘플링 할 수 있는 확률 분포 객체를 전달 Scikit-learn 패키지 crpss_va;odate(): 교차 검증을 수행하는 함수 GridSerchCV: 교차검증으로 하이퍼파라미터 탐색을 수행 RandomizedSearchCV: 교차검증으로 랜덤한 하이퍼파라미터 탐색을 수행","link":"/2022/03/30/0330_Cross_Validation01/"},{"title":"결정_트리_01","text":"데이터 불러오기 와인데이터 alcohol(알코올 도수), sugar(당도), pH(산도), class(0= 레드 와인, 1= 화이트 와인) 123import pandas as pdwine = pd.read_csv(&quot;https://bit.ly/wine_csv_data&quot;)wine.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } alcohol sugar pH class 0 9.4 1.9 3.51 0.0 1 9.8 2.6 3.20 0.0 2 9.8 2.3 3.26 0.0 3 9.8 1.9 3.16 0.0 4 9.4 1.9 3.51 0.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-3ff52dca-19e0-496c-b891-4e13de664c47 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-3ff52dca-19e0-496c-b891-4e13de664c47'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['/Images/0330_Decision_Tree_01/output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; info() 결측치 확인 / 변수 타입 1wine.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 6497 entries, 0 to 6496 Data columns (total 4 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 alcohol 6497 non-null float64 1 sugar 6497 non-null float64 2 pH 6497 non-null float64 3 class 6497 non-null float64 dtypes: float64(4) memory usage: 203.2 KB 1wine.describe() # 간단한 통계를 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } alcohol sugar pH class count 6497.000000 6497.000000 6497.000000 6497.000000 mean 10.491801 5.443235 3.218501 0.753886 std 1.192712 4.757804 0.160787 0.430779 min 8.000000 0.600000 2.720000 0.000000 25% 9.500000 1.800000 3.110000 1.000000 50% 10.300000 3.000000 3.210000 1.000000 75% 11.300000 8.100000 3.320000 1.000000 max 14.900000 65.800000 4.010000 1.000000 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-187f8402-85e9-484f-9ccb-82e7f257f44a button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-187f8402-85e9-484f-9ccb-82e7f257f44a'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['/Images/0330_Decision_Tree_01/output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 표준화 작업12data = wine[['alcohol', 'sugar', 'pH']].to_numpy() # 'alcohol', 'sugar', 'pH'기준으로 재배열target = wine['class'].to_numpy() # 'class'기준으로 재배열 훈련데이터와 테스트데이터로 분리12345from sklearn.model_selection import train_test_splittrain_input, test_input, train_target, test_target = train_test_split( data, target, test_size= 0.2, random_state= 42)print(train_input.shape, test_input.shape) (5197, 3) (1300, 3) 표준화 진행 12345from sklearn.preprocessing import StandardScalerss= StandardScaler()ss.fit(train_input) # 변환 전 훈련시키기train_scaled= ss.transform(train_input)test_scaled= ss.transform(test_input) 모델 만들기로지스틱회귀123456from sklearn.linear_model import LogisticRegressionlr = LogisticRegression()lr.fit(train_scaled, train_target)print(lr.score(train_scaled, train_target)) # 0.7808350971714451print(lr.score(test_scaled, test_target)) # 0.7776923076923077print(lr.coef_, lr.intercept_) # lr.coef_: 기울기, lr.intercept_: 절편 0.7808350971714451 0.7776923076923077 [[ 0.51270274 1.6733911 -0.68767781]] [1.81777902] 의사결정트리 1975년도 등장 다양한 산업에서 많이 쓰임 2001년즈음 랜덤 포레스트 캐글대회 2017~2018년까지 정형데이터 대회는 랜덤포래스트가 메인 이론인적이 있었음. 로지스틱 회귀 수식 의사결정트리의 기본 알고리즘을 활용해서 MS, 구글 등 이런 회사들이 신규 알고리즘을 만듬. XGBoost, LightGBM, CatBoost 캐글 정형데이터 LIghtGBM (지금 현재 실무에서 많이 쓰임) 4월 말까지는 코드에 집중, 대회 나감 PPT (알고리즘 소개) 12345from sklearn.tree import DecisionTreeClassifierdt = DecisionTreeClassifier(random_state=42)dt.fit(train_scaled, train_target)print(dt.score(train_scaled, train_target)) # 0.996921300750433print(dt.score(test_scaled, test_target)) # 0.8592307692307692 0.996921300750433 0.8592307692307692 12345678# 객체지향으로 불가# 결정트리 모델import matplotlib.pyplot as pltfrom sklearn.tree import plot_treeplt.figure(figsize=(10, 7))plot_tree(dt)plt.show() /Images/0330_Decision_Tree_01/ 1234plt.figure(figsize= (10,7))plot_tree(dt, max_depth= 1, filled= True, # max_depth: 최대깊이 , filled: 색 입히는 매개변수 feature_names=['alcohol', 'sugar', 'pH'])plt.show() 가지치기 과대적합을 방지하기 위한 것 12345dt = DecisionTreeClassifier(max_depth=3, random_state=42)dt.fit(train_scaled, train_target)print(dt.score(train_scaled, train_target))print(dt.score(test_scaled, test_target))# 비슷하게 나오는 결과를 확인 할 수 있음. 0.8454877814123533 0.8415384615384616 1234from numpy.ma.core import filledplt.figure(figsize=(20, 15))plot_tree(dt, filled= True, feature_names=['alchol','sugar', 'pH'])plt.show() 1# graph.render(&quot;decision_tree_graphivz&quot;) 123456789101112131415from matplotlib.colors import ListedColormap, to_rgbimport numpy as npplt.figure(figsize=(20, 15))artists = plot_tree(dt, filled = True, feature_names = ['alcohol', 'sugar', 'pH'])colors = ['blue', 'red']for artist, impurity, value in zip(artists, dt.tree_.impurity, dt.tree_.value): r, g, b = to_rgb(colors[np.argmax(value)]) f = impurity * 2 artist.get_bbox_patch().set_facecolor((f + (1-f)*r, f + (1-f)*g, f + (1-f)*b)) artist.get_bbox_patch().set_edgecolor('black')plt.show() 마무리 정리 키워드 결정 트리: yes / no 에 대한 질무능ㄹ 이어나가면서 정답을 찾아 학습하는 알고리즘. 성능이 뛰어남. 불순도: 결정트리가 최적의 질문을 찾기 위한 기준. (사이킷런은 지니 불순도와 엔트로피 불순도를 제공) 정보이득: 부모 노드와 자식 노드의 불순도 차이 가지치기: 결정트리의 성장을 제한하는 방법 특성중요도: 결정트리에 사용된 특성이 불순도를 감소하는데 기여한 정도를 나타내는 값 Pandas 패키지 info(): 데이터프레임의 요약된 정보를 출력. 결측치가 있는지 알기위해 사용 describe(): 데이터 프레임 열의 통계 값을 제공 Scikit-learn 패키지 DecisionTreeClassifier: 결정트리 분류 클래스. 매개변수 criterion: 불순도를 지정 [default: gini] 매개변수 splitter: 노트를 분할하는 전략을 선택 [defalt: best] max_depth: 트리가 성장 할 최대 깊이를 지정 [defalt: None] min_samples_split: 노드를 나누기 위한 최소 샘플 개수 [default: 2] 매개변수 max_features: 최적의 분할을 위해 탐색 할 특성의 개수를 지정. [defalt: None] plot_tree(): 결정 트리 모델을 시각화 매개변수 max_depth: 나타낼 트리의 깊이를 지정. [defalt: None] 매개변수 feature_names: 특성의 이름을 지정 매개변수 filled: True로 지정하면 타깃값에 따라 노드 안에 색을 채움","link":"/2022/03/30/0330_Decision_Tree_01/"},{"title":"앙상블_학습_01","text":"트리의 앙상블 LightGBM ( 중요 ) GBM –&gt; XGBoost –&gt; LightGBM 참고1. 모델 개발 속도가 빨라졌나? 참고2. 모델의 성능이 좋아졌나? TabNet (2019) 딥러닝 컨셉 랜덤 포레스트(Forest) 결정 트리 나무를 500갸 심기 최종적인 결정은 투표 방식 나무 1 : 양성 나무 2 : 음성 나무 3 : 양성 … 나무 n : 양성 최종 판단 : 양성입니다! 12345678910111213import numpy as npimport pandas as pdfrom sklearn.model_selection import train_test_splitwine = pd.read_csv('https://bit.ly/wine_csv_data')data = wine[['alcohol', 'sugar', 'pH']].to_numpy()target = wine['class'].to_numpy()train_input, test_input, train_target, test_target = train_test_split(data, target, test_size=0.2, random_state=42) 267p cross_validate() 교차 검증 수행 12345678from sklearn.model_selection import cross_validatefrom sklearn.ensemble import RandomForestClassifierrf = RandomForestClassifier(n_jobs= -1, random_state=42)scores= cross_validate(rf, train_input, train_target, return_train_score= True, n_jobs= -1) # return_train_score: 훈련세트의 점수도 같이 반환됨.print(np.mean(scores['train_score']), np.mean(scores['test_score'])) 0.9973541965122431 0.8905151032797809 123rf.fit(train_input, train_target)print(rf.feature_importances_)# feature_importances_: 하나의 특성에 과도하게 집중하지 않고 좀 더 많은 특성이 훈련에 기여 [0.23167441 0.50039841 0.26792718] 12345rf= RandomForestClassifier(oob_score= True, n_jobs= -1, random_state= 42)rf.fit(train_input, train_target)print(rf.oob_score_)# oob샘플: 훈련세트에 중복을 허용하여 푸트스트랩 샘플을 만들때 포함되지 않고 남는 샘플 (=검증 세트의 역할)# oob_score_: 검증 점수와 비슷한 값을 얻을 수 있음 0.8934000384837406 그레이디언트 부스팅 이전트리의 오차를 보완하는 방식으로 사용 깊이가 얕은 트리를 사용 학습률 매개변수로 속도를 조절 단점: 속도가 느림. 123456from sklearn.ensemble import GradientBoostingClassifier # 깊이가 얕은 결정 트리를 사용gb = GradientBoostingClassifier(random_state= 42)scores= cross_validate(gb, train_input, train_target, return_train_score= True, n_jobs= -1)print(np.mean(scores['train_score']), np.mean(scores['test_score'])) 0.8881086892152563 0.8720430147331015 12345gb = GradientBoostingClassifier(n_estimators= 500, learning_rate= 0.2, random_state= 42)scores= cross_validate(gb, train_input, train_target, return_train_score= True, n_jobs= -1)print(np.mean(scores['train_score']), np.mean(scores['test_score'])) 0.9464595437171814 0.8780082549788999 123gb.fit(train_input, train_target)print(gb.feature_importances_)# 랜덤포레스트보다 일부 특성(당도)에 더 집중하는게 보임. [0.15872278 0.68010884 0.16116839] 흐름 데이터 전처리/ 시각화 기본 모형으로 전체 흐름을 설계 여러모형으로 비교 대조 교차 검증, 하이퍼 파라미터 성능 비교 … 1등하는 그날까지…?? 마무리 정리 키워드 앙상블 학습: 더 좋은 예측 결과를 만들기 위해 여러 개의 모델을 훈련하는 머신러닝 알고리즘을 말함. 랜덤 포레스트: 대표적인 결정트리ㅇ 기반의 앙상블 학습 방법으로 부트스트랩 샘플을 사용하고 랜덤하게 일부 특성을 선택하여 트리를 만드는것이 특징 엑스트라 트리: 랜덤포레스트와 비슷하게 결정 트리를 사용하여 앙상블 모델을 만들지만 부트스트랩 샘플을 사용하지 않음. 그레이디언트 부스팅: 결정트리를 연속적으로 추가하여 손실 함수를 최소화 하는 앙상블 방법 히스토그램 기반 그레이디언트 부스팅: 그레이디언트 부스팅의 속도를 개선했으ㅜ며, 안정적인 결과와 높은 성능으로 매우 인기가 높음. Scikit-learn RandomForestClassifier: 랜덤 포레스트 분류 클래스 매개변수 n_estimators: 앙상블을 구성할 트리의 개수를 지정 [defalt: 100] 매개변수 criterion: 불순도를 지정 [defalt: gini] max_depth: 트리가 성장할 최대 깊이를 지정 [defalt: None] min_samples_split: 노드를 나누기 위한 최소 샘플 개수 [defalt: 2] 메게변수 max_features: 최적의 분할을 위해 탐색할 특성의 개수를 지정 [defalt: auto](특성 개수의 제곱근) 매개변수 bootstrap: 부트스트랩 샘플을 사용할지 지정 [defalt: True] oob_score: OOB샘플을 사용하여 훈련한 모델을 평가할지 지정 [defalt: False] 매개변수 n_jobs: 병렬 실행에 사용할 CPU코어 수를 지정 [defalt: 1](-1로 지정하면 시스템에 있는 모든 코어를 사용) GrandientBoostingClassifier: 그레이디언트 부스팅 분류 클래스 매개변수 loss: 손실 함수를 지정 [defalt: deviance] 매개변수 learning_rate: 트리가 앙상블에 기여하는 정도를 조절 [defalt: 0.1] 매개변수 n_estimators: 부스팅 단계를 수행하는 트리의 개수 매개변수 subsample: 사용할 훈련 세트의 샘플 비율을 지정 [defalt: 1] 매개변수 max_depth: 개별 회귀 트리의 최대 깊이 [defalt: 3] HistGradientBoostingClassifier: 히스토그램 기반 그레이디언트 부스팅 분류 클래스 매개변수 learning_rate: 학습률 또는 감쇠율 [defalt: 0.1] max_iter: 부스팅 단계를 수행하는 트리의 개수 [defalt: 100] max_bins: 입력 데이터를 나눌 구간의 개수. [defalt: 255]","link":"/2022/03/30/0330_Ensemble_Learning01/"},{"title":"주성분_분석_01","text":"PCA중요 차원 축소의 개념 PCA개념 과일 사진의 경우, 10000개의 픽셀 (높이 * 너비) 10000개의 특성이 있는 셈(차원) 정형데이터에서도 활용 가능 문자열 데이터, 수치형 데이터 (연속형 데이터, 비연속형 데이터) 캐글 대회: 수치형 데이터 304개 연산은 RAM에서 처리 라면을 5개 끓여야하는데 냄비 크기는 3개분량의 크기인 상황 차원축소 = 일부 특성을 선택하여 데이터 크기를 줄임 머신러닝 측면: 과대적합 방지 &amp; 성능 향상 양적 데이터 사이의 분산-공분산 관계를 이용해서 선형결합으로 표시되는 주성분을 찾음 2-3개의 주성분으로 전체 변동을 찾는것이 PCA 알고리즘 구성 할 때, 필요한 데이터 픽셀 수 300* 10000개 픽셀 300 * PCA 10주성분으로 줄임 기존 1시간 걸리던게 10분으로 줄어듦 그럼에도 불구하고, 분류가 더 잘됨 PCA 클래스1!wget https://bit.ly/fruits_300_data -O fruits_300.npy --2022-03-31 06:16:41-- https://bit.ly/fruits_300_data Resolving bit.ly (bit.ly)... 67.199.248.10, 67.199.248.11 Connecting to bit.ly (bit.ly)|67.199.248.10|:443... connected. HTTP request sent, awaiting response... 301 Moved Permanently Location: https://github.com/rickiepark/hg-mldl/raw/master/fruits_300.npy [following] --2022-03-31 06:16:41-- https://github.com/rickiepark/hg-mldl/raw/master/fruits_300.npy Resolving github.com (github.com)... 140.82.114.4 Connecting to github.com (github.com)|140.82.114.4|:443... connected. HTTP request sent, awaiting response... 302 Found Location: https://raw.githubusercontent.com/rickiepark/hg-mldl/master/fruits_300.npy [following] --2022-03-31 06:16:41-- https://raw.githubusercontent.com/rickiepark/hg-mldl/master/fruits_300.npy Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.108.133, 185.199.111.133, 185.199.109.133, ... Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.108.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 3000128 (2.9M) [application/octet-stream] Saving to: ‘fruits_300.npy’ fruits_300.npy 100%[===================&gt;] 2.86M --.-KB/s in 0.02s 2022-03-31 06:16:41 (169 MB/s) - ‘fruits_300.npy’ saved [3000128/3000128] 1234567import numpy as npimport matplotlib.pyplot as pltfruits = np.load('fruits_300.npy')print(fruits.shape) # fruits: 3차원 배열fruits_2d = fruits.reshape(-1, 100*100)fruits_2d.shape # fruits_2d: 2차원 배열 (300, 100, 100) (300, 10000) sklaern.decomposition 모듈 1234from sklearn.decomposition import PCApca = PCA(n_components= 50)# PCA 50개 성분으로 300 * 10000픽셀값을 압축pca.fit(fruits_2d) PCA(n_components=50) 1print(pca.components_.shape) (50, 10000) 그래프 그리기 12345678910111213141516import matplotlib.pyplot as pltdef draw_fruits(arr, ratio=1): n = len(arr) # n은 샘플 개수입니다 # 한 줄에 10개씩 이미지를 그립니다. 샘플 개수를 10으로 나누어 전체 행 개수를 계산합니다. rows = int(np.ceil(n/10)) # 행이 1개 이면 열 개수는 샘플 개수입니다. 그렇지 않으면 10개입니다. cols = n if rows &lt; 2 else 10 fig, axs = plt.subplots(rows, cols, figsize=(cols*ratio, rows*ratio), squeeze=False) for i in range(rows): for j in range(cols): if i*10 + j &lt; n: # n 개까지만 그립니다. axs[i, j].imshow(arr[i*10 + j], cmap='gray_r') axs[i, j].axis('off') plt.show() 12# draw_fruits(fruits[km.labels_ == 0])draw_fruits(pca.components_.reshape(-1, 100, 100)) 12fruits_pca = pca.transform(fruits_2d)print(fruits_pca.shape) (300, 50) 데이터의 원래 크기 대비해서 1/200 줄임 용량이 줄었다는 것과 똑같음 원본 데이터 재구성 10000개의 특성을 50개로 줄임 100% 재구성은 어렵지만, 그래도 쓸만하다. 123# inverse_transform(): 축소시킨 데이터를 다시 복원fruits_inverse = pca.inverse_transform(fruits_pca)print(fruits_inverse.shape) (300, 10000) 12fruits_reconstruct = fruits_inverse.reshape(-1, 100, 100) # 다시 3차원으로 재배열print(fruits_reconstruct.shape) (300, 100, 100) 123for start in [0, 100, 200]: draw_fruits(fruits_reconstruct[start:start+100]) print(&quot;\\n&quot;) 1234567891011121314151617# ## 주성분을 2개로 지정했을때 나오는 형태# pca = PCA(n_components= 2)# pca.fit(fruits_2d)# fruits_pca = pca.transform(fruits_2d)# # print(fruits_pca.shape)# fruits_inverse = pca.inverse_transform(fruits_pca)# # print(fruits_inverse.shape)# fruits_reconstruct = fruits_inverse.reshape(-1, 100, 100)# # print(fruits_reconstruct.shape)# for start in [0, 100, 200]:# draw_fruits(fruits_reconstruct[start:start+100])# print(&quot;\\n&quot;) 설명된 분산123# explained_variance_ratio_: 분산의 비율plt.plot(pca.explained_variance_ratio_)plt.show() 처음 10개의 주성분이 대부분의 분산을 표현한다. 11개 주성분부터 ~50개까지는 잘 설명이 안됨. 12# 92퍼센트정도 설명이 가능하다는걸 확인print(np.sum(pca.explained_variance_ratio_)) 0.9215689086016662 다른 알고리즘과 함께 사용하기 3개의 과일 사진 분류 위해 로지스틱 회귀 123456from sklearn.linear_model import LogisticRegressionlr = LogisticRegression()target = np.array([0]* 100 + [1]* 100 + [2]* 100)print(target) [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2] 1234from sklearn.model_selection import cross_validatescores = cross_validate(lr, fruits_2d, target)print(np.mean(scores['test_score']))print(np.mean(scores['fit_time'])) 0.9966666666666667 1.3491935729980469 1234# PCA 수행 후, 학습 시간 비교scores = cross_validate(lr, fruits_pca, target)print(np.mean(scores['test_score']))print(np.mean(scores['fit_time'])) 1.0 0.023451614379882812 주성분의 매개변수 개수 지정, 분산 비율 지정 123pca = PCA(n_components= 0.5)pca.fit(fruits_2d)print(pca.n_components_) 2 주성분을 2개로 압축 12fruits_pca = pca.transform(fruits_2d)print(fruits_pca.shape) (300, 2) 123scores = cross_validate(lr, fruits_pca, target)print(np.mean(scores['test_score']))print(np.mean(scores['fit_time'])) 0.9933333333333334 0.03700056076049805 /usr/local/lib/python3.7/dist-packages/sklearn/linear_model/_logistic.py:818: ConvergenceWarning: lbfgs failed to converge (status=1): STOP: TOTAL NO. of ITERATIONS REACHED LIMIT. Increase the number of iterations (max_iter) or scale the data as shown in: https://scikit-learn.org/stable/modules/preprocessing.html Please also refer to the documentation for alternative solver options: https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression extra_warning_msg=_LOGISTIC_SOLVER_CONVERGENCE_MSG, /usr/local/lib/python3.7/dist-packages/sklearn/linear_model/_logistic.py:818: ConvergenceWarning: lbfgs failed to converge (status=1): STOP: TOTAL NO. of ITERATIONS REACHED LIMIT. Increase the number of iterations (max_iter) or scale the data as shown in: https://scikit-learn.org/stable/modules/preprocessing.html Please also refer to the documentation for alternative solver options: https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression extra_warning_msg=_LOGISTIC_SOLVER_CONVERGENCE_MSG, /usr/local/lib/python3.7/dist-packages/sklearn/linear_model/_logistic.py:818: ConvergenceWarning: lbfgs failed to converge (status=1): STOP: TOTAL NO. of ITERATIONS REACHED LIMIT. Increase the number of iterations (max_iter) or scale the data as shown in: https://scikit-learn.org/stable/modules/preprocessing.html Please also refer to the documentation for alternative solver options: https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression extra_warning_msg=_LOGISTIC_SOLVER_CONVERGENCE_MSG, 1234from sklearn.cluster import KMeanskm = KMeans(n_clusters=3, random_state=42)km.fit(fruits_pca)print(np.unique(km.labels_, return_counts=True)) (array([0, 1, 2], dtype=int32), array([110, 99, 91])) 123for label in range(0, 3): draw_fruits(fruits[km.labels_== label]) print(&quot;/n&quot;) /n /n /n 12345for label in range(0, 3): data = fruits_pca[km.labels_== label] plt.scatter(data[:, 0], data[:, 1])plt.legend(['apple', 'banana', 'pineapple'])plt.show() 마무리 정리 키워드 차원 축소: 원본 데이터의 특성을 적은 수의 새로운 특성으로 변환하는 비지도 학습의 한 종류. 저장공간을 줄이고 시각화 하기 쉽다. 다른 알고리즘의 성능을 높임. 주성분 분석: 차원 축소의 알고리즘의 하나로 데이터에서 가장 분산이 큰 방향을 찾는 방법 설명된 분석: 주성분 분석에서 주성분이 얼마나 원본 데이터의 분산을 잘 나타내는지 기록한것 Scikit-learn 패키지 PCA: 주성분 분석을 수행하는 클래스 n_components: 주성분의 개수를 지정 [default: None](샘플 개수와 특성 개수중에서 작은 것의 값을 사용) random_state: 넘파이 난수 시드값을 지정 속성 components_: 훈련세트에서 찾은 주성분이 저장 속성 explained_variance_ : 설명된 분산이 저장 속성 explained_variance_ratio_: 설명된 분산의 비율이 저장 inverse_transform(): transfrom()메서드로 차원을 축소시킨 데이터를 다시 원본 차원으로 복원함.","link":"/2022/03/31/0331_Principar_Component_Analysis_01/"},{"title":"비지도_학습_01","text":"비지도 학습 vs 지도학습 종속변수 = 타겟 비짇 학습은 종속변수 및 타겟이 없음 분류 다중분류 전제조건이 (다양한 유형) 데이터가 많아야 함 딥러닝과 연관이 됨 (자연어 처리, 이미지) 데이터 불러오기1!wget https://bit.ly/fruits_300_data -O fruits_300.npy --2022-03-31 01:10:43-- https://bit.ly/fruits_300_data Resolving bit.ly (bit.ly)... 67.199.248.11, 67.199.248.10 Connecting to bit.ly (bit.ly)|67.199.248.11|:443... connected. HTTP request sent, awaiting response... 301 Moved Permanently Location: https://github.com/rickiepark/hg-mldl/raw/master/fruits_300.npy [following] --2022-03-31 01:10:43-- https://github.com/rickiepark/hg-mldl/raw/master/fruits_300.npy Resolving github.com (github.com)... 140.82.112.3 Connecting to github.com (github.com)|140.82.112.3|:443... connected. HTTP request sent, awaiting response... 302 Found Location: https://raw.githubusercontent.com/rickiepark/hg-mldl/master/fruits_300.npy [following] --2022-03-31 01:10:43-- https://raw.githubusercontent.com/rickiepark/hg-mldl/master/fruits_300.npy Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.108.133, 185.199.109.133, 185.199.110.133, ... Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.108.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 3000128 (2.9M) [application/octet-stream] Saving to: ‘fruits_300.npy’ fruits_300.npy 100%[===================&gt;] 2.86M --.-KB/s in 0.01s 2022-03-31 01:10:43 (210 MB/s) - ‘fruits_300.npy’ saved [3000128/3000128] numpy 파일을 불러옴 123456import numpy as npimport matplotlib.pyplot as pltfruits = np.load('fruits_300.npy')print(fruits.shape)print(fruits.ndim) (300, 100, 100) 3 첫번째 차원 = 샘플의 개수 두번째 차원 = 이미지 높이 세번째 차원 = 이미지 넓이 이미지 크기 100 * 100 1fruits[0, 0, :] array([ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 2, 1, 2, 1, 1, 1, 1, 2, 1, 3, 2, 1, 3, 1, 4, 1, 2, 5, 5, 5, 19, 148, 192, 117, 28, 1, 1, 2, 1, 4, 1, 1, 3, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=uint8) 이미지 시각화 흑백사진을 담고 있다. 0 ~ 255까지의 정수값을 가진다. 0에 가까우면 검게 나타남 255에 가까우면 밝게 나타남 12plt.imshow(fruits[0], cmap= 'gray')plt.show() /Images/0331_Unsupervised_Learning 123# cmap = 'gray_r' 일 경우 반대로 나타남plt.imshow(fruits[0], cmap= 'gray_r')plt.show() 여러 이미지 시각화 12345fig, axs = plt.subplots(1, 2)axs[0].imshow(fruits[100], cmap= 'gray_r')axs[1].imshow(fruits[200], cmap= 'gray_r')plt.show() 픽셀값 분석12345apple = fruits[0: 100].reshape(-1, 100 * 100)pineapple = fruits[100: 200].reshape(-1, 100 * 100)banana = fruits[200: 300].reshape(-1, 100 * 100)print(apple.shape, banana.shape, pineapple.shape) (100, 10000) (100, 10000) (100, 10000) axis = 0 vs axis = 1 차이 확인(p,293) 각 이미지에 대한 픽셀 평균값 비교 12# axis= 1 : 행 기준print(apple.mean(axis= 1)) [ 88.3346 97.9249 87.3709 98.3703 92.8705 82.6439 94.4244 95.5999 90.681 81.6226 87.0578 95.0745 93.8416 87.017 97.5078 87.2019 88.9827 100.9158 92.7823 100.9184 104.9854 88.674 99.5643 97.2495 94.1179 92.1935 95.1671 93.3322 102.8967 94.6695 90.5285 89.0744 97.7641 97.2938 100.7564 90.5236 100.2542 85.8452 96.4615 97.1492 90.711 102.3193 87.1629 89.8751 86.7327 86.3991 95.2865 89.1709 96.8163 91.6604 96.1065 99.6829 94.9718 87.4812 89.2596 89.5268 93.799 97.3983 87.151 97.825 103.22 94.4239 83.6657 83.5159 102.8453 87.0379 91.2742 100.4848 93.8388 90.8568 97.4616 97.5022 82.446 87.1789 96.9206 90.3135 90.565 97.6538 98.0919 93.6252 87.3867 84.7073 89.1135 86.7646 88.7301 86.643 96.7323 97.2604 81.9424 87.1687 97.2066 83.4712 95.9781 91.8096 98.4086 100.7823 101.556 100.7027 91.6098 88.8976] 각 과일에 대한 히스토그램 1234567891011121314fig, ax = plt.subplots()# ax.hist(np.mean(apple, axis= 1), alpha= 0.8)# ax.hist(np.mean(banana, axis= 1), alpha= 0.8)# ax.hist(np.mean(pineapple, axis= 1), alpha= 0.8)ax.hist(apple.mean(axis= 1), alpha= 0.8)ax.hist(pineapple.mean(axis= 1), alpha= 0.8)ax.hist(banana.mean(axis= 1), alpha= 0.8)# ax.hist(np.mean(apple, axis= 0), alpha= 0.8)# ax.hist(np.mean(banana, axis= 0), alpha= 0.8)# ax.hist(np.mean(pineapple, axis= 0), alpha= 0.8)ax.legend(['apple', 'pineapple', 'banana'])plt.show() 1234567891011fig, ax = plt.subplots()# ax.hist(np.mean(apple, axis= 1), alpha= 0.8)# ax.hist(np.mean(banana, axis= 1), alpha= 0.8)# ax.hist(np.mean(pineapple, axis= 1), alpha= 0.8)ax.hist(np.mean(apple, axis= 0), alpha= 0.8)ax.hist(np.mean(banana, axis= 0), alpha= 0.8)ax.hist(np.mean(pineapple, axis= 0), alpha= 0.8)ax.legend(['apple', 'pineapple', 'banana'])plt.show() 12345fig, axs = plt.subplots(1, 3, figsize= (20, 5))axs[0].bar(range(10000), np.mean(apple, axis= 0))axs[1].bar(range(10000), np.mean(pineapple, axis= 0))axs[2].bar(range(10000), np.mean(banana, axis= 0))plt.show() 대표 이미지 12345678910apple_mean = np.mean(apple, axis= 0).reshape(100, 100)pineapple_mean = np.mean(pineapple, axis= 0).reshape(100, 100)banana_mean = np.mean(banana, axis= 0).reshape(100, 100)fig, axs = plt.subplots(1, 3, figsize= (20, 5))axs[0].imshow(apple_mean, cmap= 'gray_r')axs[1].imshow(pineapple_mean, cmap= 'gray_r')axs[2].imshow(banana_mean, cmap= 'gray_r')# axs[3].imshow(apple_mean, cmap= 'gray_r')plt.show() 평균값과 가까운 사진 고르기123abs_diff = np.abs(fruits- apple_mean)abs_mean = np.mean(abs_diff, axis=(1, 2))print(abs_mean.shape) (300,) 오차의 값이 가장 작은 순서대로 100개를 골라본다. 1234567apple_index = np.argsort(abs_mean)[:100]fig, axs= plt.subplots(10, 10, figsize= (10, 10))for i in range(10): for j in range(10): axs[i, j].imshow(fruits[apple_index[i*10 + j]], cmap= 'gray_r') # imshow(): 크기에 맞게 이미지 출력 axs[i, j].axis('off') # 축 지우기plt.show() 12345678fig, axs = plt.subplots(2, 3, figsize=(6, 4))# axs[0].imshow(apple_mean, cmap= 'gray_r') # axs[1].imshow(pineapple_mean, cmap= 'gray_r')# axs[2].imshow(banana_mean, cmap= 'gray_r')plt.show()# fig, axs = plt.subplots()# plt.show() 마무리 정리 키워드 비지도 학습: 머신러닝의 한 종류로 훈련 데이터에 타깃이 없음. 타깃이 없기 때문에 외부의 도움 없이 스스로 유용한 무언가를 학습해야함. 히스토그램: 구간별로 값이 발생한 빈도를 그래프로 표시 군집: 비슷한 샘플끼리 하나의 그룹으로 모으는 대표적인 비지도 학습 작업","link":"/2022/03/31/0331_Unsupervised_Learning/"},{"title":"K-평균_01","text":"K-평균 각각의 픽셀값 (3차원 -&gt; 1차원 배열) 평균 구함 픽셀의 평균값을 활용해서 사과, 바나나, 파인애플에 근사한 이미지를 추출하는 것 어떻게 평균값을 구할 수 있을까? K-평균 알고리즘(K-Means) 알고리즘 평균값 = Cluster Center = Centroid 1!wget https://bit.ly/fruits_300_data -O fruits_300.npy --2022-03-31 02:14:27-- https://bit.ly/fruits_300_data Resolving bit.ly (bit.ly)... 67.199.248.11, 67.199.248.10 Connecting to bit.ly (bit.ly)|67.199.248.11|:443... connected. HTTP request sent, awaiting response... 301 Moved Permanently Location: https://github.com/rickiepark/hg-mldl/raw/master/fruits_300.npy [following] --2022-03-31 02:14:27-- https://github.com/rickiepark/hg-mldl/raw/master/fruits_300.npy Resolving github.com (github.com)... 140.82.114.3 Connecting to github.com (github.com)|140.82.114.3|:443... connected. HTTP request sent, awaiting response... 302 Found Location: https://raw.githubusercontent.com/rickiepark/hg-mldl/master/fruits_300.npy [following] --2022-03-31 02:14:28-- https://raw.githubusercontent.com/rickiepark/hg-mldl/master/fruits_300.npy Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.108.133, 185.199.109.133, 185.199.110.133, ... Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.108.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 3000128 (2.9M) [application/octet-stream] Saving to: ‘fruits_300.npy’ fruits_300.npy 100%[===================&gt;] 2.86M --.-KB/s in 0.07s 2022-03-31 02:14:28 (43.0 MB/s) - ‘fruits_300.npy’ saved [3000128/3000128] 1234567import numpy as npimport matplotlib.pyplot as pltfruits = np.load('fruits_300.npy')print(fruits.shape)print(fruits.ndim) # ndim: n차원인지 알아냄# print(fruits[:5]) (300, 100, 100) 3 3차원 (샘플개수, 넓이, 높이) 2차원 (샘플개수, 넓이* 높이) 12fruits_2d = fruits.reshape(-1, 100* 100)fruits_2d.shape (300, 10000) K-평균 알고리즘 활용 123from sklearn.cluster import KMeanskm = KMeans(n_clusters= 3, random_state= 42)km.fit(fruits_2d) KMeans(n_clusters=3, random_state=42) 모형학습 후, labels 확인 1print(km.labels_) [2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 2 0 2 2 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 0 0 2 2 2 2 2 2 2 2 0 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1] 직접 샘플의 개수 확인 1print(np.unique(km.labels_, return_counts= True)) (array([0, 1, 2], dtype=int32), array([111, 98, 91])) 그래프를 그려본다. 12345678910111213141516import matplotlib.pyplot as pltdef draw_fruits(arr, ratio=1): n = len(arr) # n은 샘플 개수입니다 # 한 줄에 10개씩 이미지를 그립니다. 샘플 개수를 10으로 나누어 전체 행 개수를 계산합니다. rows = int(np.ceil(n/10)) # 행이 1개 이면 열 개수는 샘플 개수입니다. 그렇지 않으면 10개입니다. cols = n if rows &lt; 2 else 10 fig, axs = plt.subplots(rows, cols, figsize=(cols*ratio, rows*ratio), squeeze=False) for i in range(rows): for j in range(cols): if i*10 + j &lt; n: # n 개까지만 그립니다. axs[i, j].imshow(arr[i*10 + j], cmap='gray_r') axs[i, j].axis('off') plt.show() 1draw_fruits(fruits[km.labels_ == 0]) 크러스터 중심1draw_fruits(km.cluster_centers_.reshape(-1, 100, 100), ratio= 3) 1print(km.transform(fruits_2d[100:101])) [[3393.8136117 8837.37750892 5267.70439881]] 1print(km.predict(fruits_2d[100:101])) [0] 1draw_fruits(fruits[100:101]) 최적의 K 찾기12345678# inertia= []# for k in range(2,7):# km= KMeans(n_clusters= k, random_state= 42)# km.fit(fruits_2d)# inertia.append(km.inertia_)# plt.plot(range(2,7), inertia)# plt.show() 12345678910inertia= []for k in range(2,7): km= KMeans(n_clusters= k, random_state= 42) km.fit(fruits_2d) inertia.append(km.inertia_)fig, ax = plt.subplots()ax.plot(range(2,7), inertia)plt.show() 마무리 정리 키워드 K-평균: 처음에 랜덤하게 클러스터 중심을 정하고 클러스터를 만듬. 그 후에 클러스터의 중심을 이동하고 다시 클러스터를 만드는 식으로 반복해서 최적의 클러스터를 구성하는 알고리즘. 클러스터 중심: K-평균 알고리즘이 만든 클러스터에 속한 샘플의 특성 평균값. 센트로이드라고도 부름 엘보우 방법: 최적의 클러스터 개수를 정하는 방법 중 하나 Scikit-Learn 패키지 KMeans: K-평균 알고리즘 클래스 n_clusters: 클러스터 개수를 지정. [default: 8] n_init: 반복 횟수를 지정. [default: 10] max_iter: K-평균 알고리즘의 한 번 실행에서 최적의 센트로이드를 찾기 위해 반복 할 수 있는 최대 횟수. [default: 200]","link":"/2022/03/31/0331_K_Means_01/"},{"title":"인공 신경망","text":"인공 신경망딥러닝 라이브러리 텐서플로 : https://www.tensorflow.org/ 2016년 텐서플로 1 버전 vs 텐서플로 2 버전 문법적으로 매우 다름 산업용 파이토치 : https://pytorch.org/ 연구용 패션 MNIST 데이터 이용데이터 불러오기12import tensorflowprint(tensorflow.__version__) 2.8.0 12from tensorflow import keras(train_input, train_target), (test_input, test_target) = keras.datasets.fashion_mnist.load_data() 데이터 확인 60000개 이미지, 이미지 크기는 28 * 28 12print(train_input.shape, train_target.shape) # input= 사진 # target= 0~9의 타겟값print(test_input.shape, test_target.shape) (60000, 28, 28) (60000,) (10000, 28, 28) (10000,) 이미지 시각화 123456import matplotlib.pyplot as pltfig, axs= plt.subplots(1, 10, figsize=(10,10))for i in range(10): axs[i].imshow(train_input[i], cmap='gray_r') axs[i].axis('off')plt.show() 타겟값 리스트 1print([train_target[i] for i in range(10)]) [9, 0, 0, 3, 0, 2, 7, 2, 5, 5] 실제 타겟값의 값을 확인 12import numpy as npprint(np.unique(train_target, return_counts= True)) (array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=uint8), array([6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000])) 로지스틱 회귀로 패션 아이템 분류하기 경사하강법(기울기) 전제조건: 각 컬럼의 데이터셋 동일 (표준화) why 255? : 각 픽셀의 값 0 ~ 255 사이의 정숫값을 가진다. 0 ~ 1 사이의 값으로 정규화 시킴 12345train_scaled = train_input/ 255.0# 1차원 배열로 만들기train_scaled = train_scaled.reshape(-1, 28* 28)print(train_scaled.shape) (60000, 784) 1234567from sklearn.model_selection import cross_validatefrom sklearn.linear_model import SGDClassifiersc = SGDClassifier(loss='log', max_iter=5, random_state=42)scores = cross_validate(sc, train_scaled, train_target, n_jobs=-1)print(np.mean(scores['test_score'])) 0.8195666666666668 모델 만들기 비정형데이터에 선형모델 또는 비선형 모델을 적용시키는것이 합리적인가?? 결론: 아니다! 다른 대안은 있는가??: 인공신경망! 정형데이터에 인공신경망 및 딥러닝 모델을 적용시키는 것이 합리적인가 결론: 아니다! 인공신경망 모델 적용12345678910import tensorflow as tffrom tensorflow import kerasfrom sklearn.model_selection import train_test_splittrain_scaled, val_scaled, train_target, val_target = train_test_split( train_scaled, train_target, test_size=0.2, random_state=42)print(train_scaled.shape, train_target.shape)print(val_scaled.shape, val_target.shape) (48000, 784) (48000,) (12000, 784) (12000,) 다중분류의 상황이기에 소프트맥스 활성화 함수를 사용 이진분류에는 시그모이드 함수(로지스틱 회귀) 1234567# 모델 정의dense = keras.layers.Dense(10, activation= 'softmax', input_shape=(784, ))model = keras.Sequential(dense)model.compile(loss= 'sparse_categorical_crossentropy', metrics= 'accuracy')# train데이터로 모델 훈련model.fit(train_scaled, train_target, epochs= 5) Epoch 1/5 1500/1500 [==============================] - 2s 1ms/step - loss: 0.6102 - accuracy: 0.7926 Epoch 2/5 1500/1500 [==============================] - 2s 1ms/step - loss: 0.4791 - accuracy: 0.8392 Epoch 3/5 1500/1500 [==============================] - 2s 2ms/step - loss: 0.4554 - accuracy: 0.8481 Epoch 4/5 1500/1500 [==============================] - 2s 1ms/step - loss: 0.4453 - accuracy: 0.8519 Epoch 5/5 1500/1500 [==============================] - 2s 2ms/step - loss: 0.4363 - accuracy: 0.8558 &lt;keras.callbacks.History at 0x7f04ab0dcc50&gt; 123# val데이터로 모델 훈련# evaluate()메서드도 fit()메서드와 비슷한 출력을 보여줌.model.evaluate(val_scaled, val_target) 375/375 [==============================] - 1s 3ms/step - loss: 0.4559 - accuracy: 0.8462 [0.45591267943382263, 0.8462499976158142] 마무리 정리 키워드 인공신경망(=딥러닝): 생물학적 뉴런에서 영감을 받아 만든 머신러닝 알고리즘 텐서플로: 구글이 만든 딥러닝 라이브러리. 케라스를 사용하면 간단한 모델에서 아주 복잡한 모델까지 손쉽게 만들 수 있다. 케라스: 텐서플로에서 제공하는 고수준 API. 2015년에 개발된 딥러닝 라이브러리 입력층: 처음 입력되는 모든 input데이터 밀집층: 가장 간단한 인공 신경망의 층 출력층: 신경망의 최종 값을 만드는 층 완전 연결층(Fully Connected Layer) : 양쪽의 뉴런이 모두 연결하고 있는 층 뉴런(=유닛): 값을 계산하는 단위 원-핫 인코딩: 정숫값을 배열에서 해당 정수 위치의 원소만 1이고 나머지는 모두 0으로 변환 TensorFlow 패키지 Dense: 신경망에서 가장 기본 층인 밀집층을 만드는 클래스 매개변수 units: 첫번째 매개변수로 뉴런의 개수를 지정 매개변수 activation: 사용할 활성화 함수를 지정. 이진분류일때는 ‘sigmooid’, 다중분류일때는 ‘softmax’나 ‘relu’를 사용 Sequential: 케라스에서 신경망 모델을 만드는 클래스 Compile(): 모델 객체를 만든 후 훈련하기 전에 사용할 손실 함수와 측정 지표 등을 지정하는 메서드 fit(): 모델을 훈련하는 메서드 evaluate(): 모델 성능을 평가하는 메서드","link":"/2022/04/04/0404_Artificial_Neural_Network/"},{"title":"심층 신경망","text":"심증 신경망123from tensorflow import keras(train_input, train_target), (test_input, test_target) = keras.datasets.fashion_mnist.load_data() 1234567from sklearn.model_selection import train_test_splittrain_scaled = train_input / 255.0 # 0 ~ 255의 픽셀값을 0~1로 변환train_scaled = train_scaled.reshape(-1, 28*28) # 2차원 배열을 1차원 배열로 변환train_scaled, val_scaled, train_target, val_target = train_test_split( train_scaled, train_target, test_size=0.2, random_state=42) 심층 신경망 만들기 입력값 및 출력값 층 만들기 12dense1 = keras.layers.Dense(100, activation='sigmoid', input_shape=(784,))dense2 = keras.layers.Dense(10, activation='softmax') 12model = keras.Sequential([dense1, dense2])model.summary() Model: &quot;sequential_7&quot; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= dense_14 (Dense) (None, 100) 78500 dense_15 (Dense) (None, 10) 1010 ================================================================= Total params: 79,510 Trainable params: 79,510 Non-trainable params: 0 _________________________________________________________________ 층을 추가하는 다른 방법12345# 직관적이게 한 줄로 적는 방법model = keras.Sequential([ keras.layers.Dense(100, activation='sigmoid', input_shape=(784,), name='hidden'), keras.layers.Dense(10, activation='softmax', name='output')], name='패션 MNIST 모델') 1model.summary() Model: &quot;패션 MNIST 모델&quot; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= hidden (Dense) (None, 100) 78500 output (Dense) (None, 10) 1010 ================================================================= Total params: 79,510 Trainable params: 79,510 Non-trainable params: 0 _________________________________________________________________ 1234# add()함수를 이용해 층을 추가하는 방법model = keras.Sequential()model.add(keras.layers.Dense(100, activation='sigmoid', input_shape=(784,)))model.add(keras.layers.Dense(10, activation='softmax')) 1model.summary() Model: &quot;sequential_8&quot; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= dense_16 (Dense) (None, 100) 78500 dense_17 (Dense) (None, 10) 1010 ================================================================= Total params: 79,510 Trainable params: 79,510 Non-trainable params: 0 _________________________________________________________________ - 은닉층의 layer 수: 785 * 100 - 결과층의 layer 수: (100 * 10) + 10 으로 추정됨. 123model.compile(loss='sparse_categorical_crossentropy', metrics='accuracy')model.fit(train_scaled, train_target, epochs=5) Epoch 1/5 1500/1500 [==============================] - 4s 2ms/step - loss: 0.5608 - accuracy: 0.8098 Epoch 2/5 1500/1500 [==============================] - 3s 2ms/step - loss: 0.4056 - accuracy: 0.8525 Epoch 3/5 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3716 - accuracy: 0.8661 Epoch 4/5 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3491 - accuracy: 0.8735 Epoch 5/5 1500/1500 [==============================] - 4s 3ms/step - loss: 0.3319 - accuracy: 0.8800 &lt;keras.callbacks.History at 0x7f47a719add0&gt; 층이 많은 심층 신경망일수록 학습을 어렵게 만들어 relu함수를 이용함. 도출되는 확률값이 0이거나 음수이면 0을 출력. Flatten 클래스: 배치 차원을 제외하고 나머지 입력 차원을 모두 일렬로 펼치는 역할. Flatten층을 생성 1234model = keras.Sequential()model.add(keras.layers.Flatten(input_shape=(28, 28)))model.add(keras.layers.Dense(100, activation='relu'))model.add(keras.layers.Dense(10, activation='softmax')) 1model.summary() Model: &quot;sequential_9&quot; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= flatten_1 (Flatten) (None, 784) 0 dense_18 (Dense) (None, 100) 78500 dense_19 (Dense) (None, 10) 1010 ================================================================= Total params: 79,510 Trainable params: 79,510 Non-trainable params: 0 _________________________________________________________________ 옵티마이저 대체로 Adam을 사용하면 됨. 이유: 스텝 방향 &amp; 스템 사이즈를 모두 고려한 옵티마이저 스텝 방향만 고려: GD, SGD, Momentum, NAG 스템 사이즈만 고려: GD, SGD, Adagrad, RMSProp 오류 방지용 base 123456(train_input, train_target), (test_input, test_target) = keras.datasets.fashion_mnist.load_data()train_scaled = train_input / 255.0train_scaled, val_scaled, train_target, val_target = train_test_split( train_scaled, train_target, test_size=0.2, random_state=42) 12model.compile(loss='sparse_categorical_crossentropy', metrics='accuracy')model.fit(train_scaled, train_target, epochs=5) Epoch 1/5 1500/1500 [==============================] - 5s 3ms/step - loss: 0.5277 - accuracy: 0.8145 Epoch 2/5 1500/1500 [==============================] - 4s 3ms/step - loss: 0.3914 - accuracy: 0.8606 Epoch 3/5 1500/1500 [==============================] - 7s 5ms/step - loss: 0.3551 - accuracy: 0.8724 Epoch 4/5 1500/1500 [==============================] - 5s 3ms/step - loss: 0.3351 - accuracy: 0.8807 Epoch 5/5 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3198 - accuracy: 0.8857 &lt;keras.callbacks.History at 0x7f47a7af6e10&gt; 1model.evaluate(val_scaled, val_target) 375/375 [==============================] - 1s 1ms/step - loss: 0.3423 - accuracy: 0.8812 [0.3422880470752716, 0.8811666369438171] 옵티마이저 실습 1model.compile(optimizer='sgd', loss='sparse_categorical_crossentropy', metrics='accuracy') 12sgd = keras.optimizers.SGD()model.compile(optimizer=sgd, loss='sparse_categorical_crossentropy', metrics='accuracy') 1234# 학습률 지정sgd = keras.optimizers.SGD(learning_rate= 0.1)# 모멘텀 최적화: 0보다 큰 값으로 지정하면 경사하강법을 가속도처럼 사용sgd = keras.optimizers.SGD(momentum= 0.9, nesterov= True) 12345# 적응적 학습률: 모델이 최적점에 가까이 갈수록 학습률을 낯추어, 안정적으로 최적점에 수렴 할 가능성이 높음.# 'adagrad' 를 이용adagrad =keras.optimizers.Adagrad()model.compile(optimizer= adagrad, loss= 'sparse_categoriacl_crossentropy', metrics= 'accuracy') 12345# 적응적 학습률# 'RMSprop' 을 이용rmsprop =keras.optimizers.RMSprop()model.compile(optimizer= rmsprop, loss= 'sparse_categoriacl_crossentropy', metrics= 'accuracy') 123456789# 모멘텀 최적화와 RMSprop의 장점을 접목한것이 Adammodel = keras.Sequential()model.add(keras.layers.Flatten(input_shape= (28, 28)))model.add(keras.layers.Dense(100, activation= 'relu'))model.add(keras.layers.Dense(10, activation= 'softmax'))model.compile(optimizer= 'adam', loss='sparse_categorical_crossentropy', metrics='accuracy')model.fit(train_scaled, train_target, epochs=5) Epoch 1/5 1500/1500 [==============================] - 3s 2ms/step - loss: 0.5213 - accuracy: 0.8182 Epoch 2/5 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3931 - accuracy: 0.8588 Epoch 3/5 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3477 - accuracy: 0.8730 Epoch 4/5 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3233 - accuracy: 0.8807 Epoch 5/5 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3053 - accuracy: 0.8876 &lt;keras.callbacks.History at 0x7f47a7af2a10&gt; 1model.evaluate(val_scaled, val_target) 375/375 [==============================] - 1s 1ms/step - loss: 0.3386 - accuracy: 0.8772 [0.33857372403144836, 0.8771666884422302] 마무리 정리 키워드 심층 신경망: 2개 이상의 층을 포함한 신경망. 종종 다층 인공 신경망, 심층 신경망, 딥러닝을 같은 의미로 사용 은닉층: 입력층과 출력층 사이에 있는 모든 층 렐루 함수: 이미지 분류 모델의 은닉층을 많이 사용하는 활성화 함수 옵티마이저: 신경망의 가중치와 절편을 학습하기 위한 알고리즘 또는 방법 TensorFlow 패키지 add(): 케라스 모델에 층을 추가하는 메서드 summary(): 케라스 모델의 정보를 출력 SGD: 기본 경사 하강법 옵티마이저 클래스 Adagrad: Adagrad 옵티마이저 클래스 RMSprop: RMSprop옵티마이저 클래스 Adam: Adam옵티마이저 클래스","link":"/2022/04/04/0404_Deep_Neural_Network/"},{"title":"신경망_모델_훈련","text":"신경망 모델 훈련손실곡선12345678910from tensorflow import kerasfrom sklearn.model_selection import train_test_split(train_input, train_target), (test_input, test_target) = \\ keras.datasets.fashion_mnist.load_data()train_scaled = train_input / 255.0train_scaled, val_scaled, train_target, val_target = train_test_split( train_scaled, train_target, test_size=0.2, random_state=42) 사용자 정의 함수를 작성 1234567891011def model_fn(a_layer=None): model = keras.Sequential() model.add(keras.layers.Flatten(input_shape=(28, 28))) model.add(keras.layers.Dense(100, activation='relu')) if a_layer: model.add(a_layer) model.add(keras.layers.Dense(10, activation='softmax')) return modelmodel = model_fn()model.summary() Model: &quot;sequential&quot; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= flatten (Flatten) (None, 784) 0 dense (Dense) (None, 100) 78500 dense_1 (Dense) (None, 10) 1010 ================================================================= Total params: 79,510 Trainable params: 79,510 Non-trainable params: 0 _________________________________________________________________ 모델 정의 후, 학습 12model.compile(loss='sparse_categorical_crossentropy', metrics= 'accuracy')history = model.fit(train_scaled, train_target, epochs=5, verbose= 1) Epoch 1/5 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3084 - accuracy: 0.8907 Epoch 2/5 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2963 - accuracy: 0.8947 Epoch 3/5 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2866 - accuracy: 0.8985 Epoch 4/5 1500/1500 [==============================] - 4s 3ms/step - loss: 0.2826 - accuracy: 0.9015 Epoch 5/5 1500/1500 [==============================] - 4s 3ms/step - loss: 0.2754 - accuracy: 0.9037 history 객체 무슨 값이 있나?? 1print(history.history.keys()) dict_keys(['loss', 'accuracy']) 그래프 작성 123456import matplotlib.pyplot as pltplt.plot(history.history['loss'])plt.xlabel('epoch')plt.ylabel('loss')plt.show() 정확도 출력 1234plt.plot(history.history['accuracy'])plt.xlabel('epoch')plt.ylabel('accuracy')plt.show() 손실그래프 12345678model = model_fn()model.compile(loss='sparse_categorical_crossentropy', metrics='accuracy')history = model.fit(train_scaled, train_target, epochs=20, verbose=0)plt.plot(history.history['loss'])plt.xlabel('epoch')plt.ylabel('loss')plt.show() 검증 손실 12345678910# # 중요# history = model.fit(train_scaled, train_target, epochs=10, verbose=1, # validation_data=(val_scaled, val_target))# plt.plot(history.history['loss'])# plt.plot(history.history['val_loss'])# plt.xlabel('epoch')# plt.ylabel('loss')# plt.legend(['train', 'val'])# plt.show() 123456789101112model = model_fn()model.compile(loss='sparse_categorical_crossentropy', metrics='accuracy')history = model.fit(train_scaled, train_target, epochs=10, verbose=1, validation_data=(val_scaled, val_target))plt.plot(history.history['loss'])plt.plot(history.history['val_loss'])plt.xlabel('epoch')plt.ylabel('loss')plt.legend(['train', 'val'])plt.show() Epoch 1/10 1500/1500 [==============================] - 4s 2ms/step - loss: 0.5272 - accuracy: 0.8130 - val_loss: 0.4003 - val_accuracy: 0.8572 Epoch 2/10 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3944 - accuracy: 0.8576 - val_loss: 0.3871 - val_accuracy: 0.8617 Epoch 3/10 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3568 - accuracy: 0.8729 - val_loss: 0.3542 - val_accuracy: 0.8726 Epoch 4/10 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3324 - accuracy: 0.8805 - val_loss: 0.3576 - val_accuracy: 0.8765 Epoch 5/10 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3198 - accuracy: 0.8861 - val_loss: 0.3562 - val_accuracy: 0.8795 Epoch 6/10 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3072 - accuracy: 0.8910 - val_loss: 0.3875 - val_accuracy: 0.8758 Epoch 7/10 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2966 - accuracy: 0.8956 - val_loss: 0.3722 - val_accuracy: 0.8764 Epoch 8/10 1500/1500 [==============================] - 4s 2ms/step - loss: 0.2872 - accuracy: 0.8982 - val_loss: 0.3690 - val_accuracy: 0.8783 Epoch 9/10 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2840 - accuracy: 0.8990 - val_loss: 0.3649 - val_accuracy: 0.8838 Epoch 10/10 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2745 - accuracy: 0.9041 - val_loss: 0.4154 - val_accuracy: 0.8708 12345678910111213# 에포크 20으로 늘림model = model_fn()model.compile(loss='sparse_categorical_crossentropy', metrics='accuracy')history = model.fit(train_scaled, train_target, epochs=20, verbose=1, validation_data=(val_scaled, val_target))plt.plot(history.history['loss'])plt.plot(history.history['val_loss'])plt.xlabel('epoch')plt.ylabel('loss')plt.legend(['train', 'val'])plt.show() Epoch 1/20 1500/1500 [==============================] - 4s 2ms/step - loss: 0.5319 - accuracy: 0.8131 - val_loss: 0.4284 - val_accuracy: 0.8492 Epoch 2/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3936 - accuracy: 0.8571 - val_loss: 0.3844 - val_accuracy: 0.8645 Epoch 3/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3560 - accuracy: 0.8704 - val_loss: 0.3669 - val_accuracy: 0.8715 Epoch 4/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3353 - accuracy: 0.8792 - val_loss: 0.3503 - val_accuracy: 0.8792 Epoch 5/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3200 - accuracy: 0.8857 - val_loss: 0.3798 - val_accuracy: 0.8707 Epoch 6/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3089 - accuracy: 0.8902 - val_loss: 0.3681 - val_accuracy: 0.8759 Epoch 7/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2984 - accuracy: 0.8945 - val_loss: 0.4130 - val_accuracy: 0.8653 Epoch 8/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2925 - accuracy: 0.8955 - val_loss: 0.3637 - val_accuracy: 0.8847 Epoch 9/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2822 - accuracy: 0.9012 - val_loss: 0.3923 - val_accuracy: 0.8762 Epoch 10/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2762 - accuracy: 0.9031 - val_loss: 0.3755 - val_accuracy: 0.8808 Epoch 11/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2726 - accuracy: 0.9040 - val_loss: 0.3748 - val_accuracy: 0.8794 Epoch 12/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2631 - accuracy: 0.9085 - val_loss: 0.3988 - val_accuracy: 0.8809 Epoch 13/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2600 - accuracy: 0.9087 - val_loss: 0.4310 - val_accuracy: 0.8813 Epoch 14/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2549 - accuracy: 0.9116 - val_loss: 0.4131 - val_accuracy: 0.8844 Epoch 15/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2533 - accuracy: 0.9139 - val_loss: 0.4343 - val_accuracy: 0.8820 Epoch 16/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2479 - accuracy: 0.9151 - val_loss: 0.4254 - val_accuracy: 0.8862 Epoch 17/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2406 - accuracy: 0.9166 - val_loss: 0.4298 - val_accuracy: 0.8858 Epoch 18/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2369 - accuracy: 0.9176 - val_loss: 0.4401 - val_accuracy: 0.8852 Epoch 19/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2347 - accuracy: 0.9192 - val_loss: 0.4332 - val_accuracy: 0.8883 Epoch 20/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2316 - accuracy: 0.9211 - val_loss: 0.4471 - val_accuracy: 0.8796 12345678910111213# 옵티마이저 적용model = model_fn()model.compile(optimizer= 'adam', loss='sparse_categorical_crossentropy', metrics='accuracy')history = model.fit(train_scaled, train_target, epochs=20, verbose=1, validation_data=(val_scaled, val_target))plt.plot(history.history['loss'])plt.plot(history.history['val_loss'])plt.xlabel('epoch')plt.ylabel('loss')plt.legend(['train', 'val'])plt.show() Epoch 1/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.5265 - accuracy: 0.8185 - val_loss: 0.4242 - val_accuracy: 0.8491 Epoch 2/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3969 - accuracy: 0.8575 - val_loss: 0.3747 - val_accuracy: 0.8667 Epoch 3/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3550 - accuracy: 0.8715 - val_loss: 0.3502 - val_accuracy: 0.8747 Epoch 4/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3292 - accuracy: 0.8795 - val_loss: 0.3671 - val_accuracy: 0.8695 Epoch 5/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3079 - accuracy: 0.8876 - val_loss: 0.3563 - val_accuracy: 0.8748 Epoch 6/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2941 - accuracy: 0.8918 - val_loss: 0.3482 - val_accuracy: 0.8759 Epoch 7/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2816 - accuracy: 0.8972 - val_loss: 0.3568 - val_accuracy: 0.8693 Epoch 8/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2702 - accuracy: 0.9002 - val_loss: 0.3165 - val_accuracy: 0.8883 Epoch 9/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2575 - accuracy: 0.9045 - val_loss: 0.3286 - val_accuracy: 0.8808 Epoch 10/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2501 - accuracy: 0.9072 - val_loss: 0.3677 - val_accuracy: 0.8698 Epoch 11/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2387 - accuracy: 0.9115 - val_loss: 0.3232 - val_accuracy: 0.8850 Epoch 12/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2338 - accuracy: 0.9126 - val_loss: 0.3256 - val_accuracy: 0.8865 Epoch 13/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2259 - accuracy: 0.9145 - val_loss: 0.3364 - val_accuracy: 0.8852 Epoch 14/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2178 - accuracy: 0.9184 - val_loss: 0.3426 - val_accuracy: 0.8797 Epoch 15/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2121 - accuracy: 0.9204 - val_loss: 0.3343 - val_accuracy: 0.8855 Epoch 16/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2076 - accuracy: 0.9230 - val_loss: 0.3224 - val_accuracy: 0.8903 Epoch 17/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2025 - accuracy: 0.9222 - val_loss: 0.3432 - val_accuracy: 0.8807 Epoch 18/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.1963 - accuracy: 0.9260 - val_loss: 0.3421 - val_accuracy: 0.8889 Epoch 19/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.1904 - accuracy: 0.9277 - val_loss: 0.3387 - val_accuracy: 0.8859 Epoch 20/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.1869 - accuracy: 0.9308 - val_loss: 0.3481 - val_accuracy: 0.8863 드롭아웃 제프리 힌턴 기본적으로 모든 파라미터를 연산하는것이 원칙 but. 일부 뉴런에서 출력이 없는 뉴런 발생 –&gt; 기존 일부 뉴런은 계산에서 제외 시킴 인공신경망 (뇌과학) 값이 쏠림 현상이 발생 %= 뇌에 피가 고인 현상 %= 뇌출혈 12model = model_fn(keras.layers.Dropout(0.3))model.summary() Model: &quot;sequential_6&quot; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= flatten_6 (Flatten) (None, 784) 0 dense_12 (Dense) (None, 100) 78500 dropout (Dropout) (None, 100) 0 dense_13 (Dense) (None, 10) 1010 ================================================================= Total params: 79,510 Trainable params: 79,510 Non-trainable params: 0 _________________________________________________________________ 123456789101112# 드롭아웃 적용model.compile(optimizer= 'adam', loss='sparse_categorical_crossentropy', metrics='accuracy')history = model.fit(train_scaled, train_target, epochs=20, verbose=1, validation_data=(val_scaled, val_target))plt.plot(history.history['loss'])plt.plot(history.history['val_loss'])plt.xlabel('epoch')plt.ylabel('loss')plt.legend(['train', 'val'])plt.show() Epoch 1/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.5938 - accuracy: 0.7927 - val_loss: 0.4280 - val_accuracy: 0.8453 Epoch 2/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.4419 - accuracy: 0.8411 - val_loss: 0.4036 - val_accuracy: 0.8522 Epoch 3/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.4047 - accuracy: 0.8537 - val_loss: 0.3683 - val_accuracy: 0.8670 Epoch 4/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3828 - accuracy: 0.8608 - val_loss: 0.3504 - val_accuracy: 0.8707 Epoch 5/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3714 - accuracy: 0.8635 - val_loss: 0.3404 - val_accuracy: 0.8767 Epoch 6/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3539 - accuracy: 0.8703 - val_loss: 0.3410 - val_accuracy: 0.8760 Epoch 7/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3483 - accuracy: 0.8721 - val_loss: 0.3377 - val_accuracy: 0.8776 Epoch 8/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3357 - accuracy: 0.8763 - val_loss: 0.3315 - val_accuracy: 0.8807 Epoch 9/20 1500/1500 [==============================] - 4s 3ms/step - loss: 0.3314 - accuracy: 0.8773 - val_loss: 0.3301 - val_accuracy: 0.8771 Epoch 10/20 1500/1500 [==============================] - 4s 2ms/step - loss: 0.3214 - accuracy: 0.8812 - val_loss: 0.3274 - val_accuracy: 0.8787 Epoch 11/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3180 - accuracy: 0.8831 - val_loss: 0.3325 - val_accuracy: 0.8813 Epoch 12/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.3121 - accuracy: 0.8852 - val_loss: 0.3194 - val_accuracy: 0.8821 Epoch 13/20 1500/1500 [==============================] - 4s 2ms/step - loss: 0.3078 - accuracy: 0.8860 - val_loss: 0.3408 - val_accuracy: 0.8773 Epoch 14/20 1500/1500 [==============================] - 4s 3ms/step - loss: 0.3026 - accuracy: 0.8865 - val_loss: 0.3316 - val_accuracy: 0.8817 Epoch 15/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2940 - accuracy: 0.8890 - val_loss: 0.3322 - val_accuracy: 0.8831 Epoch 16/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2955 - accuracy: 0.8900 - val_loss: 0.3196 - val_accuracy: 0.8870 Epoch 17/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2919 - accuracy: 0.8908 - val_loss: 0.3243 - val_accuracy: 0.8853 Epoch 18/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2835 - accuracy: 0.8925 - val_loss: 0.3362 - val_accuracy: 0.8830 Epoch 19/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2844 - accuracy: 0.8926 - val_loss: 0.3243 - val_accuracy: 0.8819 Epoch 20/20 1500/1500 [==============================] - 3s 2ms/step - loss: 0.2812 - accuracy: 0.8943 - val_loss: 0.3184 - val_accuracy: 0.8881 - 드롭아웃을 적용했더니 과대적합 되던 모형이 많이 완화됨. 모댈 저장과 복원 개발자: 정확도는 중요하지 않음 딥러닝 모델 활용해서 웹앱을 개발하는게 목적 분석가 &amp; 머신러닝 엔지니어: 캐글 대회 (정확도 검증 필수) 12model.save_weights('model-weights.h5')model.save('model-whole.h5') 모델 불러오기 12model = model_fn(keras.layers.Dropout(0.3))model.load_weights('model-weights.h5') 1234import numpy as npval_labels = np.argmax(model.predict(val_scaled), axis=-1)print(np.mean(val_labels == val_target)) 0.8810833333333333 콜백 model.checkpoint(): 체크포인트를 기록 12345678910model = model_fn(keras.layers.Dropout(0.3))model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')checkpoint_cb = keras.callbacks.ModelCheckpoint('best-model.h5', save_best_only=True)model.fit(train_scaled, train_target, epochs=20, verbose=0, validation_data=(val_scaled, val_target), callbacks=[checkpoint_cb]) &lt;keras.callbacks.History at 0x7f673a848ad0&gt; 12model = keras.models.load_model('best-model.h5')model.evaluate(val_scaled, val_target) 375/375 [==============================] - 1s 1ms/step - loss: 0.3137 - accuracy: 0.8893 [0.31372642517089844, 0.8893333077430725] Early Stopping 조기 종료 에포크를 많이 주면 많이 줄수록 성능이 좋아야 하는 것이 원리 (가중치 업데이트 / 기울기가 계속 미분) if) 에포크 100 / 50 에포크 시점과 90에포크 시점 성능 차이 없음 123456789101112model = model_fn(keras.layers.Dropout(0.3))model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')checkpoint_cb = keras.callbacks.ModelCheckpoint('best-model.h5', save_best_only=True)early_stopping_cb = keras.callbacks.EarlyStopping(patience=2, restore_best_weights=True)history = model.fit(train_scaled, train_target, epochs=20, verbose=0, validation_data=(val_scaled, val_target), callbacks=[checkpoint_cb, early_stopping_cb]) 1print(early_stopping_cb.stopped_epoch) 14 123456plt.plot(history.history['loss'])plt.plot(history.history['val_loss'])plt.xlabel('epoch')plt.ylabel('loss')plt.legend(['train', 'val'])plt.show() 마무리 정리 키워드: 드롭아웃: 은닉층에 있는 뉴런의 출력을 랜덤하게 꺼서 과대적합을 막는 기법 콜백: 케라스 모델을 훈련하는 도중에 어떤 작업을 수행 할 수 있도록 도와주는 도구 조기종료: 검증점수가 더 이상 감소하지 않고 상승하여 과대적합이 일어나면 훈련을 계속 진행하지 않고 멈추는 기법 TensorFlow 패키지 Dropout: 드롭아웃 층 save_weights(): 모든 층의 가중치와 절편을 파일에 저장 load_weights(): 모든 층의 가중치와 절편을 파일에 읽음 save(): 모델 구조와 모든 가중치와 절편을 파일에 저장 load_model(): model.save()로 저장된 모델을 로드 ModelCheckpoint: 케라스 모델과 가중치를 일정 간격으로 저장 EarlyStopping: 관심지표가 더이상 향상하지 않으면 훈련을 중지 NumPy 패키지 argmax: 배열에서 축을 따라 최댓값의 인덱스 반환 매개변수 axis: 어떤축을 따라 최댓값을 찾을지 지정 [default: None] (전체 배열에서 최댓값)","link":"/2022/04/05/0405_Neural_Network_Model/"},{"title":"파이프_라인_(데이터_전처리)","text":"데이터 누수 방지 위한 모델링 기법:파이프라인 구축 수능시험 = 최종테스트 데이터 모의고사 or 기출문제 = 검증데이터 교과서 문제지 = 훈련데이터 머신러닝 엔지니어 : MLOps (선행되어야 하는 코드 조건, Pipeline 형태로 구축) 머신러닝 코드 자동화 가능, 운영 가능 개발 업계의 최상위 연봉자 데이터 불러오기1234import pandas as pdimport numpy as npdata = pd.read_csv('https://raw.githubusercontent.com/MicrosoftDocs/ml-basics/master/data/daily-bike-share.csv')data.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 731 entries, 0 to 730 Data columns (total 14 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 instant 731 non-null int64 1 dteday 731 non-null object 2 season 731 non-null int64 3 yr 731 non-null int64 4 mnth 731 non-null int64 5 holiday 731 non-null int64 6 weekday 731 non-null int64 7 workingday 731 non-null int64 8 weathersit 731 non-null int64 9 temp 731 non-null float64 10 atemp 731 non-null float64 11 hum 731 non-null float64 12 windspeed 731 non-null float64 13 rentals 731 non-null int64 dtypes: float64(4), int64(9), object(1) memory usage: 80.1+ KB 데이터 추출1234cols = ['season', 'mnth', 'holiday', 'weekday', 'workingday', 'weathersit', 'temp', 'atemp', 'hum', 'windspeed', 'rentals']data = data[cols]data.info()# data['mnth'].value_counts() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 731 entries, 0 to 730 Data columns (total 11 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 season 731 non-null int64 1 mnth 731 non-null int64 2 holiday 731 non-null int64 3 weekday 731 non-null int64 4 workingday 731 non-null int64 5 weathersit 731 non-null int64 6 temp 731 non-null float64 7 atemp 731 non-null float64 8 hum 731 non-null float64 9 windspeed 731 non-null float64 10 rentals 731 non-null int64 dtypes: float64(4), int64(7) memory usage: 62.9 KB 기존: 데이터 불러오기 -&gt; 데이터 전처리 -&gt; 피처공학(원핫인코딩) -&gt; 데이터셋 분리 -&gt; 모델링 코드 -&gt; 모델평가 파이프라인: 데이터 불러오기 -&gt; 데이터 전처리 -&gt; 데이터셋 분리 -&gt; 파이프라인 구축 (피처공학, 모델링 코드) -&gt; 모델평가 데이터셋 분리12345from sklearn.model_selection import train_test_splitX = data.drop('rentals',axis=1)y = data['rentals']X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=123) Data Prepocessing 결측치 수동으로 채우거나 불필요한 변수를 제거하거나 이상치를 제거하거나 파생변수를 만들거나 등등 Feature Engineering 기존: 개별적으로 코드 작성 현재: Pipeline 코드로 추가할것 Pipeline 구축1234567891011121314151617181920212223242526272829303132333435363738from sklearn.preprocessing import StandardScaler, OrdinalEncoder, OneHotEncoderfrom sklearn.impute import SimpleImputerfrom sklearn.compose import ColumnTransformerfrom sklearn.pipeline import Pipeline# 데이터 타입 3가지# 수치형 데이터, 무자열 데이터# 문자열 데이터: 범주형(명목형, 서열형 데이터 구분)numeric_transformer = Pipeline(steps=[ ('imputer', SimpleImputer(strategy='mean')) ,('scaler', StandardScaler())])ordinal_transformer = Pipeline(steps=[ ('imputer', SimpleImputer(strategy='constant')) ,('ordEncoder', OrdinalEncoder())])onehot_transformer = Pipeline(steps=[ ('imputer', SimpleImputer(strategy='constant')) ,('oheEncoder', OneHotEncoder()) ])# 수치형 데이터 및 Categorical 데이터 컬럼 분리numeric_features = ['temp', 'atemp', 'hum', 'windspeed']ordinal_features = ['holiday', 'weekday', 'workingday', 'weathersit']onehot_features = ['season', 'mnth']# numeric_features = data.select_dtypes(include=['int64', 'float64']).columns# categorical_features = data.select_dtypes(include=['object']).drop(['Loan_Status'], axis=1).columnspreprocessor = ColumnTransformer( transformers=[ ('numeric', numeric_transformer, numeric_features) , ('ord_categorical', ordinal_transformer, ordinal_features) , ('ohe_categorical', onehot_transformer, onehot_features)]) 모델 적용123456789from sklearn.ensemble import RandomForestRegressorpipeline = Pipeline(steps = [ ('preprocessor', preprocessor) ,('regressor', RandomForestRegressor()) ])rf_model = pipeline.fit(X_train, y_train)print(rf_model) Pipeline(steps=[('preprocessor', ColumnTransformer(transformers=[('numeric', Pipeline(steps=[('imputer', SimpleImputer()), ('scaler', StandardScaler())]), ['temp', 'atemp', 'hum', 'windspeed']), ('ord_categorical', Pipeline(steps=[('imputer', SimpleImputer(strategy='constant')), ('ordEncoder', OrdinalEncoder())]), ['holiday', 'weekday', 'workingday', 'weathersit']), ('ohe_categorical', Pipeline(steps=[('imputer', SimpleImputer(strategy='constant')), ('oheEncoder', OneHotEncoder())]), ['season', 'mnth'])])), ('regressor', RandomForestRegressor())]) 모델 평가123from sklearn.metrics import r2_scorepredictions = rf_model.predict(X_test)print (r2_score(y_test, predictions)) 0.7623870644942855 다중모형 개발123456789101112131415161718from sklearn.ensemble import RandomForestRegressorfrom sklearn.tree import DecisionTreeRegressorregressors = [ RandomForestRegressor() ,DecisionTreeRegressor()]# regressors = [pipe_rf, pipe_dt]for regressor in regressors: pipeline = Pipeline(steps = [ ('preprocessor', preprocessor) ,('regressor',regressor) ]) model = pipeline.fit(X_train, y_train) predictions = model.predict(X_test) print(regressor) print(f'Model r2 score:{r2_score(predictions, y_test)}') RandomForestRegressor() Model r2 score:0.7385832717833691 DecisionTreeRegressor() Model r2 score:0.6033264470675421","link":"/2022/04/05/0405_Pipeline/"},{"title":"합성곱 신경망_01","text":"합성곱 신경망 ( CNN ) 로지스틱 회귀(일반 ML 모형): 81% 1950년대 인공신경망 (딥러닝 초기 모형): 87% 1940 ~ 80년대 합성곱(Convolution, CNN): 이미지 관련 이미지의 특성을 잡아내는 알고리즘 코드보다는 용어에 초점 변천사: alexnet (2012) - &gt; resnet - &gt; efficientnet 기타 등등… 채널(색 성분), 이미지의 넓이, 크기[=높이] (파라미터 튜닝) Vision Transformer (논문): 이미지 분류 부분의 판도를 크게 바꾼 논문 비디오 객체인식 (Object Detection) 위주 Yolo (논문): 합성곱 신경망( CNN ) 기반으로 작성됨. 순환 신경망(RNN) - LSTM (Long Short-Term Memory models) 구글 2017년 Transformer (논문) [자연어 처리 관련] 합성곱의 장점 기존: 1차원 배열에서만 연산이 가능 2차원 배열에도 연산을 할 수 있도록 구현돰 선형대수: 행렬을 이용하여 선형적인 문제를 해결. 행렬의 연산만을 다루는 것이 아니라, 공학적인 문제를 행렬의 형태로 정의하고 그 해답을 구하는 과정과 방법 12345from tensorflow import keraskeras.layers.Conv2D(10, kernel_size=(3, 3), activation= 'relu')# 매개변수 명 filters를 적은 정식 명칭# keras.layers.Conv2D(filters= 10, kernel_size=(3, 3), activation= 'relu')# activation= 'relu' ==&gt; 연산중 0으로 나오는 값들은 제외 &lt;keras.layers.convolutional.Conv2D at 0x7facca8a1410&gt; 패딩의 목적 배열의 크기를 조정하더라도 이미지의 원 특성이 손실되는것을 방지 패딩이 적용되지 않으면 각 모서리의 데이터는 한번씩밖에 읽히지 않음 세임(same) 패딩: 입력 주위에 0이나 1로 패딩하는것 밸리드(valid) 패딩: 패딩 없이 순수한 입력 배열에서만 합성곱을 진행. (특성 맵의 크기가 줄어듦) 1234# 세임패딩 적용keras.layers.Conv2D(10, kernel_size=(3, 3), activation= 'relu', padding= 'same') &lt;keras.layers.convolutional.Conv2D at 0x7facc9f66290&gt; 풀링 값을 추출 최대풀링: 필터마다의 최대값을 도출함 if ex) 100 * 100이미지 –&gt; 주요 이미지의 특성만 뽑은 후, 원이미지와 같게 만듬. 이때 크기는 줄어듬 (50 * 50) 합성곱 신경망의 전체 구조 1단계: 이미지 데이터 입력 2단계: 합성곱 층 kernel_size + padding 황설화 함수 적용 각각의 특성맵을 산출 3단계: 풀링층 Max pooling: 최댓값 추출 (풀링 방법 중 하나) 최종 특성맵 이 과정 (1~3단계) 을 계속 반복하는것이 CNN 알고리즘 4단계: 밀집층 (Fully Connected Layer) 5단계: 분류 / 예측 값을 산출 (Softmax 활성화 함수) 마무리 정리 키워드 합성곱: 밀집층과 비슷하게 입력과 가중치를 곱하고 절편을 더하는 선형계산 (각 합성곱은 입력 전체가 아니라 일부만 사용) 채널: 채널은 색 성분을 의미하며 흑백이미지는 1이며, 각 픽셀은 0 ~ 255사이의 값을 가짐. 이미지는 ‘높이’, ‘너비’, ‘채널’ 이라는 3차원 텐서로 정의됨. 필터[=커널]: 밀집층의 뉴련에 해당. 합성곱 신경망에서 부르는 명칭. (3 * 3) 과 (5 * 5)를 자주 사용 특성 맵: 합성곱 층이나 풀링 층의 출력 ‘배열’을 의미 패딩: 합성곱 층의 입력 주위에 추가한 0으로 채워진 픽셀 스트라이드: 합성곱 층에서 필터가 입력(데이터) 위를 이동하는 간격. 일반적으로 1픽셀 사용 풀링: 가중치가 없고 특성 맵의 가로 세로 크기를 줄이는 역할. 대표적으로 최대 풀링과 평균 풀링이 있음. 사전학습 모델(Pre-Trained Model): 풀고자하는 문제와 비슷하면서 사이즈가 큰 데이터로 이미 학습이 되어 있는 모델 전이학습(Transfer Learning): 특정 분야에서 학습된 신경망의 일부 능력을 유사하거나 전혀 새로운 분야에서 사용되는 신경망의 학습에 이용하는 방법 파인튜닝(Fine tuning): 기존에 학습되어져 있는 모델을 기반으로 아키텍쳐를 새로운 목적에 맞게 변형하고 이미 학습된 모델의 가중치를 미세하게 조정하여 학습시키는 방법 -&gt; 캐글 경진대회에서 학습 / 실습 가능 (클래스 공부 필요) TensorFlow 패키지 Keras.layers: 케라스의 층, 합성곱 층 Conv2D: 특별히 위를 이동하는 합성곱 매개변수 filters: 필터의 개수 매개변수 kernel_size: 필터(커널)의 크기 매개변수 activation: 활성화 함수.","link":"/2022/04/06/0406_Convolution_Neural_Network/"},{"title":"Kaggle 프로젝트","text":"프로젝트 개요 강의명 : 2022년 K-디지털 직업훈련(Training) 사업 - AI데이터플랫폼을 활용한 빅데이터 분석전문가 과정 교과목명 : 빅데이터 분석 및 시각화, AI개발 기초, 인공지능 프로그래밍 프로젝트 주제 : Spaceship Titanic 데이터를 활용한 탑승유무 분류모형 개발 프로젝트 마감일 : 2022년 4월 12일 화요일 강사명 : 정지훈 강사 수강생명 : 황우빈 123456789101112131415161718# This Python 3 environment comes with many helpful analytics libraries installed# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python# For example, here's several helpful packages to loadimport numpy as np # linear algebraimport pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)# Input data files are available in the read-only &quot;../input/&quot; directory# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directoryimport osfor dirname, _, filenames in os.walk('/kaggle/input'): for filename in filenames: print(os.path.join(dirname, filename))# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using &quot;Save &amp; Run All&quot; # You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session Step.1 라이브러리 및 데이터 불러오기 라이브러리 버전 확인 12345678910111213141516171819202122import numpy as npimport pandas as pdimport plotly.express as pxfrom plotly.subplots import make_subplotsimport plotly.graph_objects as goimport matplotlib.pyplot as pltfrom sklearn.preprocessing import OneHotEncoderfrom sklearn.compose import make_column_transformerfrom sklearn.model_selection import train_test_splitfrom sklearn.model_selection import StratifiedKFoldfrom scipy.stats import uniform, randintfrom sklearn.model_selection import RandomizedSearchCVfrom sklearn.tree import DecisionTreeClassifierfrom sklearn.model_selection import cross_validatefrom sklearn.model_selection import GridSearchCVfrom lightgbm import LGBMClassifierfrom sklearn.metrics import accuracy_scoreprint(&quot;success&quot;) 12345678# 데이터 불러오기 # PassengerId: 승객 번호, Transported: 전송sample = pd.read_csv(&quot;/kaggle/input/spaceship-titanic/sample_submission.csv&quot;)# print(sample.head())test = pd.read_csv(&quot;/kaggle/input/spaceship-titanic/test.csv&quot;)print(test.head())train = pd.read_csv(&quot;/kaggle/input/spaceship-titanic/train.csv&quot;)print(train.head()) 칼럼 별 설명: PassengerId: 각 승객의 고유 ID HomePlanet: 승객이 출발한 행성 CryoSleep: 승객이 항해 기간 동안 애니메이션을 일시 중단하도록 선택했는지 여부를 나타냄 Cabin: 승객이 머물고 있는 객실 번호입니다. Destination: 승객이 출발할 행성입니다. Age: 승객의 나이 VIP: 승객이 항해 중 특별 VIP 서비스 비용을 지불했는지 여부. RoomService: 승객이 룸서비스에 대해 청구한 금액입니다. Name: 승객의 이름 Transported: 승객이 다른 차원으로 운송되었는지 여부. 예측하려는 대상인 열 train데이터 결측치 유무, 통계 확인 12train.info()train.describe() test데이터 결측치 유무, 통계 확인 123# 결측치 확인test.info()test.describe() Step.2 탐색적 자료 분석(EDA) 데이터 시각화 산점도, 막대 그래프 등 그래프 해석해서 설명을 달아야 함. 약간의 데이터 전처리 시각화하기 위한 함수 작성. 12345678910111213141516171819202122# text = &quot;Age&quot;# train_series = train[text].value_counts()# train_df = pd.DataFrame(train_series).sort_index()# test_series = test[text].value_counts()# test_df = pd.DataFrame(test_series).sort_index()# fig = make_subplots(rows= 1,# cols= 1,# column_titles= [&quot;Target Values&quot;],# y_title= &quot;Values&quot;)# fig.add_trace(go.Scatter(x= df.index, y= train_df[text],# orientation=&quot;v&quot;,# name= &quot;train&quot;),# 1, 1)# fig.add_trace(go.Scatter(x= df.index, y= test_df[text],# orientation=&quot;v&quot;),# 1, 1) # fig.update_layout()# fig.show() 123456789101112131415161718192021222324def visual(train, test, text): train_series = train[text].value_counts() train_df = pd.DataFrame(train_series).sort_index() test_series = test[text].value_counts() test_df = pd.DataFrame(test_series).sort_index() fig = make_subplots(rows= 1, cols= 1, column_titles= [&quot;Target Values&quot;], y_title= &quot;Values&quot;) fig.add_trace(go.Scatter(x= train_df.index, y= train_df[text], orientation=&quot;v&quot;, name= &quot;train_data&quot;), 1, 1) fig.add_trace(go.Scatter(x= test_df.index, y= test_df[text], orientation=&quot;v&quot;, name= &quot;test_data&quot;), 1, 1) fig.update_layout() fig.show() 1visual(train, test, &quot;Age&quot;) - 10대 후반에서 30대 후반의 비율이 높은것을 확인 할 수 있음. 1visual(train, test, &quot;RoomService&quot;) 1visual(train, test, &quot;FoodCourt&quot;) 1visual(train, test, &quot;ShoppingMall&quot;) 1visual(train, test, &quot;Spa&quot;) 1visual(train, test, &quot;VRDeck&quot;) - RoomService, FoodCourt, ShoppingMall, Spa, VRDeck의 데이터중 10 미만의 값들이 압도적으로 많은것을 확인 할 수 있다. 결측값들의 개수 찾기 123456789train_null = pd.DataFrame(train.isna().sum())train_null= train_null.sort_values(by= 0)print(train_null)print()test_null = pd.DataFrame(test.isna().sum())test_null= test_null.sort_values(by= 0)print(test_null) 12345678910111213141516# 결측치데이터 - 시각화fig = make_subplots(rows= 1, cols= 2, column_titles= [&quot;train data&quot;, &quot;test data&quot;], x_title= &quot;Missing Values&quot;)fig.add_trace(go.Bar(x= train_null[0], y= train_null.index, orientation=&quot;h&quot;,), 1, 1) fig.add_trace(go.Bar(x= test_null[0], y= test_null.index, orientation=&quot;h&quot;), 1, 2) fig.update_layout()fig.show() - Transported와 PassengerId를 제외하고는 결측치가 존재하는걸 확인 할 수 있음. Step.3 데이터 전처리 Feature Engineering 머신러닝(ML) 모형을 돌리기 위해 표준화 등 / 원핫-인코딩 파생변수(도출변수) 만들기 왜 이 변수를 만들었는지에 대한 설명 필요 필요한 데이터를 제외하고는 제외 1train.head() 12target = train['Transported']target 12345678910111213print(train['PassengerId'].value_counts()) # x# train['HomePlanet'].value_counts() # o# train['CryoSleep'].value_counts() # oprint(train['Cabin'].value_counts()) # x# train['Destination'].value_counts() # o# train['Age'].value_counts() # o# train['VIP'].value_counts() # o# train['RoomService'].value_counts() # o# train['FoodCourt'].value_counts() # o# train['ShoppingMall'].value_counts() # o# train['Spa'].value_counts() # o# train['VRDeck'].value_counts() # oprint(train['Name'].value_counts()) # x - 확인 해 본 결과 PassengerId, Cabin, Name의 특성은 예측에 영향을 안줄것으로 추정하여 제외하도록 함. 1234567# train_data = train.drop(['PassengerId', 'Name'], axis= 1)# test_data = test.drop(['PassengerId', 'Name'], axis= 1)train_data = train.drop(['PassengerId', 'Cabin', 'Name'], axis= 1)test_data = test.drop(['PassengerId', 'Cabin', 'Name'], axis= 1)print(train_data.shape)print(test_data.shape) 결측치를 float 타입은 mean()으로 object 타입은 최빈값으로 채우기 위해 각각의 데이터를 확인 1train_data.info() 123456789101112# floatprint(train_data[&quot;Age&quot;].mean())print(train_data[&quot;RoomService&quot;].mean())print(train_data[&quot;FoodCourt&quot;].mean())print(train_data[&quot;ShoppingMall&quot;].mean())print(train_data[&quot;Spa&quot;].mean())print(train_data[&quot;VRDeck&quot;].mean())# objectprint(train_data[&quot;HomePlanet&quot;].mode())print(train_data[&quot;CryoSleep&quot;].mode())print(train_data[&quot;Destination&quot;].mode())print(train_data[&quot;VIP&quot;].mode()) train데이터 결측값 대체하기 1234567891011121314# floattrain_data['Age'].replace(np.nan, train_data['Age'].mean(), inplace= True)train_data['RoomService'].replace(np.nan, train_data['RoomService'].mean(), inplace= True)train_data['FoodCourt'].replace(np.nan, train_data['FoodCourt'].mean(), inplace= True)train_data['ShoppingMall'].replace(np.nan, train_data['ShoppingMall'].mean(), inplace= True)train_data['Spa'].replace(np.nan, train_data['Spa'].mean(), inplace= True)train_data['VRDeck'].replace(np.nan, train_data['VRDeck'].mean(), inplace= True)# objecttrain_data['HomePlanet'].replace(np.nan, 'Earth', inplace= True)train_data['Destination'].replace(np.nan, 'TRAPPIST-1e', inplace= True)train_data['CryoSleep'].replace(np.nan, False, inplace= True)train_data['VIP'].replace(np.nan, False, inplace= True)train_data.isna().sum() 1test_data.info() 123456789101112# floatprint(test_data[&quot;Age&quot;].mean())print(test_data[&quot;RoomService&quot;].mean())print(test_data[&quot;FoodCourt&quot;].mean())print(test_data[&quot;ShoppingMall&quot;].mean())print(test_data[&quot;Spa&quot;].mean())print(test_data[&quot;VRDeck&quot;].mean())# objectprint(test_data[&quot;HomePlanet&quot;].mode())print(test_data[&quot;CryoSleep&quot;].mode())print(test_data[&quot;Destination&quot;].mode())print(test_data[&quot;VIP&quot;].mode()) test데이터 결측값 대체하기 1234567891011121314# floattest_data['Age'].replace(np.nan, test_data['Age'].mean(), inplace= True)test_data['RoomService'].replace(np.nan, test_data['RoomService'].mean(), inplace= True)test_data['FoodCourt'].replace(np.nan, test_data['FoodCourt'].mean(), inplace= True)test_data['ShoppingMall'].replace(np.nan, test_data['ShoppingMall'].mean(), inplace= True)test_data['Spa'].replace(np.nan, test_data['Spa'].mean(), inplace= True)test_data['VRDeck'].replace(np.nan, test_data['VRDeck'].mean(), inplace= True)# objecttest_data['HomePlanet'].replace(np.nan, 'Earth', inplace= True)test_data['Destination'].replace(np.nan, 'TRAPPIST-1e', inplace= True)test_data['CryoSleep'].replace(np.nan, False, inplace= True)test_data['VIP'].replace(np.nan, False, inplace= True)test_data.isna().sum() -결측값들 성공적으로 제거! 원핫인코딩1234567891011121314151617181920# Transported의 True는 1로, False는 0으로 대체train_data['Transported'] = train_data['Transported'].map({True: 1, False: 0})categorical = ['HomePlanet', 'Destination', 'CryoSleep', 'VIP']transformer = make_column_transformer((OneHotEncoder(), categorical),remainder = 'passthrough')train_transformed = transformer.fit_transform(train_data[categorical])train_transformed_df = pd.DataFrame(train_transformed, columns= transformer.get_feature_names_out())train_data = pd.concat([train_data, train_transformed_df], axis= 1)train_data = train_data.drop(categorical, axis= 1)test_transformed = transformer.fit_transform(test_data[categorical])test_transformed_df = pd.DataFrame(test_transformed, columns= transformer.get_feature_names_out())test_data = pd.concat([test_data, test_transformed_df], axis= 1)test_data = test_data.drop(categorical, axis= 1)print(&quot;success&quot;) Step.4 머신러닝 모형 개발 모형에 대한 설명 필요 모형 1~2개 사용 권장 교차 검증 하이퍼 파라미터 튜닝 랜덤서치(매개변수(max_depth)) 그래드서치 독립변수와 종속변수를 구분 독립변수: x 종속변수: Transported == y 123x_cols = test_data.columnsx = train_data[x_cols].to_numpy()y = train_data['Transported'].to_numpy() 훈련데이터를 검증데이터로 분리 검증데이터: val 12x_train, x_val, y_train, y_val = train_test_split(x, y, test_size= 0.3, random_state= 42)x_train.shape,x_val.shape,y_train.shape,y_val.shape 랜덤서치123456789params = { 'min_impurity_decrease': uniform(0.0001, 0.001), 'max_depth': randint(20, 50), 'min_samples_split': randint(2, 25), 'min_samples_leaf': randint(1, 25),}gs = RandomizedSearchCV(DecisionTreeClassifier(random_state= 42), params, # n_iter: 파라미터 검색 횟수 n_iter= 100, n_jobs= -1, random_state= 42) # n_jobs: cpu코어 수gs.fit(x_train, y_train) 1print(gs.best_params_) 1print(np.max(gs.cv_results_['mean_test_score'])) 123dt = gs.best_estimator_print(dt.score(x_val, y_val))print(&quot;success&quot;) 교차검증12scores = cross_validate(dt, x_train, y_train)scores 12print(np.mean(scores['test_score']))# 평균 점수 0.7903040262941661 StratifiedKFold()로 Fold 교차검증을 높여봄. 12scores = cross_validate(dt, x_train, y_train, cv= StratifiedKFold())print(np.mean(scores['test_score'])) 123splitter = StratifiedKFold(n_splits=200, shuffle= True, random_state= 42)scores = cross_validate(dt, x_train, y_train, cv= splitter)print(np.mean(scores['test_score'])) GridSearchCV()의 하이퍼 파라미터를 이용해봄. 1params = {'min_impurity_decrease': [0.0001, 0.0002, 0.0003, 0.0004, 0.0005]} 12gs = GridSearchCV(DecisionTreeClassifier(random_state= 42),params, n_jobs= -1)gs.fit(x_train, y_train) gs로 x,y train데이터 훈련 1234dt= gs.best_estimator_print(dt)print(dt.score(x_train, y_train))print(gs.best_params_) 1print(gs.cv_results_['mean_test_score']) gs로 x,y val데이터 훈련 1234567gs = GridSearchCV(DecisionTreeClassifier(random_state= 42),params, n_jobs= -1)gs.fit(x_val, y_val)dt= gs.best_estimator_print(dt)print(dt.score(x_val, y_val))print(gs.best_params_) 123params = {'min_impurity_decrease': [0.0001, 0.0002, 0.0003, 0.0004, 0.0005], 'max_depth': range(5, 20, 1), 'min_samples_split': range(2, 100, 10)} 1print(gs.best_params_) 1print(np.max(gs.cv_results_['mean_test_score'])) LightGBM 사용 12lgb = LGBMClassifier(random_state= 42)lgb Step.5 모형 평가 훈련데이터를 쪼개어 훈련데이터 + 검증데이터 분리 정확도 비교 혼동행렬(confusion Matrix) 설명 cross_validate() 활용 123456# # 1st challengesplitter = StratifiedKFold(n_splits = 5, shuffle = True, random_state=42)scores = cross_validate(lgb, x_train, y_train, return_train_score = True, cv=splitter)print(&quot;train Acc.&quot;, np.mean(scores['train_score']))print(&quot;test Acc.&quot;, np.mean(scores['test_score'])) 검증데이터를 활용하여 정확도를 예상해본다. 123456# 1st challengelgb.fit(x_train, y_train)y_pred = lgb.predict(x_val)print(&quot;Acc.&quot;, accuracy_score(y_val, y_pred))# Acc. 0.7864263803680982 혼동행렬 - 오분류 비용 나무위키 정의: 어떤 개인이나 모델, 검사도구, 알고리즘의 ‘진단’, ‘분류’, ‘판별’, ‘예측’능력을 평가하기 위해 고안된 표. 오류행렬(error matrix)이라고도 하며, 국내에는 오분류표라고 번역되기도 한다. 표로 나타내기. 123456def confusion_matrix(): col = [&quot;실제로 맞았다 &quot;, &quot; 실제로 틀렸다&quot;] ind = [&quot;맞을것이다&quot;, &quot;틀릴것이다&quot;] con = [[&quot;예측 성공&quot;, &quot;예측 실패&quot;], [&quot;예측 실패&quot;, &quot;예측 성공&quot;]] matrix = pd.DataFrame(con, columns=col, index=ind) print(matrix) 1confusion_matrix() - True, False 기준에서 작성했기에 2 by 2의 모습 - 기준을 어떻게 잡느냐에 따라서 3 by 3 이상의 다등급 분류를 나타내는 혼동행렬로 나타낼 수 있다. Step.6 제출 제출 양식 샘플은 만들어줌. 12345# 1st challengetest_preds = lgb.predict(test_data.to_numpy())sample['Transported'] = test_preds.astype(&quot;bool&quot;)sample.to_csv(&quot;submission.csv&quot;,index=False)sample.head() 참고 다른 사람의 code 설명을 쭉 따라치는경우 노트북 표절 방지 위해서, 참조한 코드는 반드시 링크 걸어둘것 저자 이름, 글 제목, 링크 주소 마감일 4월 12일 17시 40분 제출 형태 Leaderboard 랭킹 사진 캡처 고용노동부 보고 양식 (다음주에 확인하고 알려주실 예정) My_Note value_counts(): 값 별 개수 세기 Pandas라이브러리 fillna(): 결측값을 지정한 값으로 채움","link":"/2022/04/06/0406_woob-s/"},{"title":"순차 데이터와 순환 신경망","text":"순차 데이터와 순환 신경망 초급 레벨: 기초통계 (t.test, 분산분석, 회귀분석…) 중급 레벨: 시계열 분석 / 베이지안 / 비모수검정… 순차 데이터 텍스트나 시계열 데이터와 같이 순서에 의미가 있는 데이터를 뜻함 시계열 데이터: 주식 / 날씨 / 매장 매출 등등 시계열 데이터를 공부하고 싶다면 R 로 공부할 것 권장 텍스트 텍스트 마이닝 ( 데이터 분석가 ) 대표적으로 감정분석 ( 긍정, 부정 ) 문자열: 인코딩하는 방법론이 존재 자연어 처리 ( 개발자 ) 챗봇 ( 툴은 다 존재함 ) 자동 번역 기본 딥러닝 알고리즘 / RNN &amp; LSTM 현실에서 사용하지는 않음. 자료 딥러닝을 이용한 자연어 처리 입문 (텐서플로) : https://wikidocs.net/book/2155 Pytorch로 시작하는 딥러닝 입문 : https://wikidocs.net/32471 딥러닝은 분야 선정이 중요 영상인식, 이미지 분류, 음성, 자연어 순환 신경망 일반적으로 완전 연결 신경망과 거의 비슷하지만, 완전 연결 신경망에 이전 데이터의 처리 흐름을 순환하는 고리 하나를 추가하는 형태 이미지는 픽셀값이 어느정도 고정이 되어있음 if) 28 * 28 로 정의 –&gt; 모든 데이터를 28 * 28 로 맞출 수 있음 텍스트 값이 고정이 불가함 같은 의미 p.494 ex) i am boy (1, 4, 3) 마무리 정리 순차 데이터: 텍스트나 시계열 데이터와 같이 순서에 의미가 있는 데이터 순환 신경망: 순차 데이터에 잘 맞는 인공 신경망의 한 종류 셀: 순환 신경망에서의 순환층 은닉 상태: 순환 신경망에서의 셀의 출력","link":"/2022/04/07/0407_Sequentoal_Data,Recurrent_Neural_Network/"},{"title":"합성곱 신경망_02","text":"합성곱 신경망을 사용한 이미지 분류패션 MNIST 데이터 불러오기 데이터 스케일 0 ~ 255의 데이터를 0 ~ 1로 표준화 훈련 데이터 / 검증 데이터 분류 합성곱 신경망은 2차원 이미지를 그대로 사용하기 때문에 일렬로 펼치지 않아도 됨 완전 연결 신경망 (Fully Connected Layer) 2차원 배열을 1차원 배열로 바꿔야함 123456789101112from tensorflow import kerasfrom sklearn.model_selection import train_test_split(train_input, train_target), (test_input, test_target) = \\ keras.datasets.fashion_mnist.load_data()train_scaled = train_input.reshape(-1, 28, 28, 1) / 255.0train_scaled, val_scaled, train_target, val_target = train_test_split( train_scaled, train_target, test_size=0.2, random_state=42)print(train_input.shape, train_scaled.shape) Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/train-labels-idx1-ubyte.gz 32768/29515 [=================================] - 0s 0us/step 40960/29515 [=========================================] - 0s 0us/step Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/train-images-idx3-ubyte.gz 26427392/26421880 [==============================] - 0s 0us/step 26435584/26421880 [==============================] - 0s 0us/step Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/t10k-labels-idx1-ubyte.gz 16384/5148 [===============================================================================================] - 0s 0us/step Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/t10k-images-idx3-ubyte.gz 4423680/4422102 [==============================] - 0s 0us/step 4431872/4422102 [==============================] - 0s 0us/step (60000, 28, 28) (48000, 28, 28, 1) - (60000, 28, 28)크기였던 train_input이 (48000, 28, 28, 1)크기의 train_scaled가 됨. 합성곱 신경망 만들기 합성곱 신경망의 전형적인 구조 합성곱 층으로 이미지에서 특징을 감지 한 후 밀집층으로 클래스에 따른 분류 확률을 계산 123456789101112131415161718192021222324252627# 실험 코드model = keras.Sequential()# 합성곱 층model.add(keras.layers.Conv2D(32, kernel_size = 3, activation = 'relu', padding = 'same', input_shape = (28, 28, 1)))# 풀링층# 평균 풀링을 사용, 풀링 크기는 (3, 3)로 지정# # 최대 풀링의 함수: MaxPooling2D()# # 평균 풀링의 함수: AveragePooling2D()model.add(keras.layers.AveragePooling2D(3)) # 1/3으로 줄이겠다는 의미# 합성곱 층model.add(keras.layers.Conv2D(32, kernel_size=(3,3), activation='relu', padding='same'))# 풀링층model.add(keras.layers.AveragePooling2D(3))# 완전연결층 (밀집층 = Fully Connected Layer)model.add(keras.layers.Flatten())model.add(keras.layers.Dense(100, activation='relu'))model.add(keras.layers.Dropout(0.4))model.add(keras.layers.Dense(10, activation='softmax'))model.summary() Model: &quot;sequential&quot; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= conv2d (Conv2D) (None, 28, 28, 32) 320 average_pooling2d (AverageP (None, 9, 9, 32) 0 ooling2D) conv2d_1 (Conv2D) (None, 9, 9, 32) 9248 average_pooling2d_1 (Averag (None, 3, 3, 32) 0 ePooling2D) flatten (Flatten) (None, 288) 0 dense (Dense) (None, 100) 28900 dropout (Dropout) (None, 100) 0 dense_1 (Dense) (None, 10) 1010 ================================================================= Total params: 39,478 Trainable params: 39,478 Non-trainable params: 0 _________________________________________________________________ 1234567891011121314151617181920212223242526model = keras.Sequential()# 합성곱 층model.add(keras.layers.Conv2D(32, kernel_size = 3, activation = 'relu', padding = 'same', input_shape = (28, 28, 1)))# 풀링층# 최대 풀링을 사용, 전형적인 풀링 크기인 (2,2)로 지정# # 최대 풀링의 함수: MaxPooling2D()# # 평균 풀링의 함수: AveragePooling2D()model.add(keras.layers.MaxPooling2D(2)) # 절반으로 줄이겠다는 의미# 합성곱 층model.add(keras.layers.Conv2D(64, kernel_size=(3,3), activation='relu', padding='same'))# 풀링층model.add(keras.layers.MaxPooling2D(2))# 완전연결층 (밀집층 = Fully Connected Layer)model.add(keras.layers.Flatten())model.add(keras.layers.Dense(100, activation='relu'))model.add(keras.layers.Dropout(0.4))model.add(keras.layers.Dense(10, activation='softmax'))model.summary() Model: &quot;sequential_1&quot; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= conv2d_2 (Conv2D) (None, 28, 28, 32) 320 max_pooling2d (MaxPooling2D (None, 14, 14, 32) 0 ) conv2d_3 (Conv2D) (None, 14, 14, 64) 18496 max_pooling2d_1 (MaxPooling (None, 7, 7, 64) 0 2D) flatten_1 (Flatten) (None, 3136) 0 dense_2 (Dense) (None, 100) 313700 dropout_1 (Dropout) (None, 100) 0 dense_3 (Dense) (None, 10) 1010 ================================================================= Total params: 333,526 Trainable params: 333,526 Non-trainable params: 0 _________________________________________________________________ 층의 구조를 그림으로 표현 plot_model()함수 1keras.utils.plot_model(model) 12345# 실험 코드keras.utils.plot_model(model, show_shapes=True, dpi= 50)# dpi로 크기를 조절 할 수 있음 [default: 96] 매개변수 show_shapes를 적용하여 입력과 출력의 크기를 표시 1keras.utils.plot_model(model, show_shapes=True) - 지금까지 한 것은 모델 정의 모델 컴파일 후, 훈련 123456789101112131415# import tensorflow as tfmodel.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')checkpoint_cb = keras.callbacks.ModelCheckpoint('best-cnn-model.h5', save_best_only=True)early_stopping_cb = keras.callbacks.EarlyStopping(patience=2, restore_best_weights=True)# with tf.device('/device:GPU:0'):history = model.fit(train_scaled, train_target, epochs=10, validation_data=(val_scaled, val_target), callbacks=[checkpoint_cb, early_stopping_cb]) Epoch 1/10 1500/1500 [==============================] - 22s 7ms/step - loss: 0.5226 - accuracy: 0.8148 - val_loss: 0.3283 - val_accuracy: 0.8823 Epoch 2/10 1500/1500 [==============================] - 12s 8ms/step - loss: 0.3447 - accuracy: 0.8770 - val_loss: 0.2821 - val_accuracy: 0.8950 Epoch 3/10 1500/1500 [==============================] - 11s 7ms/step - loss: 0.2924 - accuracy: 0.8943 - val_loss: 0.2594 - val_accuracy: 0.8985 Epoch 4/10 1500/1500 [==============================] - 13s 8ms/step - loss: 0.2618 - accuracy: 0.9046 - val_loss: 0.2387 - val_accuracy: 0.9109 Epoch 5/10 1500/1500 [==============================] - 12s 8ms/step - loss: 0.2392 - accuracy: 0.9132 - val_loss: 0.2278 - val_accuracy: 0.9163 Epoch 6/10 1500/1500 [==============================] - 10s 7ms/step - loss: 0.2190 - accuracy: 0.9192 - val_loss: 0.2297 - val_accuracy: 0.9172 Epoch 7/10 1500/1500 [==============================] - 10s 7ms/step - loss: 0.2006 - accuracy: 0.9255 - val_loss: 0.2286 - val_accuracy: 0.9179 12345678910111213# import tensorflow as tf# model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', # metrics='accuracy')# checkpoint_cb = keras.callbacks.ModelCheckpoint('best-cnn-model.h5', # save_best_only=True)# early_stopping_cb = keras.callbacks.EarlyStopping(patience=2,# restore_best_weights=True)# with tf.device('/device:GPU:0'):# history = model.fit(train_scaled, train_target, epochs=10,# validation_data=(val_scaled, val_target),# callbacks=[checkpoint_cb, early_stopping_cb]) 모델 학습 곡선 그리기 12345678910111213# # 연습 코드: plotly로 그려보기# # 아래와 비슷한 결과를 얻었지만 블로그에 올리기 위해 주석 처리# import plotly.express as px# from plotly.subplots import make_subplots# import plotly.graph_objects as go# import matplotlib.pyplot as plt# fig = make_subplots()# fig.add_trace(go.Bar(y= history.history['loss']))# fig.add_trace(go.Scatter(y= history.history['val_loss']))# fig.show() 123456import matplotlib.pyplot as pltplt.plot(history.history['loss'])plt.plot(history.history['val_loss'])plt.xlabel('epoch')plt.legend(['train', 'val'])plt.show() 1234567# 그래픽 카드로 돌리는지 확인하는 방법import tensorflow as tfdevice_name = tf.test.gpu_device_name()if device_name != '/device:GPU:0': raise SystemError('GPU device not found')print('Found GPU at: {}'.format(device_name)) Found GPU at: /device:GPU:0 합성곱 신경망 시각화 model이 어떤 가중치를 학습했는지 확인 123456from tensorflow import kerasmodel = keras.models.load_model('best-cnn-model.h5')# keras.utils.plot_model(model2, show_shapes=True)model.layers # 리스트 형태로 저장되어 있음 [&lt;keras.layers.convolutional.Conv2D at 0x7fc7d81a7790&gt;, &lt;keras.layers.pooling.MaxPooling2D at 0x7fc8e00bfc10&gt;, &lt;keras.layers.convolutional.Conv2D at 0x7fc7f2f88490&gt;, &lt;keras.layers.pooling.MaxPooling2D at 0x7fc7d710d5d0&gt;, &lt;keras.layers.core.flatten.Flatten at 0x7fc8e023bb10&gt;, &lt;keras.layers.core.dense.Dense at 0x7fc7f3fb5350&gt;, &lt;keras.layers.core.dropout.Dropout at 0x7fc86a7a7050&gt;, &lt;keras.layers.core.dense.Dense at 0x7fc86a793750&gt;] - 2번의 합성곱과 풀링을 하고 Flatten층, Dense층, Dropout층, Dense층이 보임 합성곱층의 가중치를 확인 가능 12conv = model.layers[0]print(conv.weights[0].shape, conv.weights[1].shape) (3, 3, 1, 32) (32,) - 깊이가 1이므로 실제 커널 크기: (3, 3, 1) - 필터 개수가 32개이므로 weights의 첫번째 원소인 가중치의 크기: (3, 3, 1, 32) - weights의 두번째 원소는 절편의 개수를 나타냄 - 필터마다 1개의 절편이 있으므로 (32,)크기가 됨. 12conv_weights = conv.weights[0].numpy()print(conv_weights.mean(), conv_weights.std()) # 평균(mean), 표준편차(std) -0.025856383 0.21591602 1234plt.hist(conv_weights.reshape(-1, 1))plt.xlabel('weight')plt.ylabel('count')plt.show() - 0을 중심으로 종 모양 분포를 띄고 있음 12345678fig, axs = plt.subplots(2, 16, figsize=(15,2))for i in range(2): for j in range(16): axs[i, j].imshow(conv_weights[:,:,0,i*16 + j], vmin=-0.5, vmax=0.5) axs[i, j].axis('off')plt.show() 훈련하지 않은 빈 합성곱 신경망을 작성 1234no_training_model = keras.Sequential()no_training_model.add(keras.layers.Conv2D(32, kernel_size=3, activation='relu', padding='same', input_shape=(28,28,1))) 12no_training_conv = no_training_model.layers[0]print(no_training_conv.weights[0].shape) (3, 3, 1, 32) 12no_training_weights = no_training_conv.weights[0].numpy()print(no_training_weights.mean(), no_training_weights.std()) 0.0065383185 0.081879705 1234plt.hist(no_training_weights.reshape(-1, 1))plt.xlabel('weight')plt.ylabel('count')plt.show() 12345678fig, axs = plt.subplots(2, 16, figsize=(15,2))for i in range(2): for j in range(16): axs[i, j].imshow(no_training_weights[:,:,0,i*16 + j], vmin=-0.5, vmax=0.5) axs[i, j].axis('off')plt.show() - 히스토그램에서 보앗듯이 전체적으로 가중치가 밋밋하게 초기화됨. - 특징이 뚜렷하지 않음. 함수형 API 딥러닝에는 더 복잡한 모델이 많이 있음. 입력이 2개일수도 있고 출력이 2개일수도 있는데 이런 경우엔 함수형API를 사용 특성 맵 시각화12345print(model.input)conv_acti = keras.Model(model.input, model.layers[0].output)(train_input, train_target), (test_input, test_target) = keras.datasets.fashion_mnist.load_data()plt.imshow(train_input[0], cmap='gray_r')plt.show() KerasTensor(type_spec=TensorSpec(shape=(None, 28, 28, 1), dtype=tf.float32, name='conv2d_2_input'), name='conv2d_2_input', description=&quot;created by layer 'conv2d_2_input'&quot;) 123inputs = train_input[0:1].reshape(-1, 28, 28, 1)/255.0feature_maps = conv_acti.predict(inputs)print(feature_maps.shape) (1, 28, 28, 32) 32개의 필터로 인해 입력 이미지에서 강하게 활성화 된 부분을 보여줌. 12345678fig, axs = plt.subplots(4, 8, figsize=(15,8))for i in range(4): for j in range(8): axs[i, j].imshow(feature_maps[0,:,:,i*8 + j]) axs[i, j].axis('off')plt.show() 123456789101112conv2_acti = keras.Model(model.input, model.layers[2].output)feature_maps = conv2_acti.predict(train_input[0:1].reshape(-1, 28, 28, 1)/255.0)print(feature_maps.shape)fig, axs = plt.subplots(8, 8, figsize=(12,12))for i in range(8): for j in range(8): axs[i, j].imshow(feature_maps[0,:,:,i*8 + j]) axs[i, j].axis('off')plt.show() (1, 14, 14, 64) 합성곱 신경망의 앞부분에 있는 합성곱 층은 이미지의 시각적인 정보를 감지하고 뒤쪽에 있는 합성곱 층은 앞쪽에서 감지한 시각적인 정보를 바탕으로 추상적인 정보를 학습한다는 추론이 가능. 마무리 키워드 가중치 시각화: 합성곱 층의 가중치를 이미지로 출력하는것 특성 맵 시각화: 합성곱 층의 활성화 출력을 이미지로 그리는 것 함수형 API: 케라스에서 신경망 모델을 만드는 방법 중 하나. 전형적으로 입력은 Input()함수를 사용하고, 출력은 마지막 층의 출력으로 정의 TensolFlow 패키지 Conv2D: 입력의 너비와 높이 방향의 합성곱 연산을 구현한 클래스 MaxPooling2D: 입력의 너비와 높이를 줄이는 풀링 연산을 구현한 클래스 plot_model(): 케라스 모델 구조를 주피터 노트북에 그리거나 파일로 저장. Model: 케라스 모델을 만드는 클래스 matplotlib 패키지 bar(): 막대그래프를 출력","link":"/2022/04/07/0407_Convolution_Neural_Network_02/"},{"title":"LSTM과 GRU셀","text":"LSTM과 GPU셀LSTM 신경망 훈련하기 RNN은 실무에서 안씀. LSTM이 나온 배경 RNN -&gt; 문장이 길면, 학습 능력이 떨어지게됨 Long Short-Term Memory 단기 기억을 오래 기억하기 위해 고안됨. 메모장에 적듯이 업무 처리함. 데이터 불러오기12345678from tensorflow.keras.datasets import imdbfrom sklearn.model_selection import train_test_split(train_input, train_target), (test_input, test_target) = imdb.load_data( num_words=500)train_input, val_input, train_target, val_target = train_test_split( train_input, train_target, test_size=0.2, random_state=42) Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/imdb.npz 17465344/17464789 [==============================] - 0s 0us/step 17473536/17464789 [==============================] - 0s 0us/step padding1234from tensorflow.keras.preprocessing.sequence import pad_sequencestrain_seq = pad_sequences(train_input, maxlen=100)val_seq = pad_sequences(val_input, maxlen=100) 모형 만들기12345from tensorflow import kerasmodel = keras.Sequential()model.add(keras.layers.Embedding(500, 16, input_length= 100))model.add(keras.layers.LSTM(8))model.add(keras.layers.Dense(1, activation= 'sigmoid')) 1model.summary() Model: &quot;sequential&quot; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= embedding (Embedding) (None, 100, 16) 8000 lstm (LSTM) (None, 8) 800 dense (Dense) (None, 1) 9 ================================================================= Total params: 8,809 Trainable params: 8,809 Non-trainable params: 0 _________________________________________________________________ 12345678910111213rmsprop = keras.optimizers.RMSprop(learning_rate=1e-4)model.compile(optimizer=rmsprop, loss='binary_crossentropy', metrics=['accuracy'])checkpoint_cb = keras.callbacks.ModelCheckpoint('best-lstm-model.h5', save_best_only=True)early_stopping_cb = keras.callbacks.EarlyStopping(patience=3, restore_best_weights=True)# 원본 epochs = 100history = model.fit(train_seq, train_target, epochs=10, batch_size=64, validation_data=(val_seq, val_target), callbacks=[checkpoint_cb, early_stopping_cb]) Epoch 1/10 313/313 [==============================] - 20s 57ms/step - loss: 0.6929 - accuracy: 0.5167 - val_loss: 0.6923 - val_accuracy: 0.5706 Epoch 2/10 313/313 [==============================] - 15s 46ms/step - loss: 0.6914 - accuracy: 0.6021 - val_loss: 0.6902 - val_accuracy: 0.6312 Epoch 3/10 313/313 [==============================] - 16s 51ms/step - loss: 0.6869 - accuracy: 0.6435 - val_loss: 0.6816 - val_accuracy: 0.5628 Epoch 4/10 313/313 [==============================] - 14s 45ms/step - loss: 0.6530 - accuracy: 0.6578 - val_loss: 0.6313 - val_accuracy: 0.7128 Epoch 5/10 313/313 [==============================] - 13s 42ms/step - loss: 0.6149 - accuracy: 0.7222 - val_loss: 0.6105 - val_accuracy: 0.7282 Epoch 6/10 313/313 [==============================] - 13s 42ms/step - loss: 0.5949 - accuracy: 0.7358 - val_loss: 0.5939 - val_accuracy: 0.7382 Epoch 7/10 313/313 [==============================] - 13s 42ms/step - loss: 0.5780 - accuracy: 0.7503 - val_loss: 0.5786 - val_accuracy: 0.7452 Epoch 8/10 313/313 [==============================] - 13s 43ms/step - loss: 0.5623 - accuracy: 0.7577 - val_loss: 0.5654 - val_accuracy: 0.7466 Epoch 9/10 313/313 [==============================] - 13s 42ms/step - loss: 0.5480 - accuracy: 0.7663 - val_loss: 0.5516 - val_accuracy: 0.7574 Epoch 10/10 313/313 [==============================] - 13s 42ms/step - loss: 0.5343 - accuracy: 0.7711 - val_loss: 0.5400 - val_accuracy: 0.7602 손실 곡선 추가12345678import matplotlib.pyplot as pltplt.plot(history.history['loss'])plt.plot(history.history['val_loss'])plt.xlabel('epoch')plt.ylabel('loss')plt.legend(['train', 'val'])plt.show() 순환층에 드롭아웃 적용하기123456789101112131415161718192021222324252627model2 = keras.Sequential()model2.add(keras.layers.Embedding(500, 16, input_length=100))# 드롭아웃 추가model2.add(keras.layers.LSTM(8, dropout=0.3))model2.add(keras.layers.Dense(1, activation='sigmoid'))rmsprop = keras.optimizers.RMSprop(learning_rate=1e-4)model2.compile(optimizer=rmsprop, loss='binary_crossentropy', metrics=['accuracy'])checkpoint_cb = keras.callbacks.ModelCheckpoint('best-dropout-model.h5', save_best_only=True)early_stopping_cb = keras.callbacks.EarlyStopping(patience=3, restore_best_weights=True)# epcohs = 100history = model2.fit(train_seq, train_target, epochs=5, batch_size=64, validation_data=(val_seq, val_target), callbacks=[checkpoint_cb, early_stopping_cb])plt.plot(history.history['loss'])plt.plot(history.history['val_loss'])plt.xlabel('epoch')plt.ylabel('loss')plt.legend(['train', 'val'])plt.show() Epoch 1/5 313/313 [==============================] - 26s 74ms/step - loss: 0.6925 - accuracy: 0.5351 - val_loss: 0.6917 - val_accuracy: 0.5744 Epoch 2/5 313/313 [==============================] - 14s 44ms/step - loss: 0.6902 - accuracy: 0.5934 - val_loss: 0.6881 - val_accuracy: 0.6306 Epoch 3/5 313/313 [==============================] - 14s 45ms/step - loss: 0.6817 - accuracy: 0.6486 - val_loss: 0.6711 - val_accuracy: 0.6736 Epoch 4/5 313/313 [==============================] - 14s 44ms/step - loss: 0.6357 - accuracy: 0.6889 - val_loss: 0.6024 - val_accuracy: 0.6984 Epoch 5/5 313/313 [==============================] - 14s 45ms/step - loss: 0.5847 - accuracy: 0.7155 - val_loss: 0.5686 - val_accuracy: 0.7286 마무리 정리 키워드 LSTM: 타임스텝이 긴 데이터를 효과적으로 학습하기 위해 고안된 순환층. 셀 상태: LSTM셀은 은닉 상태 외에 셀상태를 출력. 셀 상태는 다음 층으로 전달되지 않으며 현재 셀에서만 순환됨. GPU: LSTM셀의 간소화 버전으로 생각 할 수 있지만 LSTM셀에 못지않는 성능을 냅니다. TensorFlow 패키지 LSTM: LSTM셀을 사용한 순환층 클래스 GRU: GRU셀을 사용한 순환층 클래스","link":"/2022/04/08/0408_LSTM,GRU_Cell/"},{"title":"IMDB리뷰","text":"순환 신경망으로 IMDB리뷰 분류 주제: 긍정리뷰, 부정리뷰 분류하기 텍스트 자체는 신경망에 전달하지 않음. (문자열 –&gt; 수식에 적용 X) 문자열을 수식으로 정하는 규칙이 매우 가변적임. if ex) He follows the cat. He loves the cat. 10- 11——- 12- 13– 10- 14—- 12- 13 고양이를 따라간다. He follows the cat. 10———– 11———- 12– 13——- 14- 15 RNN, LSTM 알고리즘 영어권 사람들이 만듬 자연어 처리와 관련된 많은 알고리즘 또한 영어권 사람들이 만듬 한글 != 영어 ( 언어가 다름을 인지 ) 성과 내려면 제품을 써야함 (=돈) (네이버 / 카카오쪽 제품) 데이터 불러오기12from tensorflow.keras.datasets import imdb(train_input, train_target), (test_input, test_target) = imdb.load_data(num_words= 500) Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/imdb.npz 17465344/17464789 [==============================] - 0s 0us/step 17473536/17464789 [==============================] - 0s 0us/step 데이터 크기 확인 (1차원 배열) 텍스트의 길이가 다 다르기 때문에 1차원 배열로 정리되어 있음 1print(train_input.shape, test_input.shape) (25000,) (25000,) 문장의 길이 확인 문장의 길이가 다 다름 123print(len(train_input[0]))print(len(train_input[1]))print(len(train_input[2])) 218 189 141 Raw 데이터 전처리 -&gt; 토큰화 작업이 끝난 상황 (문자열이 숫자로 바뀜) 1print(train_input[0]) [1, 14, 22, 16, 43, 2, 2, 2, 2, 65, 458, 2, 66, 2, 4, 173, 36, 256, 5, 25, 100, 43, 2, 112, 50, 2, 2, 9, 35, 480, 284, 5, 150, 4, 172, 112, 167, 2, 336, 385, 39, 4, 172, 2, 2, 17, 2, 38, 13, 447, 4, 192, 50, 16, 6, 147, 2, 19, 14, 22, 4, 2, 2, 469, 4, 22, 71, 87, 12, 16, 43, 2, 38, 76, 15, 13, 2, 4, 22, 17, 2, 17, 12, 16, 2, 18, 2, 5, 62, 386, 12, 8, 316, 8, 106, 5, 4, 2, 2, 16, 480, 66, 2, 33, 4, 130, 12, 16, 38, 2, 5, 25, 124, 51, 36, 135, 48, 25, 2, 33, 6, 22, 12, 215, 28, 77, 52, 5, 14, 407, 16, 82, 2, 8, 4, 107, 117, 2, 15, 256, 4, 2, 7, 2, 5, 2, 36, 71, 43, 2, 476, 26, 400, 317, 46, 7, 4, 2, 2, 13, 104, 88, 4, 381, 15, 297, 98, 32, 2, 56, 26, 141, 6, 194, 2, 18, 4, 226, 22, 21, 134, 476, 26, 480, 5, 144, 30, 2, 18, 51, 36, 28, 224, 92, 25, 104, 4, 226, 65, 16, 38, 2, 88, 12, 16, 283, 5, 16, 2, 113, 103, 32, 15, 16, 2, 19, 178, 32] Target 데이터 출력 0은 부정 리뷰 1은 긍정 리뷰 12# 0번째에서 19번째까지의 데이터print(train_target[:20]) [1 0 0 1 0 0 1 0 1 0 1 0 0 0 0 0 1 1 0 1] 데이터셋 분리1234from sklearn.model_selection import train_test_splittrain_input, val_input, train_target, val_target = train_test_split( train_input, train_target, test_size= 0.2, random_state= 42) 1train_input.shape, train_target.shape, val_input.shape, val_target.shape ((20000,), (20000,), (5000,), (5000,)) 데이터 시각화1234import numpy as np# 컴프리헨션으로 길이를 표현하는 배열 만들기lengths= np.array([len(x) for x in train_input])print(np.mean(lengths), np.median(lengths), np.max(lengths)) 238.71364 178.0 2494 123import matplotlib.pyplot as pltplt.hist(lengths)plt.show() - 250이하의 길이가 대부분임을 알 수 있음. 짧은 단어 100개만 사용 할 예정 모든 길이를 100에 맞추는 ‘패딩’작업 실행 데이터의 갯수는 20000, 전체 길이는 100으로 맞춤 12from tensorflow.keras.preprocessing.sequence import pad_sequencestrain_seq= pad_sequences(train_input, maxlen= 100) 1print(train_seq.shape) (25000, 100) 1len(train_input[0]) 218 1print(train_seq[0]) [ 2 33 6 22 12 215 28 77 52 5 14 407 16 82 2 8 4 107 117 2 15 256 4 2 7 2 5 2 36 71 43 2 476 26 400 317 46 7 4 2 2 13 104 88 4 381 15 297 98 32 2 56 26 141 6 194 2 18 4 226 22 21 134 476 26 480 5 144 30 2 18 51 36 28 224 92 25 104 4 226 65 16 38 2 88 12 16 283 5 16 2 113 103 32 15 16 2 19 178 32] 123print(train_input[0][-10:]) # 음수의 인덱스로 슬라이싱 하면 끝에서부터 세기 시작함.print()print(train_input[0][208:]) [2, 113, 103, 32, 15, 16, 2, 19, 178, 32] [2, 113, 103, 32, 15, 16, 2, 19, 178, 32] - train_seq[0]의 길이는 218로 100보다 길기때문에 패딩이 안되었음을 확인 할 수 있음 12val_seq = pad_sequences(val_input, maxlen= 100)val_seq array([[ 32, 2, 225, ..., 14, 58, 2], [ 53, 2, 8, ..., 7, 32, 2], [ 0, 0, 0, ..., 2, 33, 32], ..., [383, 2, 120, ..., 16, 99, 76], [106, 345, 12, ..., 120, 2, 156], [ 4, 114, 21, ..., 4, 2, 2]], dtype=int32) 순환신경망 만들기12345from tensorflow import kerasmodel = keras.Sequential()# 최대 길이는 100까지 패딩, imdb.load_data() 함수에서 500개의 단어만 사용하도록 지정했었음model.add(keras.layers.SimpleRNN(8, input_shape= (100, 500)))model.add(keras.layers.Dense(1, activation= 'sigmoid')) 원핫인코딩 적용 123# to_categorical(): 원핫인코딩된 배열로 반환해줌.train_oh = keras.utils.to_categorical(train_seq)print(train_oh.shape) (20000, 100, 500) - 정수 하나마다 500차원의 (20000, 100)의 크기로 들어가있음을 확인 할 수 있음 1print(train_oh[0][0][:12]) [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0.] 12# 나머지 원소에 전부 0으로 들어가있는지 확인print(np.sum(train_oh[0][0])) 1.0 12val_oh = keras.utils.to_categorical(val_seq)print(val_oh.shape) (5000, 100, 500) 1model.summary() Model: &quot;sequential_3&quot; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= simple_rnn_3 (SimpleRNN) (None, 8) 4072 dense_3 (Dense) (None, 1) 9 ================================================================= Total params: 4,081 Trainable params: 4,081 Non-trainable params: 0 _________________________________________________________________ 123456789101112rmsprop = keras.optimizers.RMSprop(learning_rate=1e-4)model.compile(optimizer=rmsprop, loss='binary_crossentropy', metrics=['accuracy'])checkpoint_cb = keras.callbacks.ModelCheckpoint('best-simplernn-model.h5', save_best_only=True)early_stopping_cb = keras.callbacks.EarlyStopping(patience=3, restore_best_weights=True)# 원본 epochs = 100history = model.fit(train_oh, train_target, epochs=100, batch_size=64, validation_data=(val_oh, val_target), callbacks=[checkpoint_cb, early_stopping_cb]) Epoch 1/100 313/313 [==============================] - 15s 44ms/step - loss: 0.5339 - accuracy: 0.7710 - val_loss: 0.5444 - val_accuracy: 0.7566 Epoch 2/100 313/313 [==============================] - 11s 36ms/step - loss: 0.5241 - accuracy: 0.7762 - val_loss: 0.5373 - val_accuracy: 0.7528 Epoch 3/100 313/313 [==============================] - 12s 37ms/step - loss: 0.5160 - accuracy: 0.7796 - val_loss: 0.5296 - val_accuracy: 0.7576 Epoch 4/100 313/313 [==============================] - 11s 36ms/step - loss: 0.5079 - accuracy: 0.7828 - val_loss: 0.5231 - val_accuracy: 0.7592 Epoch 5/100 313/313 [==============================] - 12s 37ms/step - loss: 0.4998 - accuracy: 0.7872 - val_loss: 0.5165 - val_accuracy: 0.7660 Epoch 6/100 313/313 [==============================] - 11s 36ms/step - loss: 0.4931 - accuracy: 0.7887 - val_loss: 0.5115 - val_accuracy: 0.7666 Epoch 7/100 313/313 [==============================] - 12s 37ms/step - loss: 0.4858 - accuracy: 0.7914 - val_loss: 0.5061 - val_accuracy: 0.7710 Epoch 8/100 313/313 [==============================] - 11s 36ms/step - loss: 0.4801 - accuracy: 0.7949 - val_loss: 0.5015 - val_accuracy: 0.7690 Epoch 9/100 313/313 [==============================] - 11s 37ms/step - loss: 0.4742 - accuracy: 0.7972 - val_loss: 0.4985 - val_accuracy: 0.7684 Epoch 10/100 313/313 [==============================] - 12s 38ms/step - loss: 0.4688 - accuracy: 0.7982 - val_loss: 0.4931 - val_accuracy: 0.7744 Epoch 11/100 313/313 [==============================] - 16s 50ms/step - loss: 0.4636 - accuracy: 0.8023 - val_loss: 0.4941 - val_accuracy: 0.7674 Epoch 12/100 313/313 [==============================] - 11s 36ms/step - loss: 0.4595 - accuracy: 0.8023 - val_loss: 0.4893 - val_accuracy: 0.7732 Epoch 13/100 313/313 [==============================] - 11s 36ms/step - loss: 0.4546 - accuracy: 0.8051 - val_loss: 0.4850 - val_accuracy: 0.7782 Epoch 14/100 313/313 [==============================] - 11s 36ms/step - loss: 0.4512 - accuracy: 0.8065 - val_loss: 0.4837 - val_accuracy: 0.7760 Epoch 15/100 313/313 [==============================] - 11s 36ms/step - loss: 0.4471 - accuracy: 0.8097 - val_loss: 0.4826 - val_accuracy: 0.7766 Epoch 16/100 313/313 [==============================] - 11s 36ms/step - loss: 0.4438 - accuracy: 0.8109 - val_loss: 0.4789 - val_accuracy: 0.7796 Epoch 17/100 313/313 [==============================] - 11s 36ms/step - loss: 0.4396 - accuracy: 0.8121 - val_loss: 0.4795 - val_accuracy: 0.7764 Epoch 18/100 313/313 [==============================] - 12s 38ms/step - loss: 0.4367 - accuracy: 0.8133 - val_loss: 0.4792 - val_accuracy: 0.7760 Epoch 19/100 313/313 [==============================] - 12s 40ms/step - loss: 0.4344 - accuracy: 0.8127 - val_loss: 0.4761 - val_accuracy: 0.7784 Epoch 20/100 313/313 [==============================] - 15s 47ms/step - loss: 0.4313 - accuracy: 0.8157 - val_loss: 0.4733 - val_accuracy: 0.7822 Epoch 21/100 313/313 [==============================] - 11s 37ms/step - loss: 0.4289 - accuracy: 0.8162 - val_loss: 0.4753 - val_accuracy: 0.7794 Epoch 22/100 313/313 [==============================] - 11s 35ms/step - loss: 0.4261 - accuracy: 0.8173 - val_loss: 0.4757 - val_accuracy: 0.7806 Epoch 23/100 313/313 [==============================] - 11s 36ms/step - loss: 0.4241 - accuracy: 0.8167 - val_loss: 0.4717 - val_accuracy: 0.7826 Epoch 24/100 313/313 [==============================] - 11s 36ms/step - loss: 0.4220 - accuracy: 0.8188 - val_loss: 0.4735 - val_accuracy: 0.7816 Epoch 25/100 313/313 [==============================] - 12s 37ms/step - loss: 0.4197 - accuracy: 0.8202 - val_loss: 0.4696 - val_accuracy: 0.7820 Epoch 26/100 313/313 [==============================] - 11s 36ms/step - loss: 0.4179 - accuracy: 0.8201 - val_loss: 0.4728 - val_accuracy: 0.7834 Epoch 27/100 313/313 [==============================] - 11s 36ms/step - loss: 0.4160 - accuracy: 0.8210 - val_loss: 0.4736 - val_accuracy: 0.7830 Epoch 28/100 313/313 [==============================] - 11s 36ms/step - loss: 0.4142 - accuracy: 0.8209 - val_loss: 0.4711 - val_accuracy: 0.7836 123plt.plot(history.history['loss'])plt.plot(history.history['val_loss'])plt.show() 단어 임베딩을 사용 문제점 발생: 토큰 1개를 500차원으로 늘림 -&gt; 데이터 크기가 500배 커짐 단어임베딩: 라벨인코딩과 비슷 12345from tensorflow import kerasmodel2 = keras.Sequential()model2.add(keras.layers.Embedding(500, 16, input_length= 100))model2.add(keras.layers.SimpleRNN(8))model2.add(keras.layers.Dense(1, activation= 'sigmoid')) 1model2.summary() Model: &quot;sequential_4&quot; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= embedding_2 (Embedding) (None, 100, 16) 8000 simple_rnn_4 (SimpleRNN) (None, 8) 200 dense_4 (Dense) (None, 1) 9 ================================================================= Total params: 8,209 Trainable params: 8,209 Non-trainable params: 0 _________________________________________________________________ 123456789101112rmsprop = keras.optimizers.RMSprop(learning_rate=1e-4)model2.compile(optimizer=rmsprop, loss='binary_crossentropy', metrics=['accuracy'])# 임베딩으로 Changecheckpoint_cb = keras.callbacks.ModelCheckpoint('best-embedding-model.h5', save_best_only=True)early_stopping_cb = keras.callbacks.EarlyStopping(patience=3, restore_best_weights=True)# 원본 epochs= 100history = model2.fit(train_seq, train_target, epochs=100, batch_size=64, validation_data=(val_seq, val_target), callbacks=[checkpoint_cb, early_stopping_cb]) Epoch 1/100 313/313 [==============================] - 8s 22ms/step - loss: 0.6812 - accuracy: 0.5584 - val_loss: 0.6570 - val_accuracy: 0.6208 Epoch 2/100 313/313 [==============================] - 6s 19ms/step - loss: 0.6334 - accuracy: 0.6675 - val_loss: 0.6146 - val_accuracy: 0.6916 Epoch 3/100 313/313 [==============================] - 6s 19ms/step - loss: 0.5940 - accuracy: 0.7219 - val_loss: 0.5831 - val_accuracy: 0.7314 Epoch 4/100 313/313 [==============================] - 6s 19ms/step - loss: 0.5655 - accuracy: 0.7492 - val_loss: 0.5596 - val_accuracy: 0.7450 Epoch 5/100 313/313 [==============================] - 7s 21ms/step - loss: 0.5455 - accuracy: 0.7593 - val_loss: 0.5461 - val_accuracy: 0.7518 Epoch 6/100 313/313 [==============================] - 6s 20ms/step - loss: 0.5302 - accuracy: 0.7678 - val_loss: 0.5405 - val_accuracy: 0.7446 Epoch 7/100 313/313 [==============================] - 6s 19ms/step - loss: 0.5170 - accuracy: 0.7740 - val_loss: 0.5327 - val_accuracy: 0.7492 Epoch 8/100 313/313 [==============================] - 7s 21ms/step - loss: 0.5076 - accuracy: 0.7765 - val_loss: 0.5195 - val_accuracy: 0.7598 Epoch 9/100 313/313 [==============================] - 6s 19ms/step - loss: 0.4996 - accuracy: 0.7814 - val_loss: 0.5141 - val_accuracy: 0.7592 Epoch 10/100 313/313 [==============================] - 6s 20ms/step - loss: 0.4908 - accuracy: 0.7845 - val_loss: 0.5085 - val_accuracy: 0.7642 Epoch 11/100 313/313 [==============================] - 6s 20ms/step - loss: 0.4844 - accuracy: 0.7876 - val_loss: 0.5082 - val_accuracy: 0.7598 Epoch 12/100 313/313 [==============================] - 6s 20ms/step - loss: 0.4782 - accuracy: 0.7904 - val_loss: 0.4958 - val_accuracy: 0.7722 Epoch 13/100 313/313 [==============================] - 6s 21ms/step - loss: 0.4711 - accuracy: 0.7937 - val_loss: 0.4989 - val_accuracy: 0.7644 Epoch 14/100 313/313 [==============================] - 6s 20ms/step - loss: 0.4640 - accuracy: 0.7980 - val_loss: 0.4876 - val_accuracy: 0.7740 Epoch 15/100 313/313 [==============================] - 6s 19ms/step - loss: 0.4607 - accuracy: 0.7991 - val_loss: 0.4833 - val_accuracy: 0.7770 Epoch 16/100 313/313 [==============================] - 6s 20ms/step - loss: 0.4541 - accuracy: 0.8021 - val_loss: 0.4896 - val_accuracy: 0.7682 Epoch 17/100 313/313 [==============================] - 6s 20ms/step - loss: 0.4496 - accuracy: 0.8054 - val_loss: 0.4753 - val_accuracy: 0.7810 Epoch 18/100 313/313 [==============================] - 6s 20ms/step - loss: 0.4458 - accuracy: 0.8079 - val_loss: 0.4748 - val_accuracy: 0.7790 Epoch 19/100 313/313 [==============================] - 6s 19ms/step - loss: 0.4421 - accuracy: 0.8102 - val_loss: 0.4753 - val_accuracy: 0.7786 Epoch 20/100 313/313 [==============================] - 6s 19ms/step - loss: 0.4390 - accuracy: 0.8127 - val_loss: 0.4717 - val_accuracy: 0.7772 Epoch 21/100 313/313 [==============================] - 6s 19ms/step - loss: 0.4351 - accuracy: 0.8131 - val_loss: 0.4823 - val_accuracy: 0.7732 Epoch 22/100 313/313 [==============================] - 6s 20ms/step - loss: 0.4331 - accuracy: 0.8137 - val_loss: 0.4659 - val_accuracy: 0.7842 Epoch 23/100 313/313 [==============================] - 7s 22ms/step - loss: 0.4301 - accuracy: 0.8145 - val_loss: 0.4655 - val_accuracy: 0.7812 Epoch 24/100 313/313 [==============================] - 6s 20ms/step - loss: 0.4260 - accuracy: 0.8174 - val_loss: 0.4771 - val_accuracy: 0.7754 Epoch 25/100 313/313 [==============================] - 6s 21ms/step - loss: 0.4243 - accuracy: 0.8185 - val_loss: 0.4637 - val_accuracy: 0.7846 Epoch 26/100 313/313 [==============================] - 6s 19ms/step - loss: 0.4208 - accuracy: 0.8205 - val_loss: 0.4658 - val_accuracy: 0.7834 Epoch 27/100 313/313 [==============================] - 6s 20ms/step - loss: 0.4185 - accuracy: 0.8222 - val_loss: 0.4652 - val_accuracy: 0.7820 Epoch 28/100 313/313 [==============================] - 6s 20ms/step - loss: 0.4161 - accuracy: 0.8236 - val_loss: 0.4609 - val_accuracy: 0.7866 Epoch 29/100 313/313 [==============================] - 7s 21ms/step - loss: 0.4136 - accuracy: 0.8249 - val_loss: 0.4642 - val_accuracy: 0.7860 Epoch 30/100 313/313 [==============================] - 6s 19ms/step - loss: 0.4113 - accuracy: 0.8254 - val_loss: 0.4601 - val_accuracy: 0.7876 Epoch 31/100 313/313 [==============================] - 6s 20ms/step - loss: 0.4090 - accuracy: 0.8281 - val_loss: 0.4643 - val_accuracy: 0.7824 Epoch 32/100 313/313 [==============================] - 6s 20ms/step - loss: 0.4076 - accuracy: 0.8286 - val_loss: 0.4622 - val_accuracy: 0.7874 Epoch 33/100 313/313 [==============================] - 6s 19ms/step - loss: 0.4053 - accuracy: 0.8289 - val_loss: 0.4590 - val_accuracy: 0.7882 Epoch 34/100 313/313 [==============================] - 6s 21ms/step - loss: 0.4030 - accuracy: 0.8299 - val_loss: 0.4572 - val_accuracy: 0.7902 Epoch 35/100 313/313 [==============================] - 7s 21ms/step - loss: 0.4010 - accuracy: 0.8321 - val_loss: 0.4632 - val_accuracy: 0.7878 Epoch 36/100 313/313 [==============================] - 6s 19ms/step - loss: 0.3995 - accuracy: 0.8331 - val_loss: 0.4571 - val_accuracy: 0.7914 Epoch 37/100 313/313 [==============================] - 6s 19ms/step - loss: 0.3973 - accuracy: 0.8347 - val_loss: 0.4621 - val_accuracy: 0.7892 Epoch 38/100 313/313 [==============================] - 7s 21ms/step - loss: 0.3958 - accuracy: 0.8353 - val_loss: 0.4568 - val_accuracy: 0.7916 Epoch 39/100 313/313 [==============================] - 6s 20ms/step - loss: 0.3941 - accuracy: 0.8354 - val_loss: 0.4626 - val_accuracy: 0.7868 Epoch 40/100 313/313 [==============================] - 7s 22ms/step - loss: 0.3927 - accuracy: 0.8358 - val_loss: 0.4611 - val_accuracy: 0.7886 Epoch 41/100 313/313 [==============================] - 6s 20ms/step - loss: 0.3907 - accuracy: 0.8371 - val_loss: 0.4583 - val_accuracy: 0.7912 123plt.plot(history.history['loss'])plt.plot(history.history['val_loss'])plt.show() 마무리 정리 키워드 말뭉치: 자연어 처리에서 사용하는 텍스트 데이터의 모음. (= 훈련 데이터셋) 토큰: 텍스트에서 공백으로 구분되는 문자열 종종 소문자로 변환하고 구둣점은 삭제 원-핫 인코딩: 어떤 클래스에 해당하는 원소만 1이고 나머지는 모두 0인 벡터 단어 임베딩: 정수로 변환된 토큰을 비교적 작은 크기의 실수 밀집 벡터로 변환. 이런 밀집 벡터는 단어 사이의 관계를 표현 할 수 있기 때문에 자연어 처리에서 좋은 성능을 발휘 TensorFlow 패키지 pad_sequences(): 시퀀스 길이를 맞추기 위해 패딩을 추가. (샘플 개수, 타임스텝 개수)크기의 2차원 배열로 나옴. 매개변수 maxlen: 원하는 시퀀스 길이를 지정. 지정한 값보다 긴 시퀀스는 잘리고, 짧은 시퀀스는 패딩됨. to_categorical(): 정수 시퀀스를 원 핫 인코딩으로 변환. 토큰이나 타깃값을 원핫 인코딩 할 때 사용 SumpleRNN: 케라스의 기본 순환층 클래스 Embedding: 단어 임베딩을 위한 클래스","link":"/2022/04/08/0408_IMDB/"},{"title":"코딩도장 문제 01","text":"3과 5의 배수의 문제 코딩도장에 있는 퀴즈 (추천 1위) https://codingdojang.com/scode/350?answer_mode=hide 10미만의 자연수에서 3과 5의 배수를 구하면 3,5,6,9이다. 이들의 총합은 23이다. 1000미만의 자연수에서 3,5의 배수의 총합을 구하라. 123456789# 나머지를 구하는 방법: %# ex)print(&quot;%로 나머지를 구하는 방법 : 17 % 4 =&quot;,17 % 4)# 함수를 이용하는 방법: divmod()# ex)divmod(17, 4)[1]print(&quot;divmod(17, 4):&quot;, divmod(17, 4))print(&quot;divmod(17, 4)[1]:&quot;, divmod(17, 4)[1]) %로 나머지를 구하는 방법 : 17 % 4 = 1 divmod(17, 4): (4, 1) divmod(17, 4)[1]: 1 1234567891011quest1 = 1000Q_list = []for i in range(1, quest1): if divmod(i, 3)[1] == 0: Q_list.append(i) elif divmod(i, 5)[1] == 0: Q_list.append(i) else: continueprint(Q_list) [3, 5, 6, 9, 10, 12, 15, 18, 20, 21, 24, 25, 27, 30, 33, 35, 36, 39, 40, 42, 45, 48, 50, 51, 54, 55, 57, 60, 63, 65, 66, 69, 70, 72, 75, 78, 80, 81, 84, 85, 87, 90, 93, 95, 96, 99, 100, 102, 105, 108, 110, 111, 114, 115, 117, 120, 123, 125, 126, 129, 130, 132, 135, 138, 140, 141, 144, 145, 147, 150, 153, 155, 156, 159, 160, 162, 165, 168, 170, 171, 174, 175, 177, 180, 183, 185, 186, 189, 190, 192, 195, 198, 200, 201, 204, 205, 207, 210, 213, 215, 216, 219, 220, 222, 225, 228, 230, 231, 234, 235, 237, 240, 243, 245, 246, 249, 250, 252, 255, 258, 260, 261, 264, 265, 267, 270, 273, 275, 276, 279, 280, 282, 285, 288, 290, 291, 294, 295, 297, 300, 303, 305, 306, 309, 310, 312, 315, 318, 320, 321, 324, 325, 327, 330, 333, 335, 336, 339, 340, 342, 345, 348, 350, 351, 354, 355, 357, 360, 363, 365, 366, 369, 370, 372, 375, 378, 380, 381, 384, 385, 387, 390, 393, 395, 396, 399, 400, 402, 405, 408, 410, 411, 414, 415, 417, 420, 423, 425, 426, 429, 430, 432, 435, 438, 440, 441, 444, 445, 447, 450, 453, 455, 456, 459, 460, 462, 465, 468, 470, 471, 474, 475, 477, 480, 483, 485, 486, 489, 490, 492, 495, 498, 500, 501, 504, 505, 507, 510, 513, 515, 516, 519, 520, 522, 525, 528, 530, 531, 534, 535, 537, 540, 543, 545, 546, 549, 550, 552, 555, 558, 560, 561, 564, 565, 567, 570, 573, 575, 576, 579, 580, 582, 585, 588, 590, 591, 594, 595, 597, 600, 603, 605, 606, 609, 610, 612, 615, 618, 620, 621, 624, 625, 627, 630, 633, 635, 636, 639, 640, 642, 645, 648, 650, 651, 654, 655, 657, 660, 663, 665, 666, 669, 670, 672, 675, 678, 680, 681, 684, 685, 687, 690, 693, 695, 696, 699, 700, 702, 705, 708, 710, 711, 714, 715, 717, 720, 723, 725, 726, 729, 730, 732, 735, 738, 740, 741, 744, 745, 747, 750, 753, 755, 756, 759, 760, 762, 765, 768, 770, 771, 774, 775, 777, 780, 783, 785, 786, 789, 790, 792, 795, 798, 800, 801, 804, 805, 807, 810, 813, 815, 816, 819, 820, 822, 825, 828, 830, 831, 834, 835, 837, 840, 843, 845, 846, 849, 850, 852, 855, 858, 860, 861, 864, 865, 867, 870, 873, 875, 876, 879, 880, 882, 885, 888, 890, 891, 894, 895, 897, 900, 903, 905, 906, 909, 910, 912, 915, 918, 920, 921, 924, 925, 927, 930, 933, 935, 936, 939, 940, 942, 945, 948, 950, 951, 954, 955, 957, 960, 963, 965, 966, 969, 970, 972, 975, 978, 980, 981, 984, 985, 987, 990, 993, 995, 996, 999] 12345target = 0for i in range(0, len(Q_list)): target = target + Q_list[i]print(target) 233168 123# 모범답안:sum([x for x in range(1000) if x%3==0 or x%5==0])# 리스트 컴프리헨션 적용한 코드 233168","link":"/2022/04/12/0412_Multiples_of_3_and_5/"},{"title":"Kibana 설치","text":"kibana 설치 설명: Elasticsearch 데이터를 시각화하고 Elastic Stack을 탐색하게 해주는 무료 오픈소스 인터페이스 kibana 설치 1$ sudo apt-get install kibana kibana 서비스를 활성화 1$ sudo systemctl enable kibana 서비스를 시작하고, 확인 12$ sudo systemctl start kibana$ sudo systemctl status kibana 로컬에서 확인 http://localhost:5601/","link":"/2022/04/13/0413_Kibana_Install/"},{"title":"라이브러리 &#x2F; 가상 환경 &#x2F; pip, pip3 기능","text":"라이브러리 / 가상 환경 / pip, pip3 기능라이브러리 (Library): 소프트웨어 개발 시 자주 쓰거나 특정한 기능을 모듈로 만들어 사용자들이 사용 할 수 있게 만들어둔것. 가상 환경 (virtual environment): 작업하는 프로젝트마다 같은 라이브러리를 사용하더라도 쓸 때 마다 버전이 달라지곤 하는데, 이를 해결하기 위해 가상 환경이라는 독립적인 공간을 만들어 해결 할 수 있다. WSL(Windows Subsystem for Linux)에서 가상 환경을 만들고 적용 (예시) 123$ sudo pip3 install virtualenv # 패키지가 없다면 설치$ virtualenv venv$ source venv/bin/activate pip, pip3: pip: python2 버전의 패키지를 설치하는 기능pip3: python3 버전의 패키지를 설치하는 기능—&gt; 파이썬 버전에 맞게 사용 WSL에서 python3 패키지를 패키지를 설치 (예시) $ pip3 install elasticsearch 버전을 확인하는 temp.py를 작성 버전 확인 1$ python3 temp.py WSL에서 다운그레이드 하고 버전 확인 $ pip3 install elasticsearch==7.6.0 $ python3 temp.py 설치한 패키지 목록 $ pip3 list","link":"/2022/04/17/0417_Library_venv_pip3/"},{"title":"VSCode Remote 기능 연동하기","text":"0417_VSCode_Remote_functionVSCode에서 remote를 검색하여 설치 터미널을 켜고 WSL이 있는지 확인 WSL에서 가상환경으로 설정 1$ source venv/bin/activate Chapter03 파일 속 hello.py 파일을 만들고 저장 vscode의 wsl터미널에서 hello.py 파이썬 파일 실행 1$ python3 hello.py hello.py 를 수정하고 다시 실행","link":"/2022/04/17/0417_VSCode_Remote_function/"},{"title":"PostgreSQL 설치","text":"0417_PostgreSQL(pgAdmin)_insert 설명: 확장 가능성 및 표준 준수를 강조하는 객체-관계형 데이터베이스 관리 시스템의 하나 PostgreSQL 서비스를 실행, 상태 확인 12$ sudo service postgresql strat$ sudo service postgresql status PostgreSQL 아이디 비밀번호 설정 1$ sudo -u postgres psql -c “ALTER USER postgres PASSWORD ‘postgres’;” General탭에서 ‘Name’에 users를 입력(필자는 users2로 작성) Column탭에는 아래의 테이블을 추가 (Save) wsl에서 제대로 저장이 되었는지 확인하러 갑니다.(l: List 로 추측됨) 123$ sudo -u postgres psql$ \\l dataengineering으로 접속(c: connect 로 추측됨) 1$ \\c dataengineering 데이터 테이블을 확인(dt: datatable 로 추측됨) 1$ \\dt 제대로 확인이 된다면 빠져나옴.(q: quit 로 추측됨) 123$ \\q$ sudo service postgresql stop","link":"/2022/04/17/0417_PostgreSQL(pgAdmin)_insert/"},{"title":"Apache Airflow 설치","text":"0417_Apache_Airflow_install airflow를 설치하기 위해 pip를 설치 1$ sudo apt install python3-pip 라이브러리 설치 1$ sudo pip3 install virtualenv 가상환경 생성 1$ virtualenv venv 가상환경 접속 1$ source venv/bin/activate bashrc 설정 (아래 두줄이 같은 결과가 나오게 해야함) 12345$ vi ~/.bashrc$ source ~/.bashrc# $ source venv/bin/activate$ echo $AIRFLOW_HOME$ pwd 가상환경 취소 / 적용하는 방법 12$ deactive$ source venv/bin/activate PostgreSQL, Slack, Celery 패키지 설치 (진행중인 상황) 1$ pip3 install ‘apache-airflow[postgres, slack, celery]’ DB 초기화 1$ airflow db init username 설정 1$ airflow users create --username airflow --password airflow --firstname name --lastname airflow --role Admin --email my@email.com webserver를 실행 1$ airflow webserver -p 8081 정상적으로 작동 되는지 http://localhost:8081/login/ 에 접속 airflow.cfg 파일에 들어가서 load_examples 부분이 True이면 False로 바꾸고 저장. DB 초기화 1$ airflow db reset 웹서버 실행 (DB가 비어있는것을 확인) 1$ airflow webserver","link":"/2022/04/17/0417_Apache_Airflow_install/"},{"title":"Kibana 설치","text":"0417_kibana_install 설명: Elasticsearch 데이터를 시각화하고 Elastic Stack을 탐색하게 해주는 무료 오픈소스 인터페이스 kibana 설치 1$ sudo apt-get install kibana kibana 서비스를 활성화 1$ sudo systemctl enable kibana 서비스를 시작하고, 확인 12$ sudo systemctl start kibana$ sudo systemctl status kibana 로컬에서 확인 http://localhost:5601/ 끝났으면 서비스를 중지한다. 1$ sudo systemctl stop kibana 끝","link":"/2022/04/18/0418_kibana_install/"},{"title":"Elasticsearch 설치","text":"0418_Elasticsearch_install 설명: HTTP웹 인터페이스와 스키마에서 자유로운 JSON문서와 함께 분산 멀티테넌트 지원 전문 검색 엔진을 제공 시스템 업데이트 및 업그레이드 12$ sudo apt update$ sudo apt upgrade HTTPS관련 패키지 설치, 자바 설치 (설치중인 모습) 12$ sudo apt install apt-transport-https$ sudo apt install openjdk-11-jdk # Y 설치한 버전 확인 1$ java -version 환경변수 설정하기 위해 아래 문구를 입력 1$ sudo vi /etc/environment JAVA_HOME=”/usr/lib/jvm/java-11-openjdk-amd64 환경변수 업데이트 1$ source /etc/environment 적용 되었는지 확인 1$ echo $JAVA_HOME Elasticsearch 설치 GPG keys를 확인하여 설치, 라이브러리 설치 12$ wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -$ sudo sh -c 'echo &quot;deb https://artifacts.elastic.co/packages/7.x/apt stable main&quot; &gt; /etc/apt/sources.list.d/elastic-7.x.list' elasticsearch 설치 123$ sudo apt-get update$ sudo apt-get install elasticsearch elasticsearch 서비스를 시작 1$ sudo systemctl start elasticsearch 실행 시켰을 때 아래의 에러가 뜬다면 다음 코드를 입력해야한다. System has not been booted with systemd as init system (PID 1).Can’t operate. Failed to connect to bus: Host is down 123$ sudo -b unshare --pid --fork --mount-proc /lib/systemd/systemd --system-unit=basic.target$ sudo -E nsenter --all -t $(pgrep -xo systemd) runuser -P -l $USER -c &quot;exec $SHELL&quot;$ sudo systemctl enable elasticsearch 다시 서비스를 실행시켜본다. 1$ sudo systemctl start elasticsearch 실제로 작동하는지 확인해본다. 1curl -X GET &quot;localhost:9200/&quot; 인터넷 환경에서도 확인해본다http://localhost:9200/ 끝났으면 서비스를 중지한다. 1$ sudo systemctl stop elasticsearch 끝","link":"/2022/04/18/0418_Elasticsearch_install/"},{"title":"Ubuntu 설치","text":"0418_Ubuntu_installmicrosoft store 설치 아이디 패스워드 설정 버전 확인 수도 업데이트/업그레이드 12$ sudo apt-get update$ sudo apt-get upgrade # Y pip3 를 설치해달라는 문구를 확인 $ sudo apt install python3-pip virtualenv 패키지 설치 $ pip3 install virtualenv 폴더를 만들고 접속 가상환경 구축 $ virtualenv venv 가상환경 적용 $ source venv/bin/activate 라이브러리 설치중 java의 문제로 경고나 에러가 뜬다면 자바가 제대로 호출이 되는지 확인할것1$ sudo vi /etc/environment JAVA_HOME=”/usr/lib/jvm/java-11-openjdk-amd64” 업데이트 후 경로 확인 (현재 wsl환경이 문제인지 매번 업데이트해줘야하는 상황.) 12$ source /etc/environment$ echo $JAVA_HONE","link":"/2022/04/18/0418_Ubuntu_install/"},{"title":"Apache NiFi 설치","text":"0418_Apache_NiFi_install 설명.1 : 소프트웨어 시스템 간 데이터 흐름을 자동화하도록 설계된 아파치 소프트웨어 재단의 소프트웨어 프로젝트 설명.2 : 시스템 간 데이터 전달을 효율적으로 처리, 관리, 모니터링 하기에 최적화된 시스템 curl을 이용하여 nifi를 현재 경로에 설치 1$ sudo wget [https://downloads.apache.org/nifi/1.16.0/nifi-1.16.0-bin.tar.gz](https://downloads.apache.org/nifi/1.16.0/nifi-1.16.0-bin.tar.gz) tar.gz 압축 풀기 1$ sudo tar xvzf nifi-1.16.0-bin.tar.gz NiFi 아이디 비밀번호 세팅아이디: human비밀번호: human1234567890 (10자리 이상) 1$ sudo ./bin/nifi.sh set-single-user-credentials human human1234567890 NiFI 실행(ubuntu) 1$ sudo ./bin/nifi.sh start https://127.0.0.1:8443/nifi 접속 ( 시간이 많이 소요됨. )","link":"/2022/04/18/0418_Apache_NiFi_install/"},{"title":"Apache Spark 설치","text":"0419_Apache_Spark_install spark 설치 (자바 설치가 선행되어야 함) https://www.apache.org/dyn/closer.lua/spark/spark-3.2.0/spark-3.2.0-bin-hadoop3.2.tgz 홈페이지 들어가서 https://archive.apache.org/dist/spark/spark-3.2.0/spark-3.2.0-bin-hadoop3.2.tgz 링크를 클릭해서 설치 tgz 압축을 풀기 위한 WinRAR archiver 설치 https://github.com/cdarlint/winutils 링크 들어가서 spark의 버전과 맞는 폴더의 winutlis.exe 파일 설치(download) 설치한 프로그램들을 hadoop폴더로 모아서 정리 winrar 설치 ( 자바 설치를 선행 ) 스파크를 Extract to “spark-3.2.0-bin-hadoop3.2\\” 클릭해서 설치 spark 폴더가 생성됨 spark 폴더를 c드라이브로 옮김 conf 폴더(설정 폴더)의 log4j.properties 를 메모장으로 열고,log4j.rootCategory=INFO, console 부분을log4j.rootCategory=ERROR, console 로 수정 c드라이브에 winutils 폴더 내부에 bin 폴더 만듦 c드라이브에 tmp 폴더 내부에 hive 폴더 만듦 폴더가 없을 경우 ChangeFileModeByMask error (3) 의 **에러가 나올 수 있음. winutils.exe 파일을 hadoop에서 hive폴더 내부로 옮김 cmd(명령 프롬프트)에서 명령어 작성 1$ winutils.exe chmod 777 \\tmp\\hive -&gt; chmod: 파일들이나 디렉토리의 파일 시스템 모드들을 바꿈. 그 모드들은 허가나 특별한 모드들을 포함. —&gt;1= 실행 권한, 2= 쓰기 권한, 4= 읽기 권한—&gt; chmod 777: 모든 사용자들에게 모든 권한을 허용 (권장되지 않음) ——&gt; 따라서 user권한(1+2+4) group권한(1+2+4) other권한(1+2+4) ⇒ 1(읽기 됨) + 2(쓰기 됨) + 3(실행 됨) 을 뜻함. 시스템 환경변수 편집 실행 환경 변수(N)… 클릭 ‘사용자 변수’ 탭의 새로 만들기 클릭 SPARK_HOME 환경변수 설정 SPARK_HOMEC:\\spark JAVA_HOME 환경변수 설정 JAVA_HOME C:\\jdk HADOOP_HOME 환경변수 설정 HADOOP_HOME C:\\winutils 파이썬 환경 설정 끝나면 4개 항목이 추가된 것을 확인 사용자 변수 중에 Path를 찾아서 아래의 코드를 추가%SPARK_HOME%\\bin%JAVA_HOME%\\bin cmd(명령 프롬프트) 켜고 spark폴더로 접속 $ cd c:\\spark pyspark 실행 $ pyspark http:README.md파일을 불러와서 아래 코드가 실행되는지 확인 123$ rd= sc.textFile(”README.md”)$ rd.count()# 109 주피터노트북에서 사용 할 때는 아래 설정을 추가해야 함.PYSPARK_DRIVER_PYTHONjupyterPYSPARK_DRIVER_PYTHON_OPTSnotebook 추가된 것을 확인 C드라이브에 추가한 폴더:jdk, jre hadoop, spark, tmp, winutils","link":"/2022/04/19/0419_Apache_Spark_install/"},{"title":"Java 설치","text":"0419_Java_install https://www.oracle.com/java/technologies/javase/javase8u211-later-archive-downloads.html 홈페이지 접속해서 oracle 로그인 Windows x64 installer 설치 설치 경로에 공백이 있으면 문제가 생길 수 있으니 공백이 없는 경로를 지정해주는게 중요하다 — C:\\jdk — C:\\jdr 예시","link":"/2022/04/19/0419_Java_install/"},{"title":"PySpark 설치 WSL환경","text":"0420_Spark_install_on_WSL java 8버전이나 11버전 설치 선행 필요spark홈페이지에서 다운받고 spark라는 폴더에 설치 선행 필요 환경변수 세팅 1$ vi ~/.bashrc 아래 문구를 추가 12345$ export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64$ export SPARK_HOME=/mnt/c/spark$ export PATH=$JAVA_HOME/bin:$PATH$ export PATH=$SPARK_HOME/bin:$PATH$ export PYSPARK_PYTHON=/usr/bin/python3 → JAVA_HOME에는 아래 경로를 입력 → SPARK_HOME에는 아래 경로를 입력 bashrc파일 업데이트하고 제대로 설정이 되었는지 확인 123$ source ~/.bashrc$ echo $JAVA_HOME$ echo $SPARK_HOME pyspark 실행 1$ pyspark 아래 코드가 실행되는지 확인 123$ rd = sc.textFile(&quot;README.md&quot;)$ rd.count()# 109 종료 1$ quit()","link":"/2022/04/20/0420_Apache_Spark_install_on_WSL/"},{"title":"Pyspark 연습","text":"0420_Pyspark_tutorialspark홈페이지https://spark.apache.org/docs/latest/quick-start.html SimpleApp.py 작성(홈페이지에서 볼 수 있는 예제문에서 input()을 추가함) 1234567891011121314from pyspark.sql import SparkSessionlogFile = &quot;README.md&quot; # Should be some file on your systemspark = SparkSession.builder.appName(&quot;SimpleApp&quot;).getOrCreate()logData = spark.read.text(logFile).cache()numAs = logData.filter(logData.value.contains('a')).count()numBs = logData.filter(logData.value.contains('b')).count()print(&quot;Lines with a: %i, lines with b: %i&quot; % (numAs, numBs))input(&quot;Typing....&quot;)spark.stop() README.md 작성 README.md파일 내용 This program just counts the number of lines containing ‘a’ and the number containing ‘b’ in a text file. Note that you’ll need to replace YOUR_SPARK_HOME with the location where Spark is installed. As with the Scala and Java examples, we use a SparkSession to create Datasets. For applications that use custom classes or third-party libraries, we can also add code dependencies to spark-submit through its –py-files argument by packaging them into a .zip file (see spark-submit –help for details). SimpleApp is simple enough that we do not need to specify any code dependencies. We can run this application using the bin/spark-submit script: 제대로 작성 됐는지 cat 명령어로도 확인가능 1$ cat README.md 스파크 홈페이지에 연동하여 실행 1$ $SPARK_HOME/bin/spark-submit --master local[4] [SimpleApp.py](http://simpleapp.py/) =⇒ 윈도우에서 확인 http://localhost:4040/ 배포=⇒ spark-submit 예제 1. data 폴더와 friends-by-age.py 작성 spark 실행 후 http://172.22.156.103:4040 접속 1$ $SPARK_HOME/bin/spark-submit --master local[4] [friends-by-age.py](http://friends-by-age.py) =⇒ ——&gt; 500개의 record가 있는것을 확인 예제 2. titalspent.py 작성(main함수 삭제)(input이라는 객체를 생성했어서 input을 inputs로 변경) 실행하고 UI로 확인http://172.22.156.103:4040/ =⇒ ——&gt; 10000개의 record가 있다는것을 확인 가능","link":"/2022/04/20/0420_Pyspark_tutorial/"},{"title":"Selenium 연습","text":"0422_Crawling_Selenium_on_gitbash 가상환경 만들고 적용 패키지 설치 $ pip install selenium 크롬 버전 확인 크롬 드라이버 다운로드크롬에 chrome driver 검색하고 홈페이지 들어가기https://chromedriver.chromium.org/downloads 맞는 버전과 운영체제로 다운받음. 드라이버를 내가 사용할 폴더로 옮김 temp.py 작성 12345from selenium import webdriverfrom selenium.webdriver.common.keys import Keysdriver = webdriver.Chrome()driver.get(&quot;https://www.google.com/&quot;) 실행 $ python temp.py 입력창에 리그 오브 레전드를 입력 12elem= driver.find_element_by_name(&quot;q&quot;)elem.send_keys(&quot;python&quot;) 검색버튼 누르기 1elem.send_keys(Keys.RETURN) 클래스 이름으로 조회 찾으려고 했더니 다수의 동일한 클래스 이름들이 조회됨. 0번째의 text를 target 객체로 만들어 출력 123$ target= driver.find_elements_by_css_selector(&quot;.LC20lb.MBeuO.DKV0Md&quot;)[0].text$ driver.close()$ print(target) 연습 끝! 여러 시행착오 끝에 네이버같은 링크를 들어갈 때 새로운 탭이 열리는 경우엔 셀레니움이 인식을 못하는 것을 알아냄! 계속 실패하던 더보기 버튼 누르는것까지 구현함. 12345678910111213141516171819202122$ from selenium import webdriver$ from selenium.webdriver.common.keys import Keys$ import time$ driver = webdriver.Chrome()$ driver.get(&quot;https://game.naver.com/lounge/League_of_Legends/db/champion&quot;)$ time.sleep(5)# # 1번째 챔피언 이름 추출$ fir= &quot;.card_content-header__title__oJkdR&quot;$ target= driver.find_elements_by_css_selector(fir)[0].text$ print(&quot;--------------&quot;)$ print(target)$ print(&quot;--------------&quot;)# # 더보기 버튼 클릭$ sec= &quot;.gamedb_icon__1jSHy&quot;$ driver.find_element_by_css_selector(sec).click()# 종료 단계# driver.close()$ print(&quot;good&quot;)","link":"/2022/04/22/0422_Crawling_Selenium_on_gitbash/"},{"title":"데이터베이스의 객체","text":"0425_DataBase_Object 문자열 (영어)크기 문자열 (한글) 크기한글자당 3byte를 차지하기에 column의 크기를 명시해뒀다면 크기를 유념해서 입력해야한다. 숫자열 크기 FLOAT형의 특징때문에 뒤는 0으로 잘려서 나오는 현상FLOAT[(p)] : NUMBER의 하위 타입, p는 1~128, 디폴트 값은 128, 이진수 기준 최대 22byte 날짜 데이터 타입","link":"/2022/04/25/0425_DataBase_Object/"},{"title":"예외 처리","text":"0425_Exception_Handling 에러가 나올 때 처리하는 코드를 찾아냄 1234try: ...except (에러 이름): ... 예시 코드 에러 메세지도 형식에 맞춰서 넣어야하는데,에러 메세지는 터미널에서 찾아 넣으면 된다. 최종 코드 123456789a_li = [&quot;a&quot;, &quot;b&quot;]try: print(a_li[2])except IndexError: pass print(&quot;no!&quot;)print(&quot;end...&quot;) ——&gt;셀레니움에 적용시킬 코드 1234567891011121314while True: try: more.click() time.sleep(1) more= driver.find_element_by_css_selector(sec) print(i) except Exception as error: print(&quot;Here!&quot;) i= &quot;break&quot; print(i) print(error) print(&quot;step&quot;) break","link":"/2022/04/25/0425_Exception_Handling/"},{"title":"Oracle SQL 삭제","text":"0425_Oracle_SQL_deinsert 오라클 설치중에 중지 시켜 전부 다 삭제하고 다시 설치를 시작해야 하는 상황인데 그냥 삭제하려니까 삭제가 안됨. 제어판에서 관리도구 선택 서비스 메뉴를 선택하여 oracle로 시작하는 모든 서비스를 중지시킨다. deinstall 폴더의 deinstall 파일을 관리자 권한으로 실행필자의 경로C:\\sql_lecture\\db_homes\\WINDOWS.X64_193000_db_home\\deinstall 실행하면 명령프롬프트 창이 나오는데엔터나 y만 누르다가 삭제 할 데이터베이스의 이름 목록을 적으라는 부분에서 데이터 베이스를 적어주고, 저장 영역 유형은 FS로 적어준다.나머지는 y를 눌러 넘어가주면 됨 레지스트리 편집기를 켠다. HKEY_LOCAL_MACHINE - &gt; SOFTWARE - &gt; ORACLE로 시작하는 항목 삭제 HKEY_LOCAL_MACHINE - &gt; SYSTEM - &gt; ControlSet001 - &gt; service - &gt; ORACLE로 시작하는 항목 삭제 HKEY_LOCAL_MACHINE - &gt; SYSTEM - &gt; ControlSet002 - &gt; service - &gt; ORACLE로 시작하는 항목 삭제 HKEY_LOCAL_MACHINE - &gt; SYSTEM - &gt; CurrentControlSet - &gt; service - &gt; ORACLE로 시작하는 항목 삭제 컴퓨터를 재부팅하고 오라클 홈 디렉토리에 파일이 남아있다면 삭제하면 끝남.","link":"/2022/04/25/0425_Oracle_SQL_deinsert/"},{"title":"셀레니움을 이용하여 LOL데이터 크롤링","text":"0425_Sellenium_LOLchampions_name 셀레니움을 이용하여 LOL게임의 챔피언 이름들 추출 웹페이지를 보며 30개밖에 안나오는 리스트를 더보기 버튼을 눌러 리스트를 더 불러올 필요가 있다고 생각했다. 더보기 버튼이 나오지 않을때까지 처음에는 for문으로 원하는 조건이 나올때까지 돌리려는 생각을 했지만 for문 특성상 정해진 횟수를 제어 할 수 없었다. 그래서 찾아낸게, while문으로 특정 조건을 걸어두지 않으면 무한루프가 돌아간다는것을 찾아냄. 123456while True: more.click() time.sleep(1) target= driver.find_elements_by_css_selector(fir) if divmod(len(target), 30)[1] != 0 : break 이름은 챔피언 박스를 list로 만들어 names에 append함수를 이용하여 추출 1234names= []for i in target: names.append(i.text)print(names) 0424_최종 코드 1234567891011121314151617181920212223242526272829303132from selenium import webdriverfrom selenium.webdriver.common.keys import Keysimport timedriver = webdriver.Chrome()driver.get(&quot;https://game.naver.com/lounge/League_of_Legends/db/champion&quot;)time.sleep(5)# # 1번째 챔피언 이름 추출fir= &quot;.card_content-header__title__oJkdR&quot;# target : 챔피언 박스 listtarget= driver.find_elements_by_css_selector(fir)sec= &quot;.gamedb_icon__1jSHy&quot;# more : 더보기 버튼more= driver.find_element_by_css_selector(sec)while True: more.click() time.sleep(1) target= driver.find_elements_by_css_selector(fir) if divmod(len(target), 30)[1] != 0 : breaknames= []for i in target: names.append(i.text)print(names)# 종료 단계driver.close()print(&quot;end...&quot;) 당장 원하는 기능은 구현 했지만 while문의 조건 (list를 30으로 나눴을 때의 나머지가 0이 아니라면) 이 완벽하지 않기에 수정 할 필요는 있어보임. 조건을 error가 뜰때까지나 css_selector의 기능이 가능하다면 같은 조건식을 찾아내면 수정하면 흠이 없을거라는 생각중이다. ps) 웹페이지에 최종 목록의 수가 명시되어있는데 이걸 이용해도 괜찮을거라는 생각. 0424_이미지 긁어오는 코드 추가 1234567thi = &quot;.card_thumbnail__image__2xUgG&quot;# img : 이미지 srcimg= driver.find_elements_by_css_selector(thi)[0].get_attribute('src')print(&quot;------------&quot;)print(img)print(&quot;------------&quot;) 0425_최종 코드타겟 개수가 180개일 때 같은 예외 상황 해결 + 이미지 긁어오기 구현names: 이름들images: 이미지들 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from selenium import webdriverfrom selenium.webdriver.common.keys import Keysimport timedriver = webdriver.Chrome()driver.get(&quot;https://game.naver.com/lounge/League_of_Legends/db/champion&quot;)# 로딩시간 필요하여 3초간 쉬기time.sleep(3)fir= &quot;.card_content-header__title__oJkdR&quot;# target : 챔피언 박스 listtarget= driver.find_elements_by_css_selector(fir)sec= &quot;.gamedb_icon__1jSHy&quot;# more : 더보기 버튼more= driver.find_element_by_css_selector(sec)# 더보기 누를때 continue 출력# 더보기 없을때 break 출력while True: try: more.click() time.sleep(1) more= driver.find_element_by_css_selector(sec) print(&quot;continue&quot;) except Exception as error: print(&quot;break&quot;) print(error) print(&quot;step&quot;) break# 더보기 버튼 끝까지 클릭하기# 이름 출력names= []for i in target: names.append(i.text)print(names)thi = &quot;.card_thumbnail__image__2xUgG&quot;img= driver.find_elements_by_css_selector(thi)images= []for i in img: images.append(i.get_attribute('src'))print(len(images))# 종료 단계driver.close()print(&quot;end...&quot;)","link":"/2022/04/25/0425_Sellenium_LOLchampions_name/"},{"title":"Oracle SQL 설치","text":"0425_Oracle_SQL_install_on_windowOracle SQL 설치 구글 oracle database 19c download 검색 오라클 로그인 후 다운로드하기 db_home이라는 폴더에 압축 풀어둠.setup파일 관리자권한으로 실행 단일 인스턴스 데이터베이스 생성 및 구성 (default) 데스크탑 클래스 (default) 가상계정 사용 (default) 컨테이너 데이터베이스 설정 (해제)데이터베이스 명: myoracle비밀번호: 1234 바로 설치 (default) 설치 진행중 세팅하기 설치가 끝났다면, SQL Plus 관리자 권한으로 실행 실행시 사용자명과 비밀번호 설정 해야함.사용자명은 system비밀번호는 1234로 지정 테이블 스페이스를 myts라는 이름으로 100MB 크기로 생성데이터가 증가하면 5MB씩 자동 증가 옵션 추가 1$ CREATE TABLESPACE myts DATAFINE 'C:\\sql_lecture\\db_homes\\oradata\\MYORACLE\\myts.dbf' SIZE 100M AUTOEXTEND ON NEXT 5M; 사용자 생성하고 권한 부여사용자명 ora_user비밀번호 evan 12345CREATE USER ora_user IDENTIFIED BY evan DEFAULT TABLESPACE MYTS TEMPORARY TABLESPACE TEMP;# 사용자가 생성되었습니다.GRANT DBA TO ora_user;# 권한이 부여되었습니다. 사용자 계정으로 DB에 접속 123connect ora_user/evanselcet user from dual; Oracle Develop 설치 구글에 sql developer download 검색 로그인 후 설치 세팅하기 도구 - 환경설정 - 데이터베이스 - NLS시간기록 TZ형식을 복사하여 시간기록형식에 붙여넣음 코드를 입력하고 실행(F5) 아래 두개 프로그램 다운로드https://github.com/gilbutITbook/006696/tree/master/01장 환경설정 c드라이브 아래에 백업 폴더 만들고 방금 다운한 두개의 파일을 옮김. 명령프롬프트(cmd)창에서 설치 123imp ora_user/evan file=expall.dmp log=empall.log ignore=y grants=y rows=y indexes=y full=y imp ora_user/evan file=expcust.dmp log=expcust.log ignore=y grants=y rows=y indexes=y full=y sql developer에서 명령어 입력 후 실행 1SELECt table_name FROM user_tables; 연습 SQL Plus를 실행 로그인하기사용자명 : system비밀번호 : 1234 연결하기 1connect ora_user/evan 확인하기 1show user 테이블 생성해보기 사이드바에서도 생성된걸 확인 가능 가능 상단에 SQL탭을 누르면 코드가 나온다.","link":"/2022/04/25/0425_Oracle_SQL_install_on_window/"},{"title":"SQL Query문","text":"0426_SQL_QuerySELECT문: 테이블이나 뷰에 있는 데이터를 조회 할 때 사용하는 명령문 SELECT * 혹은 컬럼FROM * 테이블 또는 VIEWWHERE 조건ORDER BY 컬럼 어디서 가져올 것인지 -&gt; FROM무엇을 가져올 것인지 -&gt; SELECT어떻게 가져올 것인지 -&gt; WHERE 자주 쓰이며 설명할게 없어서 예시로 대체예시) INSERT문: 데이터를 입력하여 삽입 할 때 사용하는 명령문 자주 쓰이며 설명할게 없어서 예시로 대체예시) VALUES 대신에 SELECT구문을 이용하여 입력 해 넣는것도 가능 UPDATE문: 기존 데이터를 수정 할 때 사용하는 명령문 아래의 형태를 띄며 대체 할 데이터를 SET 라는 문구로 가져가야 한다는 게 포인트 1234UPDATE 테이블명SET 컬럼1 = 변경 할 값 1, 컬럼2 = 변경 할 값 2, ...WHERE 조건; 예시) MERGE문 (병합): 조건을 비교하여 테이블에 해당 조건에 맞는 데이터가 없으면 insert, 있으면 update하는 명령문 아래의 형태를 띄며 굉장히 복잡하다; 12345678910MERGE INTO 테이블명 USING (update)나 insert 될 데이터의 원천) ON (update 될 조건)WHEN MATCHED THEN SET 컬럼1 = 값1, ...WHERE update 조건 DELETE WHERE update_delete 조건WHEN NOT MATCHED THEN INSERT (컬럼1, ...) VALUES (값1, ...) WHERE insert 조건; 예시) DELETE문: 데이터를 삭제 할 때 사용하는 명령문 설명할게 없어서 예시로 대체예시) COMMIT, ROLLBACK, TRUNCATE COMMIT : 변경한 데이터를 DB에 마지막으로 반영ROLLBACK : 반대로 변경한 데이터를 변경하기 이전 상태로 되돌림TRUNCATE: 한번 실행 시 데이터 바로 삭제, rollback으로 적용 안됨 ex3_5 테이블 생성 명령프롬프트에서 DB로 조회 commit 하기 다시 명령프롬프트에서 DB로 조회 의사컬럼: 테이블의 컬럼처럼 동작하지만 실제로 테이블에 저장되지 않는 컬럼 컬럼중 ROWNUM과 ROWID를 이용해봄. ROWNUM로 조회가 가능하다, 행의 번호 정도로 인식 됨.예시) 테이블 생성시 각자 다른 ROWID가 생성되어 그걸로 조회도 가능하다!예시)","link":"/2022/04/26/0426_SQL_Query/"},{"title":"데이터베이스의 객체 2","text":"0426_Database_Object_02제약 조건 NOT NULL : 해당 칼럼에는 NULL값을 입력 할 수 없음. NOT NULL 조건을 걸었더니 에러가 뜨는것이 확인됨. USER_CONSTRAINTS 명령어로 계약조건을 확인 할 수 있다.type이 c로 나오는 모습 UNIQUE : 중복되는 값을 입력 할 수 없음 하지만 NUll값에 의한건 해당안됨. 기본키 : 기본키의 예시중 하나로 PRIMARY는 NOTNULL과 UNIQUE의 특성을 반영한 KEY이다. constraint를 찍어본 결과 type이 p로 찍히는 모습. 외래키 : 테이블간의 참조 데이터 무결성을 위한 제약조건ex) table1의 컬럼1과 table2의 컬럼1을 연결하는식의 방식 CHECK : 컬럼에 입력되는 데이터를 체크해 특정 조건에 맞는 데이터만 입력 받고 그렇지 않으면 오류를 출력 —— 조건에 맞지 않기에 오류가 발생하고 조건에 맞춰 데이터를 입력하는 모습 DEFAULT : 따로 입력하지 않아도 기본적으로 출력되게 하는 값들값을 넣으려면 형식에 맞춰 입력시켜줘야함.ex) 날짜 형식 ‘22/04/23’ , 숫자 형식 ‘1’ or 1 테이블 변경 컬럼명 변경 컬럼 타입 변경 컬럼 추가 컬럼 삭제 계약조건 추가 계약조건 삭제 테이블 복사 뷰(view) : 하나 이상의 테이블이나 다른 뷰의 데이터를 볼 수 있게 하는 데이터베이스 객체=⇒ 테이블과 비슷 뷰 생성 뷰 삭제 인덱스 : 테이블에 있는 데이터를 빨리 찾기 위한 용도의 데이터베이스객체 인덱스를 분류하면 다음과 같이 분류 할 수 있다. 인덱스 구성 컬럼 개수에 따른 분류 : 단일 인덱스와 결합 인덱스 유일성 여부에 따른 분류: unique 인덱스, non-unique 인덱스 인덱스 내부 구조에 따른 분류: B-tree 인덱스, 비트맵 인덱스, 함수 기반 인덱스 예시) unique 인덱스를 만들고,ex2_10에 적용한 모습 —— 앞서 제약조건에서 언급한 unique와 같은 성질을 띔 제약조건을 걸어두고 특징을 본 모습 마치며 컬럼명이나 테이블명은 대부분 대문자로 들어가기때문에 가급적 대문자로 적어두는게 문제가 덜 발생할것같다.","link":"/2022/04/26/0426_Database_Object_02/"},{"title":"조인과 서브쿼리","text":"0428_Join_and_Sub_QueryERD(Entity Relationship Diagram): 테이블끼리의 관계를 표현한 도표 내부 조인, 외부 조인 동등 조인: WHERE 절에서 등호를 사용하여 2개 이상의 테이블이나 뷰를 연결하는 것 세미 조인서브쿼리를 이용하여 서브쿼리에 존재하는 데이터를 메인 쿼리에서 추출하는 것 (IN과 EXISTS가 있음) IN 사용 예시) EXISTS 사용 예시) 안티 조인세미조인 개념의 반대. NOT IN이나 NOT EXISTS를 사용 셀프 조인동일한 한 테이블을 사용하여 조인하는 방법 예시) 외부 조인: (+)를 사용하며 사용하며, 조건에 만족하지 않더라도 데이터를 모두 추출.(+)를 붙여주면 해당 테이블을 기준으로 조건에 맞는게 없다면 NULL값으로 반환. 카타시안 조인: WHERE절에 조인 조건이 없는 조인을 말하며, 결과 건수는 테이블들의 곱으로 나온다. ANSI조인 ANSI 조인: ANSI SQL문법을 사용한 조인이며, WHERE절이 아닌 FROM절에 들어간다. 내부 조인의 예시) 외부조인의 예시) CROSS 조인조인 조건을 명시하지 않는 CROSS조인(테이블들의 곱만큼의 결과 건수가 나옴.) FULL OUTER 조인외부 조인의 하나로 ANSI조인에서만 제공하는 기능 다음과 같은 결과를 조회 할 수 있음. 서브쿼리 SQL문장 안에서 보조로 사용되는 또 다른 SELECT문 메인 쿼리와 연관성 없는 서브쿼리: 메인 테이블과 조인 조건이 걸리지 않는 서브쿼리 메인 쿼리와 연관성이 있는 서브쿼리: 메인 테이블과 조인 조건이 걸린 서브 쿼리 인라인 뷰: FROM 절에 사용하는 서브쿼리 퀴즈 101번 사원의 정보를 조회하기(정답 참고) (각 테이블 연결하여 마무리)","link":"/2022/04/28/0428_Join_and_Sub_Query/"},{"title":"GROUP 쿼리, 집합 연산자","text":"0428_Group_Query_and_SET_Operator기본 집계 함수 COUNT(expr): 행 개수를 반환 (NULL값은 계산 안됨.) 1-1. DISTINCT : 해당 컬럼을 유일한 값으로 조회 SUM(exopr): 전체 합계를 반환 AVG(expr): 평균값을 반환 MIN(expr), MAX(expr): 최소값과 최대값을 반환 VARIANCE(expr), STDDEV(expr): 분산과 표준편차를 반환 GROUP BY절, HAVING절 GROUP BY: 해당 컬럼의 값이 같은 것 끼리 묶어서 반환—&gt; 참고) SELECT문에서 선언 된 컬럼명이나 표현식 중 집계함수를 제외하고는 모두 GROUP BY절에서 선언해야 한다!! HAVING 절: GROUP BY절 뒤에 위치하며, GROUP BY 한 결과에 조건을 제시하여 해당하는 데이터를 반환 ROLLUP절, CUBE절: 소그룹간의 합계를 계산 ROLLUP절: 합계 결과를 아래에 붙여 출력 CUBE절: 합계 결과를 위에 붙여 출력 집합(SET) 연산자 UNION, INTERSECT: 합집합과 교집합의 역할 MINUS: 차집합을 의미 (앞의 데이터에서 뒤의 데이터를 뺀 나머지) 집합 연산자 사용시 유의 사항 SELECT리스트의 개수와 데이터 타입이 일치해야한다. 집합 연산자로 SELECT문을 연결할 때 ORDER BY절은 맨 마지막에서만 사용 가능 BLOB, CLOB, BfILE타입의 컬럼에 대해서는 집합 연산자를 사용 할 수 없다. UNION, INTERSECT, MINUS 연산자는 LONG형 컬럼에는 사용 할 수 없다.","link":"/2022/04/28/0428_Group_Query_and_SET_Operator/"},{"title":"SQL 함수","text":"0428_SQL_Function숫자 함수 ABS(n): 절대값을 반환 CEIL(n), FLOOR(n): FLOOR는 가우스의 개념으로 n과 같거나 n보다 작은 정수중에 가장 큰 정수를 뜻함. ( CEIL은 반대의 의미) ROUND(n, i), TRUNC(n1, i): ROUND는 n의 소수점 (i + 1)번째의 자리에서 반올림.: TRUNC는 n의 소수점 i번째의 자리에서 뒷부분을 다 0으로 변환 POWER(n1, n2), SQRT(n): 제곱과 제곱근을 반환 MOD(n1, n2), REMAINDER(n1, n2): MOD는 n1에서 n2를 나눈 나머지 값: REMAINDER는 그 나머지에서 n2를 뺀 음수의 값을 반환 EXP(n), LN(n), LOG(n2, n1): EXP는 지수 함수 e(2.718…)의 n제곱의 값: LN은 밑수를 e로 하여 n의 로그 값: LOG는 밑수를 n2로 하여 n1의 로그 값을 반환 문자 함수 INITCAP(char), LOWER(char), UPPER(char): INITCAP은 각 영단어의 첫번째를 대문자로 나머지는 소문자로 변환: LOWER, UPPER는 문자열을 소문자, 대문자로 변환 CONCAT(char1, char2), SUBSTR(char, n, len): CONCAT은 문자열을 붙여 반환: SUBSTR은 문자열의 n번째 문자부터 len개의 문자를 반환 LTRIM(char, set), RTRIM(char, set): 문자열의 왼쪽 / 오른쪽에서 set를 제거하고 반환 LPAD(name, n, set), RPAD(name, n, set): name이라는 컬럼에서 문자열의 길이가 n이 될 때 까지 set를 왼쪽 / 오른쪽에 입력 REPLACE(char, search, change), TRANSLATE(char, search, change): char 문자열에서 search 문자열을 찾아 change 문자열로 바꿈. TRANSLATE는 문자 하나씩 찾아 바꾸므로 권하지는 않음 INSTR(char, search, start, n), LENGTH(char): INSTR은 char 문자열에서 start번째의 문자에서 출발하여 n번째 search 문자열이 몇 번째 자리에 위치 해 있는지 반환: LENGTH는 char문자열의 길이(문자의 개수)를 반환 날짜 함수 SYSDATE, SYSTIMESTAMP: 현재 날짜와 시간을 반환 ADD_MONTHS(date, n): date날짜에 n달을 더한 후 반환 MONTHS_BETWEEN(date1, date2): date1의 달에서 date2의 달을 뺀 개월 수를 반환 LAST_DAY(date): 그 달의 마지막 일자를 반환 ROUND(date, format), TRUNC(date, format): ROUND는 format에 따라 반올림 한 날짜TRUNC는 format을 기준으로 뒷자리를 잘라낸 날짜를 반환 NEXT_DAY(date, char): date날짜부터 char 날짜가 되는 날짜를 반환 변환 함수 형변환 TO_CHAR (data, format): data를 format의 형태에 맞게 반환 TO_NUMBER (data): data를 NUMBER 형태로 반환 TO_DATE(data, format), TO_TIMESTAMP(data, format): data를 format형태로 반환 NULL관련 함수 NVL(expr1, expr2) WHERE expr1 IS NULL: expr1의 컬럼이 null일때 expr2의 컬럼을 반환 NVL2(expr1, expr2, expr3): expr1이 null이 아니면 expr2 실행, expr1이 null이면 expr3을 실행 COALESCE(expr1, expr2, …): expr중에 처음으로 null이 안되는 조건의 값으로 반환 LNNVL(조건식): 조건식이 NULL이나 부정문이 나올 때, TRUE를 반환, 조건식이 참 값이 나오면 FALSE를 반환한다. NULLIF(expr1, expr2): expr1과 expr2를 비교해 같으면 NULL을 같지 않으면 expr1을 반환 기타 함수 GREATEST(data1, data2, …), LEAST(data1, data2, …): 데이터 값 중에서 가장 큰 값과 가장 작은 값을 반환 DECODE(expr, search1, result1, search2, result2, … , default): expr과 search1을 비교해 두 값이 같으면 result1을 반환 같지 않으면 search2와 비교해 값이 같으면 result2를 반환을 반복하여 같은 값이 없으면 default로 값을 반환","link":"/2022/04/28/0428_SQL_Function/"},{"title":"SQL Query문 2","text":"0428_SQL_Query_02연산자수식 연산자: +, - , *, / 문자 연산자: ‘ || ’ 예시) 두 개의 컬럼을 사이에 ‘-’를 붙여 하나의 컬럼으로 출력 논리 연산자: &lt;, &lt;=, !=, 등등이 있음. 표현식: CASE WHEN 조건 THEN … ELSE … END 조건식비교 조건식ANY, SOME : OR연산자와 같은 개념ALL : AND연산자와 같은 개념 대표적으로 ANY 를 사용한 예시) 논리 조건식: AND, OR, NOT을 이용하여 조건을 TRUE / FALSE로 반환 NULL 조건식: IS NULL, IS NOT NULL을 이용하여 특정 값이 NULL인지 여부를 체크 1234-- 해당 코드SELECT *FROM test2WHERE col2 IS NOT NULL; BETWEEN AND 조건식: 크거나 같고 작거나 같은 값을 찾음. IN, NOT IN 조건식: ANY와 비슷하지만 ANY는 등호나 논리 연산자와도 함께 사용 가능 EXISTS 조건식: IN과 비슷하지만 서브쿼리 절에서만 사용 가능 서브쿼리 : SQL문 속에 포함되어 있는 또 다른 SQL문 LIKE 조건식: 문자열의 패턴을 검색하여 데이터를 찾음. 밑줄 ( _ )을 이용하여 문자열의 위치 지정도 가능","link":"/2022/04/28/0428_SQL_Query_02/"},{"title":"트럼프카드 덱 만들기","text":"0502_Make_TrumpCard_Deck card_set 리스트로 모으기 12345678910card_set = []pattern_limit = [&quot;♥ &quot;, &quot;♣ &quot;, &quot;♠ &quot;, &quot;◆ &quot;]number_limit = [&quot;A&quot;, 2, 3, 4, 5, 6, 7, 8, 9, 10, &quot;J&quot;, &quot;Q&quot;, &quot;K&quot;]for i in pattern_limit: for j in number_limit: card_one = str(i) + str(j) card_set.append(card_one)print(card_set) 카드 더미에서 랜덤한 카드 하나 추출하기 1print(random.choice(card_set)) 카드의 문양을 알아야 할 때가 있기 때문에 문양을 추출하는 코드 123target = card_set[51]test = target.split(&quot; &quot;)print(test)","link":"/2022/05/02/0502_Make_TrumpCard_Deck/"},{"title":"pip Library Update","text":"0502_Python_pip_Upgrade 데스크탑에서 VSCode를 이용하는중… VSCode에서 git bash를 이용하는데 자꾸 이상한 글귀가 출력됨. 12WARNING: You are using pip version 20.2.1; however, version 22.0.4 is available.You should consider upgrading via the 'c:\\users\\zxcvb\\appdata\\local\\programs\\python\\python38\\python.exe -m pip install --upgrade pip' command. ——&gt;pip를 업그레이드 하라는 뜻으로 보인다. pip의 버전을 확인 ——&gt; 버전을 보아하니 추측이 확신으로 바뀜 pip install –upgrade pip ——&gt; 조금 불안하긴 했지만 list로 확인해보니 최신버전이 다운되어있는 모습 -&gt;(심지어 노란 글귀도 안뜸) 혹시 가상환경에서만 업그레이드가 되었나 싶기에 가상환경 해제하고 확인 ——이번에도 추측은 확신이 되었고… 다시 실행 $ pip install –upgrade pip list로 확인 $ pip list ——&gt; 버전은 업그레이드 되었지만 가상환경이 아닌데도 너무 많은 패키지가 설치되어있는걸 확인 패키지 삭제 $ pip uninstall 패키지 ——&gt; 명령어가 적용되는걸 확인하고 나머지도 지우러 감. 여러 라이브러리를 지우려 할 때 $ pip uninstall 패키지 패키지 패키지 … 청소 끝!","link":"/2022/05/02/0502_Python_pip_Upgrade/"}],"tags":[],"categories":[]}